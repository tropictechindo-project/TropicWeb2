
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Invoice
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Order
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model PaymentTransaction
 * 
 */
export type PaymentTransaction = $Result.DefaultSelection<Prisma.$PaymentTransactionPayload>
/**
 * Model ProductRelation
 * 
 */
export type ProductRelation = $Result.DefaultSelection<Prisma.$ProductRelationPayload>
/**
 * Model RentalPackageItem
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type RentalPackageItem = $Result.DefaultSelection<Prisma.$RentalPackageItemPayload>
/**
 * Model RentalPackage
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type RentalPackage = $Result.DefaultSelection<Prisma.$RentalPackagePayload>
/**
 * Model Product
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductVariant
 * 
 */
export type ProductVariant = $Result.DefaultSelection<Prisma.$ProductVariantPayload>
/**
 * Model ProductUnit
 * 
 */
export type ProductUnit = $Result.DefaultSelection<Prisma.$ProductUnitPayload>
/**
 * Model UnitHistory
 * 
 */
export type UnitHistory = $Result.DefaultSelection<Prisma.$UnitHistoryPayload>
/**
 * Model SystemNotification
 * 
 */
export type SystemNotification = $Result.DefaultSelection<Prisma.$SystemNotificationPayload>
/**
 * Model RentalItem
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type RentalItem = $Result.DefaultSelection<Prisma.$RentalItemPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ChatGroup
 * 
 */
export type ChatGroup = $Result.DefaultSelection<Prisma.$ChatGroupPayload>
/**
 * Model ChatGroupMember
 * 
 */
export type ChatGroupMember = $Result.DefaultSelection<Prisma.$ChatGroupMemberPayload>
/**
 * Model GroupMessage
 * 
 */
export type GroupMessage = $Result.DefaultSelection<Prisma.$GroupMessagePayload>
/**
 * Model SiteSetting
 * 
 */
export type SiteSetting = $Result.DefaultSelection<Prisma.$SiteSettingPayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>
/**
 * Model WorkerAttendance
 * 
 */
export type WorkerAttendance = $Result.DefaultSelection<Prisma.$WorkerAttendancePayload>
/**
 * Model InventorySyncLog
 * 
 */
export type InventorySyncLog = $Result.DefaultSelection<Prisma.$InventorySyncLogPayload>
/**
 * Model WorkerNotification
 * 
 */
export type WorkerNotification = $Result.DefaultSelection<Prisma.$WorkerNotificationPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model NotificationDismissal
 * 
 */
export type NotificationDismissal = $Result.DefaultSelection<Prisma.$NotificationDismissalPayload>
/**
 * Model SystemJobLog
 * 
 */
export type SystemJobLog = $Result.DefaultSelection<Prisma.$SystemJobLogPayload>
/**
 * Model IdempotencyKey
 * 
 */
export type IdempotencyKey = $Result.DefaultSelection<Prisma.$IdempotencyKeyPayload>
/**
 * Model JobQueue
 * 
 */
export type JobQueue = $Result.DefaultSelection<Prisma.$JobQueuePayload>
/**
 * Model CronLock
 * 
 */
export type CronLock = $Result.DefaultSelection<Prisma.$CronLockPayload>
/**
 * Model AiAgent
 * 
 */
export type AiAgent = $Result.DefaultSelection<Prisma.$AiAgentPayload>
/**
 * Model AiPermission
 * 
 */
export type AiPermission = $Result.DefaultSelection<Prisma.$AiPermissionPayload>
/**
 * Model AiAction
 * 
 */
export type AiAction = $Result.DefaultSelection<Prisma.$AiActionPayload>
/**
 * Model AiTrainingData
 * 
 */
export type AiTrainingData = $Result.DefaultSelection<Prisma.$AiTrainingDataPayload>
/**
 * Model Vehicle
 * 
 */
export type Vehicle = $Result.DefaultSelection<Prisma.$VehiclePayload>
/**
 * Model Delivery
 * 
 */
export type Delivery = $Result.DefaultSelection<Prisma.$DeliveryPayload>
/**
 * Model DeliveryItem
 * 
 */
export type DeliveryItem = $Result.DefaultSelection<Prisma.$DeliveryItemPayload>
/**
 * Model DeliveryLog
 * 
 */
export type DeliveryLog = $Result.DefaultSelection<Prisma.$DeliveryLogPayload>
/**
 * Model DeliveryEditLog
 * 
 */
export type DeliveryEditLog = $Result.DefaultSelection<Prisma.$DeliveryEditLogPayload>
/**
 * Model SpecialOffer
 * 
 */
export type SpecialOffer = $Result.DefaultSelection<Prisma.$SpecialOfferPayload>
/**
 * Model ContactMessage
 * 
 */
export type ContactMessage = $Result.DefaultSelection<Prisma.$ContactMessagePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const attendance_status: {
  PRESENT: 'PRESENT',
  ABSENT: 'ABSENT',
  LATE: 'LATE',
  LEAVE: 'LEAVE'
};

export type attendance_status = (typeof attendance_status)[keyof typeof attendance_status]


export const inventory_source: {
  ADMIN: 'ADMIN',
  WORKER: 'WORKER'
};

export type inventory_source = (typeof inventory_source)[keyof typeof inventory_source]


export const OrderStatus: {
  DRAFT: 'DRAFT',
  AWAITING_PAYMENT: 'AWAITING_PAYMENT',
  PAYMENT_PENDING_VERIFICATION: 'PAYMENT_PENDING_VERIFICATION',
  PAID: 'PAID',
  READY_FOR_FULFILLMENT: 'READY_FOR_FULFILLMENT',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  FAILED: 'FAILED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const PaymentProvider: {
  STRIPE: 'STRIPE',
  WISE: 'WISE',
  PAYPAL: 'PAYPAL',
  APPLE_PAY: 'APPLE_PAY',
  CARD: 'CARD',
  CRYPTO: 'CRYPTO',
  EDC: 'EDC',
  QRIS: 'QRIS',
  BANK_TRANSFER: 'BANK_TRANSFER',
  CASH: 'CASH'
};

export type PaymentProvider = (typeof PaymentProvider)[keyof typeof PaymentProvider]


export const TransactionStatus: {
  INITIATED: 'INITIATED',
  PENDING_VERIFICATION: 'PENDING_VERIFICATION',
  CONFIRMED: 'CONFIRMED',
  FAILED: 'FAILED',
  EXPIRED: 'EXPIRED'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]


export const RelationType: {
  CROSS_SELL: 'CROSS_SELL',
  UPSELL: 'UPSELL',
  ACCESSORY: 'ACCESSORY'
};

export type RelationType = (typeof RelationType)[keyof typeof RelationType]


export const UnitStatus: {
  AVAILABLE: 'AVAILABLE',
  RESERVED: 'RESERVED',
  RENTED: 'RENTED',
  MAINTENANCE: 'MAINTENANCE',
  LOST: 'LOST'
};

export type UnitStatus = (typeof UnitStatus)[keyof typeof UnitStatus]


export const UnitCondition: {
  GOOD: 'GOOD',
  FAIR: 'FAIR',
  DAMAGED: 'DAMAGED',
  NEEDS_SERVICE: 'NEEDS_SERVICE'
};

export type UnitCondition = (typeof UnitCondition)[keyof typeof UnitCondition]


export const AiAgentSystemName: {
  SALES: 'SALES',
  WORKER: 'WORKER',
  RISK: 'RISK',
  SELLER: 'SELLER',
  MASTER: 'MASTER'
};

export type AiAgentSystemName = (typeof AiAgentSystemName)[keyof typeof AiAgentSystemName]


export const AiActionStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  EXECUTED: 'EXECUTED'
};

export type AiActionStatus = (typeof AiActionStatus)[keyof typeof AiActionStatus]


export const VehicleType: {
  VAN: 'VAN',
  MOTORCYCLE: 'MOTORCYCLE'
};

export type VehicleType = (typeof VehicleType)[keyof typeof VehicleType]


export const VehicleStatus: {
  AVAILABLE: 'AVAILABLE',
  IN_USE: 'IN_USE',
  MAINTENANCE: 'MAINTENANCE'
};

export type VehicleStatus = (typeof VehicleStatus)[keyof typeof VehicleStatus]


export const DeliveryMethod: {
  INTERNAL: 'INTERNAL',
  GOJEK: 'GOJEK'
};

export type DeliveryMethod = (typeof DeliveryMethod)[keyof typeof DeliveryMethod]


export const DeliveryType: {
  DROPOFF: 'DROPOFF',
  PICKUP: 'PICKUP'
};

export type DeliveryType = (typeof DeliveryType)[keyof typeof DeliveryType]


export const DeliveryStatus: {
  QUEUED: 'QUEUED',
  CLAIMED: 'CLAIMED',
  OUT_FOR_DELIVERY: 'OUT_FOR_DELIVERY',
  PAUSED: 'PAUSED',
  DELAYED: 'DELAYED',
  CANCEL_REQUESTED: 'CANCEL_REQUESTED',
  COMPLETED: 'COMPLETED',
  CANCELED: 'CANCELED'
};

export type DeliveryStatus = (typeof DeliveryStatus)[keyof typeof DeliveryStatus]


export const DeliveryRole: {
  ADMIN: 'ADMIN',
  WORKER: 'WORKER',
  SYSTEM: 'SYSTEM'
};

export type DeliveryRole = (typeof DeliveryRole)[keyof typeof DeliveryRole]

}

export type attendance_status = $Enums.attendance_status

export const attendance_status: typeof $Enums.attendance_status

export type inventory_source = $Enums.inventory_source

export const inventory_source: typeof $Enums.inventory_source

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type PaymentProvider = $Enums.PaymentProvider

export const PaymentProvider: typeof $Enums.PaymentProvider

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

export type RelationType = $Enums.RelationType

export const RelationType: typeof $Enums.RelationType

export type UnitStatus = $Enums.UnitStatus

export const UnitStatus: typeof $Enums.UnitStatus

export type UnitCondition = $Enums.UnitCondition

export const UnitCondition: typeof $Enums.UnitCondition

export type AiAgentSystemName = $Enums.AiAgentSystemName

export const AiAgentSystemName: typeof $Enums.AiAgentSystemName

export type AiActionStatus = $Enums.AiActionStatus

export const AiActionStatus: typeof $Enums.AiActionStatus

export type VehicleType = $Enums.VehicleType

export const VehicleType: typeof $Enums.VehicleType

export type VehicleStatus = $Enums.VehicleStatus

export const VehicleStatus: typeof $Enums.VehicleStatus

export type DeliveryMethod = $Enums.DeliveryMethod

export const DeliveryMethod: typeof $Enums.DeliveryMethod

export type DeliveryType = $Enums.DeliveryType

export const DeliveryType: typeof $Enums.DeliveryType

export type DeliveryStatus = $Enums.DeliveryStatus

export const DeliveryStatus: typeof $Enums.DeliveryStatus

export type DeliveryRole = $Enums.DeliveryRole

export const DeliveryRole: typeof $Enums.DeliveryRole

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Invoices
 * const invoices = await prisma.invoice.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Invoices
   * const invoices = await prisma.invoice.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentTransaction`: Exposes CRUD operations for the **PaymentTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentTransactions
    * const paymentTransactions = await prisma.paymentTransaction.findMany()
    * ```
    */
  get paymentTransaction(): Prisma.PaymentTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productRelation`: Exposes CRUD operations for the **ProductRelation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductRelations
    * const productRelations = await prisma.productRelation.findMany()
    * ```
    */
  get productRelation(): Prisma.ProductRelationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rentalPackageItem`: Exposes CRUD operations for the **RentalPackageItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RentalPackageItems
    * const rentalPackageItems = await prisma.rentalPackageItem.findMany()
    * ```
    */
  get rentalPackageItem(): Prisma.RentalPackageItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rentalPackage`: Exposes CRUD operations for the **RentalPackage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RentalPackages
    * const rentalPackages = await prisma.rentalPackage.findMany()
    * ```
    */
  get rentalPackage(): Prisma.RentalPackageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productVariant`: Exposes CRUD operations for the **ProductVariant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductVariants
    * const productVariants = await prisma.productVariant.findMany()
    * ```
    */
  get productVariant(): Prisma.ProductVariantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productUnit`: Exposes CRUD operations for the **ProductUnit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductUnits
    * const productUnits = await prisma.productUnit.findMany()
    * ```
    */
  get productUnit(): Prisma.ProductUnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitHistory`: Exposes CRUD operations for the **UnitHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitHistories
    * const unitHistories = await prisma.unitHistory.findMany()
    * ```
    */
  get unitHistory(): Prisma.UnitHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemNotification`: Exposes CRUD operations for the **SystemNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemNotifications
    * const systemNotifications = await prisma.systemNotification.findMany()
    * ```
    */
  get systemNotification(): Prisma.SystemNotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rentalItem`: Exposes CRUD operations for the **RentalItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RentalItems
    * const rentalItems = await prisma.rentalItem.findMany()
    * ```
    */
  get rentalItem(): Prisma.RentalItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatGroup`: Exposes CRUD operations for the **ChatGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatGroups
    * const chatGroups = await prisma.chatGroup.findMany()
    * ```
    */
  get chatGroup(): Prisma.ChatGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatGroupMember`: Exposes CRUD operations for the **ChatGroupMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatGroupMembers
    * const chatGroupMembers = await prisma.chatGroupMember.findMany()
    * ```
    */
  get chatGroupMember(): Prisma.ChatGroupMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groupMessage`: Exposes CRUD operations for the **GroupMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupMessages
    * const groupMessages = await prisma.groupMessage.findMany()
    * ```
    */
  get groupMessage(): Prisma.GroupMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.siteSetting`: Exposes CRUD operations for the **SiteSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SiteSettings
    * const siteSettings = await prisma.siteSetting.findMany()
    * ```
    */
  get siteSetting(): Prisma.SiteSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workerAttendance`: Exposes CRUD operations for the **WorkerAttendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkerAttendances
    * const workerAttendances = await prisma.workerAttendance.findMany()
    * ```
    */
  get workerAttendance(): Prisma.WorkerAttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventorySyncLog`: Exposes CRUD operations for the **InventorySyncLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventorySyncLogs
    * const inventorySyncLogs = await prisma.inventorySyncLog.findMany()
    * ```
    */
  get inventorySyncLog(): Prisma.InventorySyncLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workerNotification`: Exposes CRUD operations for the **WorkerNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkerNotifications
    * const workerNotifications = await prisma.workerNotification.findMany()
    * ```
    */
  get workerNotification(): Prisma.WorkerNotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationDismissal`: Exposes CRUD operations for the **NotificationDismissal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationDismissals
    * const notificationDismissals = await prisma.notificationDismissal.findMany()
    * ```
    */
  get notificationDismissal(): Prisma.NotificationDismissalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemJobLog`: Exposes CRUD operations for the **SystemJobLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemJobLogs
    * const systemJobLogs = await prisma.systemJobLog.findMany()
    * ```
    */
  get systemJobLog(): Prisma.SystemJobLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.idempotencyKey`: Exposes CRUD operations for the **IdempotencyKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IdempotencyKeys
    * const idempotencyKeys = await prisma.idempotencyKey.findMany()
    * ```
    */
  get idempotencyKey(): Prisma.IdempotencyKeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobQueue`: Exposes CRUD operations for the **JobQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobQueues
    * const jobQueues = await prisma.jobQueue.findMany()
    * ```
    */
  get jobQueue(): Prisma.JobQueueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cronLock`: Exposes CRUD operations for the **CronLock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CronLocks
    * const cronLocks = await prisma.cronLock.findMany()
    * ```
    */
  get cronLock(): Prisma.CronLockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiAgent`: Exposes CRUD operations for the **AiAgent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiAgents
    * const aiAgents = await prisma.aiAgent.findMany()
    * ```
    */
  get aiAgent(): Prisma.AiAgentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiPermission`: Exposes CRUD operations for the **AiPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiPermissions
    * const aiPermissions = await prisma.aiPermission.findMany()
    * ```
    */
  get aiPermission(): Prisma.AiPermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiAction`: Exposes CRUD operations for the **AiAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiActions
    * const aiActions = await prisma.aiAction.findMany()
    * ```
    */
  get aiAction(): Prisma.AiActionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiTrainingData`: Exposes CRUD operations for the **AiTrainingData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiTrainingData
    * const aiTrainingData = await prisma.aiTrainingData.findMany()
    * ```
    */
  get aiTrainingData(): Prisma.AiTrainingDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicle`: Exposes CRUD operations for the **Vehicle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicles
    * const vehicles = await prisma.vehicle.findMany()
    * ```
    */
  get vehicle(): Prisma.VehicleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.delivery`: Exposes CRUD operations for the **Delivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deliveries
    * const deliveries = await prisma.delivery.findMany()
    * ```
    */
  get delivery(): Prisma.DeliveryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryItem`: Exposes CRUD operations for the **DeliveryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryItems
    * const deliveryItems = await prisma.deliveryItem.findMany()
    * ```
    */
  get deliveryItem(): Prisma.DeliveryItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryLog`: Exposes CRUD operations for the **DeliveryLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryLogs
    * const deliveryLogs = await prisma.deliveryLog.findMany()
    * ```
    */
  get deliveryLog(): Prisma.DeliveryLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryEditLog`: Exposes CRUD operations for the **DeliveryEditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryEditLogs
    * const deliveryEditLogs = await prisma.deliveryEditLog.findMany()
    * ```
    */
  get deliveryEditLog(): Prisma.DeliveryEditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.specialOffer`: Exposes CRUD operations for the **SpecialOffer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpecialOffers
    * const specialOffers = await prisma.specialOffer.findMany()
    * ```
    */
  get specialOffer(): Prisma.SpecialOfferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactMessage`: Exposes CRUD operations for the **ContactMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactMessages
    * const contactMessages = await prisma.contactMessage.findMany()
    * ```
    */
  get contactMessage(): Prisma.ContactMessageDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.1
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Invoice: 'Invoice',
    Order: 'Order',
    PaymentTransaction: 'PaymentTransaction',
    ProductRelation: 'ProductRelation',
    RentalPackageItem: 'RentalPackageItem',
    RentalPackage: 'RentalPackage',
    Product: 'Product',
    ProductVariant: 'ProductVariant',
    ProductUnit: 'ProductUnit',
    UnitHistory: 'UnitHistory',
    SystemNotification: 'SystemNotification',
    RentalItem: 'RentalItem',
    User: 'User',
    ChatGroup: 'ChatGroup',
    ChatGroupMember: 'ChatGroupMember',
    GroupMessage: 'GroupMessage',
    SiteSetting: 'SiteSetting',
    ActivityLog: 'ActivityLog',
    WorkerAttendance: 'WorkerAttendance',
    InventorySyncLog: 'InventorySyncLog',
    WorkerNotification: 'WorkerNotification',
    Message: 'Message',
    NotificationDismissal: 'NotificationDismissal',
    SystemJobLog: 'SystemJobLog',
    IdempotencyKey: 'IdempotencyKey',
    JobQueue: 'JobQueue',
    CronLock: 'CronLock',
    AiAgent: 'AiAgent',
    AiPermission: 'AiPermission',
    AiAction: 'AiAction',
    AiTrainingData: 'AiTrainingData',
    Vehicle: 'Vehicle',
    Delivery: 'Delivery',
    DeliveryItem: 'DeliveryItem',
    DeliveryLog: 'DeliveryLog',
    DeliveryEditLog: 'DeliveryEditLog',
    SpecialOffer: 'SpecialOffer',
    ContactMessage: 'ContactMessage'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "invoice" | "order" | "paymentTransaction" | "productRelation" | "rentalPackageItem" | "rentalPackage" | "product" | "productVariant" | "productUnit" | "unitHistory" | "systemNotification" | "rentalItem" | "user" | "chatGroup" | "chatGroupMember" | "groupMessage" | "siteSetting" | "activityLog" | "workerAttendance" | "inventorySyncLog" | "workerNotification" | "message" | "notificationDismissal" | "systemJobLog" | "idempotencyKey" | "jobQueue" | "cronLock" | "aiAgent" | "aiPermission" | "aiAction" | "aiTrainingData" | "vehicle" | "delivery" | "deliveryItem" | "deliveryLog" | "deliveryEditLog" | "specialOffer" | "contactMessage"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      PaymentTransaction: {
        payload: Prisma.$PaymentTransactionPayload<ExtArgs>
        fields: Prisma.PaymentTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          findFirst: {
            args: Prisma.PaymentTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          findMany: {
            args: Prisma.PaymentTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>[]
          }
          create: {
            args: Prisma.PaymentTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          createMany: {
            args: Prisma.PaymentTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>[]
          }
          delete: {
            args: Prisma.PaymentTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          update: {
            args: Prisma.PaymentTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          deleteMany: {
            args: Prisma.PaymentTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>[]
          }
          upsert: {
            args: Prisma.PaymentTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          aggregate: {
            args: Prisma.PaymentTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentTransaction>
          }
          groupBy: {
            args: Prisma.PaymentTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentTransactionCountAggregateOutputType> | number
          }
        }
      }
      ProductRelation: {
        payload: Prisma.$ProductRelationPayload<ExtArgs>
        fields: Prisma.ProductRelationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductRelationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRelationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductRelationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRelationPayload>
          }
          findFirst: {
            args: Prisma.ProductRelationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRelationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductRelationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRelationPayload>
          }
          findMany: {
            args: Prisma.ProductRelationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRelationPayload>[]
          }
          create: {
            args: Prisma.ProductRelationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRelationPayload>
          }
          createMany: {
            args: Prisma.ProductRelationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductRelationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRelationPayload>[]
          }
          delete: {
            args: Prisma.ProductRelationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRelationPayload>
          }
          update: {
            args: Prisma.ProductRelationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRelationPayload>
          }
          deleteMany: {
            args: Prisma.ProductRelationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductRelationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductRelationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRelationPayload>[]
          }
          upsert: {
            args: Prisma.ProductRelationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRelationPayload>
          }
          aggregate: {
            args: Prisma.ProductRelationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductRelation>
          }
          groupBy: {
            args: Prisma.ProductRelationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductRelationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductRelationCountArgs<ExtArgs>
            result: $Utils.Optional<ProductRelationCountAggregateOutputType> | number
          }
        }
      }
      RentalPackageItem: {
        payload: Prisma.$RentalPackageItemPayload<ExtArgs>
        fields: Prisma.RentalPackageItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RentalPackageItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPackageItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RentalPackageItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPackageItemPayload>
          }
          findFirst: {
            args: Prisma.RentalPackageItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPackageItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RentalPackageItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPackageItemPayload>
          }
          findMany: {
            args: Prisma.RentalPackageItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPackageItemPayload>[]
          }
          create: {
            args: Prisma.RentalPackageItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPackageItemPayload>
          }
          createMany: {
            args: Prisma.RentalPackageItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RentalPackageItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPackageItemPayload>[]
          }
          delete: {
            args: Prisma.RentalPackageItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPackageItemPayload>
          }
          update: {
            args: Prisma.RentalPackageItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPackageItemPayload>
          }
          deleteMany: {
            args: Prisma.RentalPackageItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RentalPackageItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RentalPackageItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPackageItemPayload>[]
          }
          upsert: {
            args: Prisma.RentalPackageItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPackageItemPayload>
          }
          aggregate: {
            args: Prisma.RentalPackageItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRentalPackageItem>
          }
          groupBy: {
            args: Prisma.RentalPackageItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<RentalPackageItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.RentalPackageItemCountArgs<ExtArgs>
            result: $Utils.Optional<RentalPackageItemCountAggregateOutputType> | number
          }
        }
      }
      RentalPackage: {
        payload: Prisma.$RentalPackagePayload<ExtArgs>
        fields: Prisma.RentalPackageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RentalPackageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPackagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RentalPackageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPackagePayload>
          }
          findFirst: {
            args: Prisma.RentalPackageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPackagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RentalPackageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPackagePayload>
          }
          findMany: {
            args: Prisma.RentalPackageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPackagePayload>[]
          }
          create: {
            args: Prisma.RentalPackageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPackagePayload>
          }
          createMany: {
            args: Prisma.RentalPackageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RentalPackageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPackagePayload>[]
          }
          delete: {
            args: Prisma.RentalPackageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPackagePayload>
          }
          update: {
            args: Prisma.RentalPackageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPackagePayload>
          }
          deleteMany: {
            args: Prisma.RentalPackageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RentalPackageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RentalPackageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPackagePayload>[]
          }
          upsert: {
            args: Prisma.RentalPackageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPackagePayload>
          }
          aggregate: {
            args: Prisma.RentalPackageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRentalPackage>
          }
          groupBy: {
            args: Prisma.RentalPackageGroupByArgs<ExtArgs>
            result: $Utils.Optional<RentalPackageGroupByOutputType>[]
          }
          count: {
            args: Prisma.RentalPackageCountArgs<ExtArgs>
            result: $Utils.Optional<RentalPackageCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductVariant: {
        payload: Prisma.$ProductVariantPayload<ExtArgs>
        fields: Prisma.ProductVariantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductVariantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductVariantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          findFirst: {
            args: Prisma.ProductVariantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductVariantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          findMany: {
            args: Prisma.ProductVariantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
          }
          create: {
            args: Prisma.ProductVariantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          createMany: {
            args: Prisma.ProductVariantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductVariantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
          }
          delete: {
            args: Prisma.ProductVariantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          update: {
            args: Prisma.ProductVariantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          deleteMany: {
            args: Prisma.ProductVariantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductVariantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductVariantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
          }
          upsert: {
            args: Prisma.ProductVariantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          aggregate: {
            args: Prisma.ProductVariantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductVariant>
          }
          groupBy: {
            args: Prisma.ProductVariantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductVariantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductVariantCountArgs<ExtArgs>
            result: $Utils.Optional<ProductVariantCountAggregateOutputType> | number
          }
        }
      }
      ProductUnit: {
        payload: Prisma.$ProductUnitPayload<ExtArgs>
        fields: Prisma.ProductUnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductUnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductUnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductUnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductUnitPayload>
          }
          findFirst: {
            args: Prisma.ProductUnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductUnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductUnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductUnitPayload>
          }
          findMany: {
            args: Prisma.ProductUnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductUnitPayload>[]
          }
          create: {
            args: Prisma.ProductUnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductUnitPayload>
          }
          createMany: {
            args: Prisma.ProductUnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductUnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductUnitPayload>[]
          }
          delete: {
            args: Prisma.ProductUnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductUnitPayload>
          }
          update: {
            args: Prisma.ProductUnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductUnitPayload>
          }
          deleteMany: {
            args: Prisma.ProductUnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUnitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductUnitPayload>[]
          }
          upsert: {
            args: Prisma.ProductUnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductUnitPayload>
          }
          aggregate: {
            args: Prisma.ProductUnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductUnit>
          }
          groupBy: {
            args: Prisma.ProductUnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductUnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductUnitCountArgs<ExtArgs>
            result: $Utils.Optional<ProductUnitCountAggregateOutputType> | number
          }
        }
      }
      UnitHistory: {
        payload: Prisma.$UnitHistoryPayload<ExtArgs>
        fields: Prisma.UnitHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitHistoryPayload>
          }
          findFirst: {
            args: Prisma.UnitHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitHistoryPayload>
          }
          findMany: {
            args: Prisma.UnitHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitHistoryPayload>[]
          }
          create: {
            args: Prisma.UnitHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitHistoryPayload>
          }
          createMany: {
            args: Prisma.UnitHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitHistoryPayload>[]
          }
          delete: {
            args: Prisma.UnitHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitHistoryPayload>
          }
          update: {
            args: Prisma.UnitHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitHistoryPayload>
          }
          deleteMany: {
            args: Prisma.UnitHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitHistoryPayload>[]
          }
          upsert: {
            args: Prisma.UnitHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitHistoryPayload>
          }
          aggregate: {
            args: Prisma.UnitHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitHistory>
          }
          groupBy: {
            args: Prisma.UnitHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<UnitHistoryCountAggregateOutputType> | number
          }
        }
      }
      SystemNotification: {
        payload: Prisma.$SystemNotificationPayload<ExtArgs>
        fields: Prisma.SystemNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemNotificationPayload>
          }
          findFirst: {
            args: Prisma.SystemNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemNotificationPayload>
          }
          findMany: {
            args: Prisma.SystemNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemNotificationPayload>[]
          }
          create: {
            args: Prisma.SystemNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemNotificationPayload>
          }
          createMany: {
            args: Prisma.SystemNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemNotificationPayload>[]
          }
          delete: {
            args: Prisma.SystemNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemNotificationPayload>
          }
          update: {
            args: Prisma.SystemNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemNotificationPayload>
          }
          deleteMany: {
            args: Prisma.SystemNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemNotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemNotificationPayload>[]
          }
          upsert: {
            args: Prisma.SystemNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemNotificationPayload>
          }
          aggregate: {
            args: Prisma.SystemNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemNotification>
          }
          groupBy: {
            args: Prisma.SystemNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<SystemNotificationCountAggregateOutputType> | number
          }
        }
      }
      RentalItem: {
        payload: Prisma.$RentalItemPayload<ExtArgs>
        fields: Prisma.RentalItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RentalItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RentalItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalItemPayload>
          }
          findFirst: {
            args: Prisma.RentalItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RentalItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalItemPayload>
          }
          findMany: {
            args: Prisma.RentalItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalItemPayload>[]
          }
          create: {
            args: Prisma.RentalItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalItemPayload>
          }
          createMany: {
            args: Prisma.RentalItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RentalItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalItemPayload>[]
          }
          delete: {
            args: Prisma.RentalItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalItemPayload>
          }
          update: {
            args: Prisma.RentalItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalItemPayload>
          }
          deleteMany: {
            args: Prisma.RentalItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RentalItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RentalItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalItemPayload>[]
          }
          upsert: {
            args: Prisma.RentalItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalItemPayload>
          }
          aggregate: {
            args: Prisma.RentalItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRentalItem>
          }
          groupBy: {
            args: Prisma.RentalItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<RentalItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.RentalItemCountArgs<ExtArgs>
            result: $Utils.Optional<RentalItemCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ChatGroup: {
        payload: Prisma.$ChatGroupPayload<ExtArgs>
        fields: Prisma.ChatGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupPayload>
          }
          findFirst: {
            args: Prisma.ChatGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupPayload>
          }
          findMany: {
            args: Prisma.ChatGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupPayload>[]
          }
          create: {
            args: Prisma.ChatGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupPayload>
          }
          createMany: {
            args: Prisma.ChatGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupPayload>[]
          }
          delete: {
            args: Prisma.ChatGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupPayload>
          }
          update: {
            args: Prisma.ChatGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupPayload>
          }
          deleteMany: {
            args: Prisma.ChatGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupPayload>[]
          }
          upsert: {
            args: Prisma.ChatGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupPayload>
          }
          aggregate: {
            args: Prisma.ChatGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatGroup>
          }
          groupBy: {
            args: Prisma.ChatGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatGroupCountArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupCountAggregateOutputType> | number
          }
        }
      }
      ChatGroupMember: {
        payload: Prisma.$ChatGroupMemberPayload<ExtArgs>
        fields: Prisma.ChatGroupMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatGroupMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatGroupMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupMemberPayload>
          }
          findFirst: {
            args: Prisma.ChatGroupMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatGroupMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupMemberPayload>
          }
          findMany: {
            args: Prisma.ChatGroupMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupMemberPayload>[]
          }
          create: {
            args: Prisma.ChatGroupMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupMemberPayload>
          }
          createMany: {
            args: Prisma.ChatGroupMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatGroupMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupMemberPayload>[]
          }
          delete: {
            args: Prisma.ChatGroupMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupMemberPayload>
          }
          update: {
            args: Prisma.ChatGroupMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupMemberPayload>
          }
          deleteMany: {
            args: Prisma.ChatGroupMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatGroupMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatGroupMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupMemberPayload>[]
          }
          upsert: {
            args: Prisma.ChatGroupMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatGroupMemberPayload>
          }
          aggregate: {
            args: Prisma.ChatGroupMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatGroupMember>
          }
          groupBy: {
            args: Prisma.ChatGroupMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatGroupMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupMemberCountAggregateOutputType> | number
          }
        }
      }
      GroupMessage: {
        payload: Prisma.$GroupMessagePayload<ExtArgs>
        fields: Prisma.GroupMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagePayload>
          }
          findFirst: {
            args: Prisma.GroupMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagePayload>
          }
          findMany: {
            args: Prisma.GroupMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagePayload>[]
          }
          create: {
            args: Prisma.GroupMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagePayload>
          }
          createMany: {
            args: Prisma.GroupMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagePayload>[]
          }
          delete: {
            args: Prisma.GroupMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagePayload>
          }
          update: {
            args: Prisma.GroupMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagePayload>
          }
          deleteMany: {
            args: Prisma.GroupMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagePayload>[]
          }
          upsert: {
            args: Prisma.GroupMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessagePayload>
          }
          aggregate: {
            args: Prisma.GroupMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupMessage>
          }
          groupBy: {
            args: Prisma.GroupMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupMessageCountArgs<ExtArgs>
            result: $Utils.Optional<GroupMessageCountAggregateOutputType> | number
          }
        }
      }
      SiteSetting: {
        payload: Prisma.$SiteSettingPayload<ExtArgs>
        fields: Prisma.SiteSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingPayload>
          }
          findFirst: {
            args: Prisma.SiteSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingPayload>
          }
          findMany: {
            args: Prisma.SiteSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingPayload>[]
          }
          create: {
            args: Prisma.SiteSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingPayload>
          }
          createMany: {
            args: Prisma.SiteSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SiteSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingPayload>[]
          }
          delete: {
            args: Prisma.SiteSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingPayload>
          }
          update: {
            args: Prisma.SiteSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingPayload>
          }
          deleteMany: {
            args: Prisma.SiteSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SiteSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SiteSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingPayload>[]
          }
          upsert: {
            args: Prisma.SiteSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingPayload>
          }
          aggregate: {
            args: Prisma.SiteSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSiteSetting>
          }
          groupBy: {
            args: Prisma.SiteSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SiteSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SiteSettingCountArgs<ExtArgs>
            result: $Utils.Optional<SiteSettingCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      WorkerAttendance: {
        payload: Prisma.$WorkerAttendancePayload<ExtArgs>
        fields: Prisma.WorkerAttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkerAttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerAttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkerAttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerAttendancePayload>
          }
          findFirst: {
            args: Prisma.WorkerAttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerAttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkerAttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerAttendancePayload>
          }
          findMany: {
            args: Prisma.WorkerAttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerAttendancePayload>[]
          }
          create: {
            args: Prisma.WorkerAttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerAttendancePayload>
          }
          createMany: {
            args: Prisma.WorkerAttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkerAttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerAttendancePayload>[]
          }
          delete: {
            args: Prisma.WorkerAttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerAttendancePayload>
          }
          update: {
            args: Prisma.WorkerAttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerAttendancePayload>
          }
          deleteMany: {
            args: Prisma.WorkerAttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkerAttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkerAttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerAttendancePayload>[]
          }
          upsert: {
            args: Prisma.WorkerAttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerAttendancePayload>
          }
          aggregate: {
            args: Prisma.WorkerAttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkerAttendance>
          }
          groupBy: {
            args: Prisma.WorkerAttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkerAttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkerAttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<WorkerAttendanceCountAggregateOutputType> | number
          }
        }
      }
      InventorySyncLog: {
        payload: Prisma.$InventorySyncLogPayload<ExtArgs>
        fields: Prisma.InventorySyncLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventorySyncLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySyncLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventorySyncLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySyncLogPayload>
          }
          findFirst: {
            args: Prisma.InventorySyncLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySyncLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventorySyncLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySyncLogPayload>
          }
          findMany: {
            args: Prisma.InventorySyncLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySyncLogPayload>[]
          }
          create: {
            args: Prisma.InventorySyncLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySyncLogPayload>
          }
          createMany: {
            args: Prisma.InventorySyncLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventorySyncLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySyncLogPayload>[]
          }
          delete: {
            args: Prisma.InventorySyncLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySyncLogPayload>
          }
          update: {
            args: Prisma.InventorySyncLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySyncLogPayload>
          }
          deleteMany: {
            args: Prisma.InventorySyncLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventorySyncLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventorySyncLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySyncLogPayload>[]
          }
          upsert: {
            args: Prisma.InventorySyncLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventorySyncLogPayload>
          }
          aggregate: {
            args: Prisma.InventorySyncLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventorySyncLog>
          }
          groupBy: {
            args: Prisma.InventorySyncLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventorySyncLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventorySyncLogCountArgs<ExtArgs>
            result: $Utils.Optional<InventorySyncLogCountAggregateOutputType> | number
          }
        }
      }
      WorkerNotification: {
        payload: Prisma.$WorkerNotificationPayload<ExtArgs>
        fields: Prisma.WorkerNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkerNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkerNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerNotificationPayload>
          }
          findFirst: {
            args: Prisma.WorkerNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkerNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerNotificationPayload>
          }
          findMany: {
            args: Prisma.WorkerNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerNotificationPayload>[]
          }
          create: {
            args: Prisma.WorkerNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerNotificationPayload>
          }
          createMany: {
            args: Prisma.WorkerNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkerNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerNotificationPayload>[]
          }
          delete: {
            args: Prisma.WorkerNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerNotificationPayload>
          }
          update: {
            args: Prisma.WorkerNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerNotificationPayload>
          }
          deleteMany: {
            args: Prisma.WorkerNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkerNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkerNotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerNotificationPayload>[]
          }
          upsert: {
            args: Prisma.WorkerNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerNotificationPayload>
          }
          aggregate: {
            args: Prisma.WorkerNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkerNotification>
          }
          groupBy: {
            args: Prisma.WorkerNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkerNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkerNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<WorkerNotificationCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      NotificationDismissal: {
        payload: Prisma.$NotificationDismissalPayload<ExtArgs>
        fields: Prisma.NotificationDismissalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationDismissalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationDismissalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationDismissalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationDismissalPayload>
          }
          findFirst: {
            args: Prisma.NotificationDismissalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationDismissalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationDismissalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationDismissalPayload>
          }
          findMany: {
            args: Prisma.NotificationDismissalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationDismissalPayload>[]
          }
          create: {
            args: Prisma.NotificationDismissalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationDismissalPayload>
          }
          createMany: {
            args: Prisma.NotificationDismissalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationDismissalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationDismissalPayload>[]
          }
          delete: {
            args: Prisma.NotificationDismissalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationDismissalPayload>
          }
          update: {
            args: Prisma.NotificationDismissalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationDismissalPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDismissalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationDismissalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationDismissalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationDismissalPayload>[]
          }
          upsert: {
            args: Prisma.NotificationDismissalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationDismissalPayload>
          }
          aggregate: {
            args: Prisma.NotificationDismissalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationDismissal>
          }
          groupBy: {
            args: Prisma.NotificationDismissalGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationDismissalGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationDismissalCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationDismissalCountAggregateOutputType> | number
          }
        }
      }
      SystemJobLog: {
        payload: Prisma.$SystemJobLogPayload<ExtArgs>
        fields: Prisma.SystemJobLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemJobLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemJobLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemJobLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemJobLogPayload>
          }
          findFirst: {
            args: Prisma.SystemJobLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemJobLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemJobLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemJobLogPayload>
          }
          findMany: {
            args: Prisma.SystemJobLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemJobLogPayload>[]
          }
          create: {
            args: Prisma.SystemJobLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemJobLogPayload>
          }
          createMany: {
            args: Prisma.SystemJobLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemJobLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemJobLogPayload>[]
          }
          delete: {
            args: Prisma.SystemJobLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemJobLogPayload>
          }
          update: {
            args: Prisma.SystemJobLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemJobLogPayload>
          }
          deleteMany: {
            args: Prisma.SystemJobLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemJobLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemJobLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemJobLogPayload>[]
          }
          upsert: {
            args: Prisma.SystemJobLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemJobLogPayload>
          }
          aggregate: {
            args: Prisma.SystemJobLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemJobLog>
          }
          groupBy: {
            args: Prisma.SystemJobLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemJobLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemJobLogCountArgs<ExtArgs>
            result: $Utils.Optional<SystemJobLogCountAggregateOutputType> | number
          }
        }
      }
      IdempotencyKey: {
        payload: Prisma.$IdempotencyKeyPayload<ExtArgs>
        fields: Prisma.IdempotencyKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IdempotencyKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdempotencyKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IdempotencyKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdempotencyKeyPayload>
          }
          findFirst: {
            args: Prisma.IdempotencyKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdempotencyKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IdempotencyKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdempotencyKeyPayload>
          }
          findMany: {
            args: Prisma.IdempotencyKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdempotencyKeyPayload>[]
          }
          create: {
            args: Prisma.IdempotencyKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdempotencyKeyPayload>
          }
          createMany: {
            args: Prisma.IdempotencyKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IdempotencyKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdempotencyKeyPayload>[]
          }
          delete: {
            args: Prisma.IdempotencyKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdempotencyKeyPayload>
          }
          update: {
            args: Prisma.IdempotencyKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdempotencyKeyPayload>
          }
          deleteMany: {
            args: Prisma.IdempotencyKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IdempotencyKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IdempotencyKeyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdempotencyKeyPayload>[]
          }
          upsert: {
            args: Prisma.IdempotencyKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdempotencyKeyPayload>
          }
          aggregate: {
            args: Prisma.IdempotencyKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIdempotencyKey>
          }
          groupBy: {
            args: Prisma.IdempotencyKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<IdempotencyKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.IdempotencyKeyCountArgs<ExtArgs>
            result: $Utils.Optional<IdempotencyKeyCountAggregateOutputType> | number
          }
        }
      }
      JobQueue: {
        payload: Prisma.$JobQueuePayload<ExtArgs>
        fields: Prisma.JobQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>
          }
          findFirst: {
            args: Prisma.JobQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>
          }
          findMany: {
            args: Prisma.JobQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>[]
          }
          create: {
            args: Prisma.JobQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>
          }
          createMany: {
            args: Prisma.JobQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobQueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>[]
          }
          delete: {
            args: Prisma.JobQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>
          }
          update: {
            args: Prisma.JobQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>
          }
          deleteMany: {
            args: Prisma.JobQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobQueueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>[]
          }
          upsert: {
            args: Prisma.JobQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobQueuePayload>
          }
          aggregate: {
            args: Prisma.JobQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobQueue>
          }
          groupBy: {
            args: Prisma.JobQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobQueueCountArgs<ExtArgs>
            result: $Utils.Optional<JobQueueCountAggregateOutputType> | number
          }
        }
      }
      CronLock: {
        payload: Prisma.$CronLockPayload<ExtArgs>
        fields: Prisma.CronLockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CronLockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronLockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CronLockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronLockPayload>
          }
          findFirst: {
            args: Prisma.CronLockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronLockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CronLockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronLockPayload>
          }
          findMany: {
            args: Prisma.CronLockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronLockPayload>[]
          }
          create: {
            args: Prisma.CronLockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronLockPayload>
          }
          createMany: {
            args: Prisma.CronLockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CronLockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronLockPayload>[]
          }
          delete: {
            args: Prisma.CronLockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronLockPayload>
          }
          update: {
            args: Prisma.CronLockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronLockPayload>
          }
          deleteMany: {
            args: Prisma.CronLockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CronLockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CronLockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronLockPayload>[]
          }
          upsert: {
            args: Prisma.CronLockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronLockPayload>
          }
          aggregate: {
            args: Prisma.CronLockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCronLock>
          }
          groupBy: {
            args: Prisma.CronLockGroupByArgs<ExtArgs>
            result: $Utils.Optional<CronLockGroupByOutputType>[]
          }
          count: {
            args: Prisma.CronLockCountArgs<ExtArgs>
            result: $Utils.Optional<CronLockCountAggregateOutputType> | number
          }
        }
      }
      AiAgent: {
        payload: Prisma.$AiAgentPayload<ExtArgs>
        fields: Prisma.AiAgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiAgentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiAgentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>
          }
          findFirst: {
            args: Prisma.AiAgentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiAgentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>
          }
          findMany: {
            args: Prisma.AiAgentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>[]
          }
          create: {
            args: Prisma.AiAgentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>
          }
          createMany: {
            args: Prisma.AiAgentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiAgentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>[]
          }
          delete: {
            args: Prisma.AiAgentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>
          }
          update: {
            args: Prisma.AiAgentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>
          }
          deleteMany: {
            args: Prisma.AiAgentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiAgentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiAgentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>[]
          }
          upsert: {
            args: Prisma.AiAgentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>
          }
          aggregate: {
            args: Prisma.AiAgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiAgent>
          }
          groupBy: {
            args: Prisma.AiAgentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiAgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiAgentCountArgs<ExtArgs>
            result: $Utils.Optional<AiAgentCountAggregateOutputType> | number
          }
        }
      }
      AiPermission: {
        payload: Prisma.$AiPermissionPayload<ExtArgs>
        fields: Prisma.AiPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiPermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiPermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPermissionPayload>
          }
          findFirst: {
            args: Prisma.AiPermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiPermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPermissionPayload>
          }
          findMany: {
            args: Prisma.AiPermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPermissionPayload>[]
          }
          create: {
            args: Prisma.AiPermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPermissionPayload>
          }
          createMany: {
            args: Prisma.AiPermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiPermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPermissionPayload>[]
          }
          delete: {
            args: Prisma.AiPermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPermissionPayload>
          }
          update: {
            args: Prisma.AiPermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPermissionPayload>
          }
          deleteMany: {
            args: Prisma.AiPermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiPermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiPermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPermissionPayload>[]
          }
          upsert: {
            args: Prisma.AiPermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPermissionPayload>
          }
          aggregate: {
            args: Prisma.AiPermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiPermission>
          }
          groupBy: {
            args: Prisma.AiPermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiPermissionCountArgs<ExtArgs>
            result: $Utils.Optional<AiPermissionCountAggregateOutputType> | number
          }
        }
      }
      AiAction: {
        payload: Prisma.$AiActionPayload<ExtArgs>
        fields: Prisma.AiActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiActionPayload>
          }
          findFirst: {
            args: Prisma.AiActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiActionPayload>
          }
          findMany: {
            args: Prisma.AiActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiActionPayload>[]
          }
          create: {
            args: Prisma.AiActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiActionPayload>
          }
          createMany: {
            args: Prisma.AiActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiActionPayload>[]
          }
          delete: {
            args: Prisma.AiActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiActionPayload>
          }
          update: {
            args: Prisma.AiActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiActionPayload>
          }
          deleteMany: {
            args: Prisma.AiActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiActionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiActionPayload>[]
          }
          upsert: {
            args: Prisma.AiActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiActionPayload>
          }
          aggregate: {
            args: Prisma.AiActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiAction>
          }
          groupBy: {
            args: Prisma.AiActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiActionCountArgs<ExtArgs>
            result: $Utils.Optional<AiActionCountAggregateOutputType> | number
          }
        }
      }
      AiTrainingData: {
        payload: Prisma.$AiTrainingDataPayload<ExtArgs>
        fields: Prisma.AiTrainingDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiTrainingDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTrainingDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiTrainingDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTrainingDataPayload>
          }
          findFirst: {
            args: Prisma.AiTrainingDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTrainingDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiTrainingDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTrainingDataPayload>
          }
          findMany: {
            args: Prisma.AiTrainingDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTrainingDataPayload>[]
          }
          create: {
            args: Prisma.AiTrainingDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTrainingDataPayload>
          }
          createMany: {
            args: Prisma.AiTrainingDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiTrainingDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTrainingDataPayload>[]
          }
          delete: {
            args: Prisma.AiTrainingDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTrainingDataPayload>
          }
          update: {
            args: Prisma.AiTrainingDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTrainingDataPayload>
          }
          deleteMany: {
            args: Prisma.AiTrainingDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiTrainingDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiTrainingDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTrainingDataPayload>[]
          }
          upsert: {
            args: Prisma.AiTrainingDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTrainingDataPayload>
          }
          aggregate: {
            args: Prisma.AiTrainingDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiTrainingData>
          }
          groupBy: {
            args: Prisma.AiTrainingDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiTrainingDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiTrainingDataCountArgs<ExtArgs>
            result: $Utils.Optional<AiTrainingDataCountAggregateOutputType> | number
          }
        }
      }
      Vehicle: {
        payload: Prisma.$VehiclePayload<ExtArgs>
        fields: Prisma.VehicleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findFirst: {
            args: Prisma.VehicleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findMany: {
            args: Prisma.VehicleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          create: {
            args: Prisma.VehicleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          createMany: {
            args: Prisma.VehicleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          delete: {
            args: Prisma.VehicleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          update: {
            args: Prisma.VehicleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          deleteMany: {
            args: Prisma.VehicleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VehicleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          upsert: {
            args: Prisma.VehicleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          aggregate: {
            args: Prisma.VehicleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle>
          }
          groupBy: {
            args: Prisma.VehicleGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleCountAggregateOutputType> | number
          }
        }
      }
      Delivery: {
        payload: Prisma.$DeliveryPayload<ExtArgs>
        fields: Prisma.DeliveryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          findFirst: {
            args: Prisma.DeliveryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          findMany: {
            args: Prisma.DeliveryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>[]
          }
          create: {
            args: Prisma.DeliveryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          createMany: {
            args: Prisma.DeliveryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>[]
          }
          delete: {
            args: Prisma.DeliveryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          update: {
            args: Prisma.DeliveryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>[]
          }
          upsert: {
            args: Prisma.DeliveryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          aggregate: {
            args: Prisma.DeliveryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDelivery>
          }
          groupBy: {
            args: Prisma.DeliveryGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryCountAggregateOutputType> | number
          }
        }
      }
      DeliveryItem: {
        payload: Prisma.$DeliveryItemPayload<ExtArgs>
        fields: Prisma.DeliveryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryItemPayload>
          }
          findFirst: {
            args: Prisma.DeliveryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryItemPayload>
          }
          findMany: {
            args: Prisma.DeliveryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryItemPayload>[]
          }
          create: {
            args: Prisma.DeliveryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryItemPayload>
          }
          createMany: {
            args: Prisma.DeliveryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryItemPayload>[]
          }
          delete: {
            args: Prisma.DeliveryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryItemPayload>
          }
          update: {
            args: Prisma.DeliveryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryItemPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryItemPayload>[]
          }
          upsert: {
            args: Prisma.DeliveryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryItemPayload>
          }
          aggregate: {
            args: Prisma.DeliveryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryItem>
          }
          groupBy: {
            args: Prisma.DeliveryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryItemCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryItemCountAggregateOutputType> | number
          }
        }
      }
      DeliveryLog: {
        payload: Prisma.$DeliveryLogPayload<ExtArgs>
        fields: Prisma.DeliveryLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLogPayload>
          }
          findFirst: {
            args: Prisma.DeliveryLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLogPayload>
          }
          findMany: {
            args: Prisma.DeliveryLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLogPayload>[]
          }
          create: {
            args: Prisma.DeliveryLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLogPayload>
          }
          createMany: {
            args: Prisma.DeliveryLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLogPayload>[]
          }
          delete: {
            args: Prisma.DeliveryLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLogPayload>
          }
          update: {
            args: Prisma.DeliveryLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLogPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLogPayload>[]
          }
          upsert: {
            args: Prisma.DeliveryLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryLogPayload>
          }
          aggregate: {
            args: Prisma.DeliveryLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryLog>
          }
          groupBy: {
            args: Prisma.DeliveryLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryLogCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryLogCountAggregateOutputType> | number
          }
        }
      }
      DeliveryEditLog: {
        payload: Prisma.$DeliveryEditLogPayload<ExtArgs>
        fields: Prisma.DeliveryEditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryEditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryEditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEditLogPayload>
          }
          findFirst: {
            args: Prisma.DeliveryEditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryEditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEditLogPayload>
          }
          findMany: {
            args: Prisma.DeliveryEditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEditLogPayload>[]
          }
          create: {
            args: Prisma.DeliveryEditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEditLogPayload>
          }
          createMany: {
            args: Prisma.DeliveryEditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryEditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEditLogPayload>[]
          }
          delete: {
            args: Prisma.DeliveryEditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEditLogPayload>
          }
          update: {
            args: Prisma.DeliveryEditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEditLogPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryEditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryEditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryEditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEditLogPayload>[]
          }
          upsert: {
            args: Prisma.DeliveryEditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryEditLogPayload>
          }
          aggregate: {
            args: Prisma.DeliveryEditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryEditLog>
          }
          groupBy: {
            args: Prisma.DeliveryEditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryEditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryEditLogCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryEditLogCountAggregateOutputType> | number
          }
        }
      }
      SpecialOffer: {
        payload: Prisma.$SpecialOfferPayload<ExtArgs>
        fields: Prisma.SpecialOfferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpecialOfferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOfferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpecialOfferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOfferPayload>
          }
          findFirst: {
            args: Prisma.SpecialOfferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOfferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpecialOfferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOfferPayload>
          }
          findMany: {
            args: Prisma.SpecialOfferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOfferPayload>[]
          }
          create: {
            args: Prisma.SpecialOfferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOfferPayload>
          }
          createMany: {
            args: Prisma.SpecialOfferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpecialOfferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOfferPayload>[]
          }
          delete: {
            args: Prisma.SpecialOfferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOfferPayload>
          }
          update: {
            args: Prisma.SpecialOfferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOfferPayload>
          }
          deleteMany: {
            args: Prisma.SpecialOfferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpecialOfferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpecialOfferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOfferPayload>[]
          }
          upsert: {
            args: Prisma.SpecialOfferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialOfferPayload>
          }
          aggregate: {
            args: Prisma.SpecialOfferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpecialOffer>
          }
          groupBy: {
            args: Prisma.SpecialOfferGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpecialOfferGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpecialOfferCountArgs<ExtArgs>
            result: $Utils.Optional<SpecialOfferCountAggregateOutputType> | number
          }
        }
      }
      ContactMessage: {
        payload: Prisma.$ContactMessagePayload<ExtArgs>
        fields: Prisma.ContactMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>
          }
          findFirst: {
            args: Prisma.ContactMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>
          }
          findMany: {
            args: Prisma.ContactMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>[]
          }
          create: {
            args: Prisma.ContactMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>
          }
          createMany: {
            args: Prisma.ContactMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>[]
          }
          delete: {
            args: Prisma.ContactMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>
          }
          update: {
            args: Prisma.ContactMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>
          }
          deleteMany: {
            args: Prisma.ContactMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>[]
          }
          upsert: {
            args: Prisma.ContactMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>
          }
          aggregate: {
            args: Prisma.ContactMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactMessage>
          }
          groupBy: {
            args: Prisma.ContactMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ContactMessageCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    invoice?: InvoiceOmit
    order?: OrderOmit
    paymentTransaction?: PaymentTransactionOmit
    productRelation?: ProductRelationOmit
    rentalPackageItem?: RentalPackageItemOmit
    rentalPackage?: RentalPackageOmit
    product?: ProductOmit
    productVariant?: ProductVariantOmit
    productUnit?: ProductUnitOmit
    unitHistory?: UnitHistoryOmit
    systemNotification?: SystemNotificationOmit
    rentalItem?: RentalItemOmit
    user?: UserOmit
    chatGroup?: ChatGroupOmit
    chatGroupMember?: ChatGroupMemberOmit
    groupMessage?: GroupMessageOmit
    siteSetting?: SiteSettingOmit
    activityLog?: ActivityLogOmit
    workerAttendance?: WorkerAttendanceOmit
    inventorySyncLog?: InventorySyncLogOmit
    workerNotification?: WorkerNotificationOmit
    message?: MessageOmit
    notificationDismissal?: NotificationDismissalOmit
    systemJobLog?: SystemJobLogOmit
    idempotencyKey?: IdempotencyKeyOmit
    jobQueue?: JobQueueOmit
    cronLock?: CronLockOmit
    aiAgent?: AiAgentOmit
    aiPermission?: AiPermissionOmit
    aiAction?: AiActionOmit
    aiTrainingData?: AiTrainingDataOmit
    vehicle?: VehicleOmit
    delivery?: DeliveryOmit
    deliveryItem?: DeliveryItemOmit
    deliveryLog?: DeliveryLogOmit
    deliveryEditLog?: DeliveryEditLogOmit
    specialOffer?: SpecialOfferOmit
    contactMessage?: ContactMessageOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    deliveries: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveries?: boolean | InvoiceCountOutputTypeCountDeliveriesArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    invoices: number
    assignedUnits: number
    rentalItems: number
    paymentTransactions: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | OrderCountOutputTypeCountInvoicesArgs
    assignedUnits?: boolean | OrderCountOutputTypeCountAssignedUnitsArgs
    rentalItems?: boolean | OrderCountOutputTypeCountRentalItemsArgs
    paymentTransactions?: boolean | OrderCountOutputTypeCountPaymentTransactionsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountAssignedUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductUnitWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountRentalItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RentalItemWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountPaymentTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentTransactionWhereInput
  }


  /**
   * Count Type RentalPackageCountOutputType
   */

  export type RentalPackageCountOutputType = {
    rentalPackageItems: number
    rentalItems: number
  }

  export type RentalPackageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rentalPackageItems?: boolean | RentalPackageCountOutputTypeCountRentalPackageItemsArgs
    rentalItems?: boolean | RentalPackageCountOutputTypeCountRentalItemsArgs
  }

  // Custom InputTypes
  /**
   * RentalPackageCountOutputType without action
   */
  export type RentalPackageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackageCountOutputType
     */
    select?: RentalPackageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RentalPackageCountOutputType without action
   */
  export type RentalPackageCountOutputTypeCountRentalPackageItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RentalPackageItemWhereInput
  }

  /**
   * RentalPackageCountOutputType without action
   */
  export type RentalPackageCountOutputTypeCountRentalItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RentalItemWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    inventorySyncLogs: number
    rentalPackageItems: number
    productRelations: number
    relatedTo: number
    variants: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventorySyncLogs?: boolean | ProductCountOutputTypeCountInventorySyncLogsArgs
    rentalPackageItems?: boolean | ProductCountOutputTypeCountRentalPackageItemsArgs
    productRelations?: boolean | ProductCountOutputTypeCountProductRelationsArgs
    relatedTo?: boolean | ProductCountOutputTypeCountRelatedToArgs
    variants?: boolean | ProductCountOutputTypeCountVariantsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountInventorySyncLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventorySyncLogWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountRentalPackageItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RentalPackageItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductRelationWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountRelatedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductRelationWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariantWhereInput
  }


  /**
   * Count Type ProductVariantCountOutputType
   */

  export type ProductVariantCountOutputType = {
    rentalItems: number
    units: number
  }

  export type ProductVariantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rentalItems?: boolean | ProductVariantCountOutputTypeCountRentalItemsArgs
    units?: boolean | ProductVariantCountOutputTypeCountUnitsArgs
  }

  // Custom InputTypes
  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantCountOutputType
     */
    select?: ProductVariantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeCountRentalItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RentalItemWhereInput
  }

  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeCountUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductUnitWhereInput
  }


  /**
   * Count Type ProductUnitCountOutputType
   */

  export type ProductUnitCountOutputType = {
    rentalItems: number
    history: number
  }

  export type ProductUnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rentalItems?: boolean | ProductUnitCountOutputTypeCountRentalItemsArgs
    history?: boolean | ProductUnitCountOutputTypeCountHistoryArgs
  }

  // Custom InputTypes
  /**
   * ProductUnitCountOutputType without action
   */
  export type ProductUnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductUnitCountOutputType
     */
    select?: ProductUnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductUnitCountOutputType without action
   */
  export type ProductUnitCountOutputTypeCountRentalItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RentalItemWhereInput
  }

  /**
   * ProductUnitCountOutputType without action
   */
  export type ProductUnitCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitHistoryWhereInput
  }


  /**
   * Count Type RentalItemCountOutputType
   */

  export type RentalItemCountOutputType = {
    deliveryItems: number
  }

  export type RentalItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveryItems?: boolean | RentalItemCountOutputTypeCountDeliveryItemsArgs
  }

  // Custom InputTypes
  /**
   * RentalItemCountOutputType without action
   */
  export type RentalItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalItemCountOutputType
     */
    select?: RentalItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RentalItemCountOutputType without action
   */
  export type RentalItemCountOutputTypeCountDeliveryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryItemWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    activityLogs: number
    inventoryResolutions: number
    inventoryUpdates: number
    invoices: number
    orders_orders_payment_confirmed_byTousers: number
    orders: number
    workerAttendance: number
    claimedDeliveries: number
    deliveryLogs: number
    deliveryEditLogs: number
    sentNotifications: number
    receivedNotifications: number
    sentMessages: number
    receivedMessages: number
    chatGroupMemberships: number
    sentGroupMessages: number
    notificationDismissals: number
    systemNotifications: number
    verifiedTransactions: number
    unitActions: number
    aiActionApprovals: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activityLogs?: boolean | UserCountOutputTypeCountActivityLogsArgs
    inventoryResolutions?: boolean | UserCountOutputTypeCountInventoryResolutionsArgs
    inventoryUpdates?: boolean | UserCountOutputTypeCountInventoryUpdatesArgs
    invoices?: boolean | UserCountOutputTypeCountInvoicesArgs
    orders_orders_payment_confirmed_byTousers?: boolean | UserCountOutputTypeCountOrders_orders_payment_confirmed_byTousersArgs
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    workerAttendance?: boolean | UserCountOutputTypeCountWorkerAttendanceArgs
    claimedDeliveries?: boolean | UserCountOutputTypeCountClaimedDeliveriesArgs
    deliveryLogs?: boolean | UserCountOutputTypeCountDeliveryLogsArgs
    deliveryEditLogs?: boolean | UserCountOutputTypeCountDeliveryEditLogsArgs
    sentNotifications?: boolean | UserCountOutputTypeCountSentNotificationsArgs
    receivedNotifications?: boolean | UserCountOutputTypeCountReceivedNotificationsArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    receivedMessages?: boolean | UserCountOutputTypeCountReceivedMessagesArgs
    chatGroupMemberships?: boolean | UserCountOutputTypeCountChatGroupMembershipsArgs
    sentGroupMessages?: boolean | UserCountOutputTypeCountSentGroupMessagesArgs
    notificationDismissals?: boolean | UserCountOutputTypeCountNotificationDismissalsArgs
    systemNotifications?: boolean | UserCountOutputTypeCountSystemNotificationsArgs
    verifiedTransactions?: boolean | UserCountOutputTypeCountVerifiedTransactionsArgs
    unitActions?: boolean | UserCountOutputTypeCountUnitActionsArgs
    aiActionApprovals?: boolean | UserCountOutputTypeCountAiActionApprovalsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryResolutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventorySyncLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryUpdatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventorySyncLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrders_orders_payment_confirmed_byTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkerAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerAttendanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClaimedDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeliveryLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeliveryEditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryEditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerNotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerNotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatGroupMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatGroupMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentGroupMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationDismissalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationDismissalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSystemNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemNotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVerifiedTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUnitActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAiActionApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiActionWhereInput
  }


  /**
   * Count Type ChatGroupCountOutputType
   */

  export type ChatGroupCountOutputType = {
    members: number
    messages: number
  }

  export type ChatGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ChatGroupCountOutputTypeCountMembersArgs
    messages?: boolean | ChatGroupCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatGroupCountOutputType without action
   */
  export type ChatGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupCountOutputType
     */
    select?: ChatGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatGroupCountOutputType without action
   */
  export type ChatGroupCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatGroupMemberWhereInput
  }

  /**
   * ChatGroupCountOutputType without action
   */
  export type ChatGroupCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMessageWhereInput
  }


  /**
   * Count Type AiAgentCountOutputType
   */

  export type AiAgentCountOutputType = {
    actions: number
    trainingData: number
  }

  export type AiAgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actions?: boolean | AiAgentCountOutputTypeCountActionsArgs
    trainingData?: boolean | AiAgentCountOutputTypeCountTrainingDataArgs
  }

  // Custom InputTypes
  /**
   * AiAgentCountOutputType without action
   */
  export type AiAgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgentCountOutputType
     */
    select?: AiAgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AiAgentCountOutputType without action
   */
  export type AiAgentCountOutputTypeCountActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiActionWhereInput
  }

  /**
   * AiAgentCountOutputType without action
   */
  export type AiAgentCountOutputTypeCountTrainingDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiTrainingDataWhereInput
  }


  /**
   * Count Type VehicleCountOutputType
   */

  export type VehicleCountOutputType = {
    deliveries: number
  }

  export type VehicleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveries?: boolean | VehicleCountOutputTypeCountDeliveriesArgs
  }

  // Custom InputTypes
  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleCountOutputType
     */
    select?: VehicleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryWhereInput
  }


  /**
   * Count Type DeliveryCountOutputType
   */

  export type DeliveryCountOutputType = {
    items: number
    logs: number
    editLogs: number
  }

  export type DeliveryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | DeliveryCountOutputTypeCountItemsArgs
    logs?: boolean | DeliveryCountOutputTypeCountLogsArgs
    editLogs?: boolean | DeliveryCountOutputTypeCountEditLogsArgs
  }

  // Custom InputTypes
  /**
   * DeliveryCountOutputType without action
   */
  export type DeliveryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryCountOutputType
     */
    select?: DeliveryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeliveryCountOutputType without action
   */
  export type DeliveryCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryItemWhereInput
  }

  /**
   * DeliveryCountOutputType without action
   */
  export type DeliveryCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryLogWhereInput
  }

  /**
   * DeliveryCountOutputType without action
   */
  export type DeliveryCountOutputTypeCountEditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryEditLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    subtotal: Decimal | null
    tax: Decimal | null
    deliveryFee: Decimal | null
    total: Decimal | null
    deliveryFeeOverride: Decimal | null
    taxRate: Decimal | null
    discountPercentage: number | null
    discountAmount: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    subtotal: Decimal | null
    tax: Decimal | null
    deliveryFee: Decimal | null
    total: Decimal | null
    deliveryFeeOverride: Decimal | null
    taxRate: Decimal | null
    discountPercentage: number | null
    discountAmount: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    orderId: string | null
    subtotal: Decimal | null
    tax: Decimal | null
    deliveryFee: Decimal | null
    total: Decimal | null
    currency: string | null
    createdAt: Date | null
    userId: string | null
    status: string | null
    guestEmail: string | null
    guestName: string | null
    guestWhatsapp: string | null
    guestAddress: string | null
    deliveryFeeOverride: Decimal | null
    taxRate: Decimal | null
    discountPercentage: number | null
    discountAmount: Decimal | null
    shareableToken: string | null
    emailSent: boolean | null
    emailSentAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    orderId: string | null
    subtotal: Decimal | null
    tax: Decimal | null
    deliveryFee: Decimal | null
    total: Decimal | null
    currency: string | null
    createdAt: Date | null
    userId: string | null
    status: string | null
    guestEmail: string | null
    guestName: string | null
    guestWhatsapp: string | null
    guestAddress: string | null
    deliveryFeeOverride: Decimal | null
    taxRate: Decimal | null
    discountPercentage: number | null
    discountAmount: Decimal | null
    shareableToken: string | null
    emailSent: boolean | null
    emailSentAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    invoiceNumber: number
    orderId: number
    subtotal: number
    tax: number
    deliveryFee: number
    total: number
    currency: number
    createdAt: number
    userId: number
    status: number
    guestEmail: number
    guestName: number
    guestWhatsapp: number
    guestAddress: number
    deliveryFeeOverride: number
    taxRate: number
    discountPercentage: number
    discountAmount: number
    shareableToken: number
    emailSent: number
    emailSentAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    subtotal?: true
    tax?: true
    deliveryFee?: true
    total?: true
    deliveryFeeOverride?: true
    taxRate?: true
    discountPercentage?: true
    discountAmount?: true
  }

  export type InvoiceSumAggregateInputType = {
    subtotal?: true
    tax?: true
    deliveryFee?: true
    total?: true
    deliveryFeeOverride?: true
    taxRate?: true
    discountPercentage?: true
    discountAmount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    invoiceNumber?: true
    orderId?: true
    subtotal?: true
    tax?: true
    deliveryFee?: true
    total?: true
    currency?: true
    createdAt?: true
    userId?: true
    status?: true
    guestEmail?: true
    guestName?: true
    guestWhatsapp?: true
    guestAddress?: true
    deliveryFeeOverride?: true
    taxRate?: true
    discountPercentage?: true
    discountAmount?: true
    shareableToken?: true
    emailSent?: true
    emailSentAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    invoiceNumber?: true
    orderId?: true
    subtotal?: true
    tax?: true
    deliveryFee?: true
    total?: true
    currency?: true
    createdAt?: true
    userId?: true
    status?: true
    guestEmail?: true
    guestName?: true
    guestWhatsapp?: true
    guestAddress?: true
    deliveryFeeOverride?: true
    taxRate?: true
    discountPercentage?: true
    discountAmount?: true
    shareableToken?: true
    emailSent?: true
    emailSentAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    invoiceNumber?: true
    orderId?: true
    subtotal?: true
    tax?: true
    deliveryFee?: true
    total?: true
    currency?: true
    createdAt?: true
    userId?: true
    status?: true
    guestEmail?: true
    guestName?: true
    guestWhatsapp?: true
    guestAddress?: true
    deliveryFeeOverride?: true
    taxRate?: true
    discountPercentage?: true
    discountAmount?: true
    shareableToken?: true
    emailSent?: true
    emailSentAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    invoiceNumber: string
    orderId: string | null
    subtotal: Decimal
    tax: Decimal
    deliveryFee: Decimal
    total: Decimal
    currency: string | null
    createdAt: Date | null
    userId: string | null
    status: string
    guestEmail: string | null
    guestName: string | null
    guestWhatsapp: string | null
    guestAddress: string | null
    deliveryFeeOverride: Decimal | null
    taxRate: Decimal | null
    discountPercentage: number | null
    discountAmount: Decimal | null
    shareableToken: string | null
    emailSent: boolean | null
    emailSentAt: Date | null
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    orderId?: boolean
    subtotal?: boolean
    tax?: boolean
    deliveryFee?: boolean
    total?: boolean
    currency?: boolean
    createdAt?: boolean
    userId?: boolean
    status?: boolean
    guestEmail?: boolean
    guestName?: boolean
    guestWhatsapp?: boolean
    guestAddress?: boolean
    deliveryFeeOverride?: boolean
    taxRate?: boolean
    discountPercentage?: boolean
    discountAmount?: boolean
    shareableToken?: boolean
    emailSent?: boolean
    emailSentAt?: boolean
    order?: boolean | Invoice$orderArgs<ExtArgs>
    deliveries?: boolean | Invoice$deliveriesArgs<ExtArgs>
    user?: boolean | Invoice$userArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    orderId?: boolean
    subtotal?: boolean
    tax?: boolean
    deliveryFee?: boolean
    total?: boolean
    currency?: boolean
    createdAt?: boolean
    userId?: boolean
    status?: boolean
    guestEmail?: boolean
    guestName?: boolean
    guestWhatsapp?: boolean
    guestAddress?: boolean
    deliveryFeeOverride?: boolean
    taxRate?: boolean
    discountPercentage?: boolean
    discountAmount?: boolean
    shareableToken?: boolean
    emailSent?: boolean
    emailSentAt?: boolean
    order?: boolean | Invoice$orderArgs<ExtArgs>
    user?: boolean | Invoice$userArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    orderId?: boolean
    subtotal?: boolean
    tax?: boolean
    deliveryFee?: boolean
    total?: boolean
    currency?: boolean
    createdAt?: boolean
    userId?: boolean
    status?: boolean
    guestEmail?: boolean
    guestName?: boolean
    guestWhatsapp?: boolean
    guestAddress?: boolean
    deliveryFeeOverride?: boolean
    taxRate?: boolean
    discountPercentage?: boolean
    discountAmount?: boolean
    shareableToken?: boolean
    emailSent?: boolean
    emailSentAt?: boolean
    order?: boolean | Invoice$orderArgs<ExtArgs>
    user?: boolean | Invoice$userArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    invoiceNumber?: boolean
    orderId?: boolean
    subtotal?: boolean
    tax?: boolean
    deliveryFee?: boolean
    total?: boolean
    currency?: boolean
    createdAt?: boolean
    userId?: boolean
    status?: boolean
    guestEmail?: boolean
    guestName?: boolean
    guestWhatsapp?: boolean
    guestAddress?: boolean
    deliveryFeeOverride?: boolean
    taxRate?: boolean
    discountPercentage?: boolean
    discountAmount?: boolean
    shareableToken?: boolean
    emailSent?: boolean
    emailSentAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceNumber" | "orderId" | "subtotal" | "tax" | "deliveryFee" | "total" | "currency" | "createdAt" | "userId" | "status" | "guestEmail" | "guestName" | "guestWhatsapp" | "guestAddress" | "deliveryFeeOverride" | "taxRate" | "discountPercentage" | "discountAmount" | "shareableToken" | "emailSent" | "emailSentAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | Invoice$orderArgs<ExtArgs>
    deliveries?: boolean | Invoice$deliveriesArgs<ExtArgs>
    user?: boolean | Invoice$userArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | Invoice$orderArgs<ExtArgs>
    user?: boolean | Invoice$userArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | Invoice$orderArgs<ExtArgs>
    user?: boolean | Invoice$userArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs> | null
      deliveries: Prisma.$DeliveryPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceNumber: string
      orderId: string | null
      subtotal: Prisma.Decimal
      tax: Prisma.Decimal
      deliveryFee: Prisma.Decimal
      total: Prisma.Decimal
      currency: string | null
      createdAt: Date | null
      userId: string | null
      status: string
      guestEmail: string | null
      guestName: string | null
      guestWhatsapp: string | null
      guestAddress: string | null
      deliveryFeeOverride: Prisma.Decimal | null
      taxRate: Prisma.Decimal | null
      discountPercentage: number | null
      discountAmount: Prisma.Decimal | null
      shareableToken: string | null
      emailSent: boolean | null
      emailSentAt: Date | null
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends Invoice$orderArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    deliveries<T extends Invoice$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends Invoice$userArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly invoiceNumber: FieldRef<"Invoice", 'String'>
    readonly orderId: FieldRef<"Invoice", 'String'>
    readonly subtotal: FieldRef<"Invoice", 'Decimal'>
    readonly tax: FieldRef<"Invoice", 'Decimal'>
    readonly deliveryFee: FieldRef<"Invoice", 'Decimal'>
    readonly total: FieldRef<"Invoice", 'Decimal'>
    readonly currency: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly userId: FieldRef<"Invoice", 'String'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly guestEmail: FieldRef<"Invoice", 'String'>
    readonly guestName: FieldRef<"Invoice", 'String'>
    readonly guestWhatsapp: FieldRef<"Invoice", 'String'>
    readonly guestAddress: FieldRef<"Invoice", 'String'>
    readonly deliveryFeeOverride: FieldRef<"Invoice", 'Decimal'>
    readonly taxRate: FieldRef<"Invoice", 'Decimal'>
    readonly discountPercentage: FieldRef<"Invoice", 'Int'>
    readonly discountAmount: FieldRef<"Invoice", 'Decimal'>
    readonly shareableToken: FieldRef<"Invoice", 'String'>
    readonly emailSent: FieldRef<"Invoice", 'Boolean'>
    readonly emailSentAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.order
   */
  export type Invoice$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * Invoice.deliveries
   */
  export type Invoice$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    where?: DeliveryWhereInput
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    cursor?: DeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Invoice.user
   */
  export type Invoice$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    duration: number | null
    totalAmount: Decimal | null
    subtotal: Decimal | null
    tax: Decimal | null
    deliveryFee: Decimal | null
    discountPercentage: number | null
    discountAmount: Decimal | null
  }

  export type OrderSumAggregateOutputType = {
    duration: number | null
    totalAmount: Decimal | null
    subtotal: Decimal | null
    tax: Decimal | null
    deliveryFee: Decimal | null
    discountPercentage: number | null
    discountAmount: Decimal | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    duration: number | null
    totalAmount: Decimal | null
    subtotal: Decimal | null
    tax: Decimal | null
    deliveryFee: Decimal | null
    discountPercentage: number | null
    discountAmount: Decimal | null
    currency: string | null
    paymentMethod: string | null
    createdAt: Date | null
    userId: string | null
    paymentStatus: string | null
    paymentConfirmedBy: string | null
    paymentConfirmedAt: Date | null
    deliveryAddress: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    duration: number | null
    totalAmount: Decimal | null
    subtotal: Decimal | null
    tax: Decimal | null
    deliveryFee: Decimal | null
    discountPercentage: number | null
    discountAmount: Decimal | null
    currency: string | null
    paymentMethod: string | null
    createdAt: Date | null
    userId: string | null
    paymentStatus: string | null
    paymentConfirmedBy: string | null
    paymentConfirmedAt: Date | null
    deliveryAddress: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    orderNumber: number
    status: number
    startDate: number
    endDate: number
    duration: number
    totalAmount: number
    subtotal: number
    tax: number
    deliveryFee: number
    discountPercentage: number
    discountAmount: number
    currency: number
    paymentMethod: number
    createdAt: number
    userId: number
    paymentStatus: number
    paymentConfirmedBy: number
    paymentConfirmedAt: number
    deliveryAddress: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    duration?: true
    totalAmount?: true
    subtotal?: true
    tax?: true
    deliveryFee?: true
    discountPercentage?: true
    discountAmount?: true
  }

  export type OrderSumAggregateInputType = {
    duration?: true
    totalAmount?: true
    subtotal?: true
    tax?: true
    deliveryFee?: true
    discountPercentage?: true
    discountAmount?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    orderNumber?: true
    status?: true
    startDate?: true
    endDate?: true
    duration?: true
    totalAmount?: true
    subtotal?: true
    tax?: true
    deliveryFee?: true
    discountPercentage?: true
    discountAmount?: true
    currency?: true
    paymentMethod?: true
    createdAt?: true
    userId?: true
    paymentStatus?: true
    paymentConfirmedBy?: true
    paymentConfirmedAt?: true
    deliveryAddress?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    status?: true
    startDate?: true
    endDate?: true
    duration?: true
    totalAmount?: true
    subtotal?: true
    tax?: true
    deliveryFee?: true
    discountPercentage?: true
    discountAmount?: true
    currency?: true
    paymentMethod?: true
    createdAt?: true
    userId?: true
    paymentStatus?: true
    paymentConfirmedBy?: true
    paymentConfirmedAt?: true
    deliveryAddress?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    orderNumber?: true
    status?: true
    startDate?: true
    endDate?: true
    duration?: true
    totalAmount?: true
    subtotal?: true
    tax?: true
    deliveryFee?: true
    discountPercentage?: true
    discountAmount?: true
    currency?: true
    paymentMethod?: true
    createdAt?: true
    userId?: true
    paymentStatus?: true
    paymentConfirmedBy?: true
    paymentConfirmedAt?: true
    deliveryAddress?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    orderNumber: string
    status: string
    startDate: Date
    endDate: Date
    duration: number
    totalAmount: Decimal
    subtotal: Decimal
    tax: Decimal
    deliveryFee: Decimal
    discountPercentage: number | null
    discountAmount: Decimal | null
    currency: string | null
    paymentMethod: string | null
    createdAt: Date | null
    userId: string
    paymentStatus: string | null
    paymentConfirmedBy: string | null
    paymentConfirmedAt: Date | null
    deliveryAddress: string | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    totalAmount?: boolean
    subtotal?: boolean
    tax?: boolean
    deliveryFee?: boolean
    discountPercentage?: boolean
    discountAmount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    userId?: boolean
    paymentStatus?: boolean
    paymentConfirmedBy?: boolean
    paymentConfirmedAt?: boolean
    deliveryAddress?: boolean
    invoices?: boolean | Order$invoicesArgs<ExtArgs>
    assignedUnits?: boolean | Order$assignedUnitsArgs<ExtArgs>
    users_orders_payment_confirmed_byTousers?: boolean | Order$users_orders_payment_confirmed_byTousersArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    rentalItems?: boolean | Order$rentalItemsArgs<ExtArgs>
    paymentTransactions?: boolean | Order$paymentTransactionsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    totalAmount?: boolean
    subtotal?: boolean
    tax?: boolean
    deliveryFee?: boolean
    discountPercentage?: boolean
    discountAmount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    userId?: boolean
    paymentStatus?: boolean
    paymentConfirmedBy?: boolean
    paymentConfirmedAt?: boolean
    deliveryAddress?: boolean
    users_orders_payment_confirmed_byTousers?: boolean | Order$users_orders_payment_confirmed_byTousersArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    totalAmount?: boolean
    subtotal?: boolean
    tax?: boolean
    deliveryFee?: boolean
    discountPercentage?: boolean
    discountAmount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    userId?: boolean
    paymentStatus?: boolean
    paymentConfirmedBy?: boolean
    paymentConfirmedAt?: boolean
    deliveryAddress?: boolean
    users_orders_payment_confirmed_byTousers?: boolean | Order$users_orders_payment_confirmed_byTousersArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    orderNumber?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    totalAmount?: boolean
    subtotal?: boolean
    tax?: boolean
    deliveryFee?: boolean
    discountPercentage?: boolean
    discountAmount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    userId?: boolean
    paymentStatus?: boolean
    paymentConfirmedBy?: boolean
    paymentConfirmedAt?: boolean
    deliveryAddress?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNumber" | "status" | "startDate" | "endDate" | "duration" | "totalAmount" | "subtotal" | "tax" | "deliveryFee" | "discountPercentage" | "discountAmount" | "currency" | "paymentMethod" | "createdAt" | "userId" | "paymentStatus" | "paymentConfirmedBy" | "paymentConfirmedAt" | "deliveryAddress", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | Order$invoicesArgs<ExtArgs>
    assignedUnits?: boolean | Order$assignedUnitsArgs<ExtArgs>
    users_orders_payment_confirmed_byTousers?: boolean | Order$users_orders_payment_confirmed_byTousersArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    rentalItems?: boolean | Order$rentalItemsArgs<ExtArgs>
    paymentTransactions?: boolean | Order$paymentTransactionsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_orders_payment_confirmed_byTousers?: boolean | Order$users_orders_payment_confirmed_byTousersArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_orders_payment_confirmed_byTousers?: boolean | Order$users_orders_payment_confirmed_byTousersArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      assignedUnits: Prisma.$ProductUnitPayload<ExtArgs>[]
      users_orders_payment_confirmed_byTousers: Prisma.$UserPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      rentalItems: Prisma.$RentalItemPayload<ExtArgs>[]
      paymentTransactions: Prisma.$PaymentTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNumber: string
      status: string
      startDate: Date
      endDate: Date
      duration: number
      totalAmount: Prisma.Decimal
      subtotal: Prisma.Decimal
      tax: Prisma.Decimal
      deliveryFee: Prisma.Decimal
      discountPercentage: number | null
      discountAmount: Prisma.Decimal | null
      currency: string | null
      paymentMethod: string | null
      createdAt: Date | null
      userId: string
      paymentStatus: string | null
      paymentConfirmedBy: string | null
      paymentConfirmedAt: Date | null
      deliveryAddress: string | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoices<T extends Order$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Order$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedUnits<T extends Order$assignedUnitsArgs<ExtArgs> = {}>(args?: Subset<T, Order$assignedUnitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductUnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users_orders_payment_confirmed_byTousers<T extends Order$users_orders_payment_confirmed_byTousersArgs<ExtArgs> = {}>(args?: Subset<T, Order$users_orders_payment_confirmed_byTousersArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rentalItems<T extends Order$rentalItemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$rentalItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentTransactions<T extends Order$paymentTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Order$paymentTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly orderNumber: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'String'>
    readonly startDate: FieldRef<"Order", 'DateTime'>
    readonly endDate: FieldRef<"Order", 'DateTime'>
    readonly duration: FieldRef<"Order", 'Int'>
    readonly totalAmount: FieldRef<"Order", 'Decimal'>
    readonly subtotal: FieldRef<"Order", 'Decimal'>
    readonly tax: FieldRef<"Order", 'Decimal'>
    readonly deliveryFee: FieldRef<"Order", 'Decimal'>
    readonly discountPercentage: FieldRef<"Order", 'Int'>
    readonly discountAmount: FieldRef<"Order", 'Decimal'>
    readonly currency: FieldRef<"Order", 'String'>
    readonly paymentMethod: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly userId: FieldRef<"Order", 'String'>
    readonly paymentStatus: FieldRef<"Order", 'String'>
    readonly paymentConfirmedBy: FieldRef<"Order", 'String'>
    readonly paymentConfirmedAt: FieldRef<"Order", 'DateTime'>
    readonly deliveryAddress: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.invoices
   */
  export type Order$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Order.assignedUnits
   */
  export type Order$assignedUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductUnit
     */
    select?: ProductUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductUnit
     */
    omit?: ProductUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductUnitInclude<ExtArgs> | null
    where?: ProductUnitWhereInput
    orderBy?: ProductUnitOrderByWithRelationInput | ProductUnitOrderByWithRelationInput[]
    cursor?: ProductUnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductUnitScalarFieldEnum | ProductUnitScalarFieldEnum[]
  }

  /**
   * Order.users_orders_payment_confirmed_byTousers
   */
  export type Order$users_orders_payment_confirmed_byTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Order.rentalItems
   */
  export type Order$rentalItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalItem
     */
    select?: RentalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalItem
     */
    omit?: RentalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalItemInclude<ExtArgs> | null
    where?: RentalItemWhereInput
    orderBy?: RentalItemOrderByWithRelationInput | RentalItemOrderByWithRelationInput[]
    cursor?: RentalItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RentalItemScalarFieldEnum | RentalItemScalarFieldEnum[]
  }

  /**
   * Order.paymentTransactions
   */
  export type Order$paymentTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    where?: PaymentTransactionWhereInput
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    cursor?: PaymentTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model PaymentTransaction
   */

  export type AggregatePaymentTransaction = {
    _count: PaymentTransactionCountAggregateOutputType | null
    _avg: PaymentTransactionAvgAggregateOutputType | null
    _sum: PaymentTransactionSumAggregateOutputType | null
    _min: PaymentTransactionMinAggregateOutputType | null
    _max: PaymentTransactionMaxAggregateOutputType | null
  }

  export type PaymentTransactionAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentTransactionSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentTransactionMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    provider: $Enums.PaymentProvider | null
    amount: Decimal | null
    currency: string | null
    status: $Enums.TransactionStatus | null
    externalReferenceId: string | null
    proofUrl: string | null
    verifiedByAdminId: string | null
    verifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentTransactionMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    provider: $Enums.PaymentProvider | null
    amount: Decimal | null
    currency: string | null
    status: $Enums.TransactionStatus | null
    externalReferenceId: string | null
    proofUrl: string | null
    verifiedByAdminId: string | null
    verifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentTransactionCountAggregateOutputType = {
    id: number
    orderId: number
    provider: number
    amount: number
    currency: number
    status: number
    externalReferenceId: number
    proofUrl: number
    verifiedByAdminId: number
    verifiedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentTransactionAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentTransactionSumAggregateInputType = {
    amount?: true
  }

  export type PaymentTransactionMinAggregateInputType = {
    id?: true
    orderId?: true
    provider?: true
    amount?: true
    currency?: true
    status?: true
    externalReferenceId?: true
    proofUrl?: true
    verifiedByAdminId?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentTransactionMaxAggregateInputType = {
    id?: true
    orderId?: true
    provider?: true
    amount?: true
    currency?: true
    status?: true
    externalReferenceId?: true
    proofUrl?: true
    verifiedByAdminId?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentTransactionCountAggregateInputType = {
    id?: true
    orderId?: true
    provider?: true
    amount?: true
    currency?: true
    status?: true
    externalReferenceId?: true
    proofUrl?: true
    verifiedByAdminId?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentTransaction to aggregate.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentTransactions
    **/
    _count?: true | PaymentTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentTransactionMaxAggregateInputType
  }

  export type GetPaymentTransactionAggregateType<T extends PaymentTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentTransaction[P]>
      : GetScalarType<T[P], AggregatePaymentTransaction[P]>
  }




  export type PaymentTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentTransactionWhereInput
    orderBy?: PaymentTransactionOrderByWithAggregationInput | PaymentTransactionOrderByWithAggregationInput[]
    by: PaymentTransactionScalarFieldEnum[] | PaymentTransactionScalarFieldEnum
    having?: PaymentTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentTransactionCountAggregateInputType | true
    _avg?: PaymentTransactionAvgAggregateInputType
    _sum?: PaymentTransactionSumAggregateInputType
    _min?: PaymentTransactionMinAggregateInputType
    _max?: PaymentTransactionMaxAggregateInputType
  }

  export type PaymentTransactionGroupByOutputType = {
    id: string
    orderId: string
    provider: $Enums.PaymentProvider
    amount: Decimal
    currency: string
    status: $Enums.TransactionStatus
    externalReferenceId: string | null
    proofUrl: string | null
    verifiedByAdminId: string | null
    verifiedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentTransactionCountAggregateOutputType | null
    _avg: PaymentTransactionAvgAggregateOutputType | null
    _sum: PaymentTransactionSumAggregateOutputType | null
    _min: PaymentTransactionMinAggregateOutputType | null
    _max: PaymentTransactionMaxAggregateOutputType | null
  }

  type GetPaymentTransactionGroupByPayload<T extends PaymentTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentTransactionGroupByOutputType[P]>
        }
      >
    >


  export type PaymentTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    provider?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    externalReferenceId?: boolean
    proofUrl?: boolean
    verifiedByAdminId?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    verifiedBy?: boolean | PaymentTransaction$verifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["paymentTransaction"]>

  export type PaymentTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    provider?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    externalReferenceId?: boolean
    proofUrl?: boolean
    verifiedByAdminId?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    verifiedBy?: boolean | PaymentTransaction$verifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["paymentTransaction"]>

  export type PaymentTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    provider?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    externalReferenceId?: boolean
    proofUrl?: boolean
    verifiedByAdminId?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    verifiedBy?: boolean | PaymentTransaction$verifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["paymentTransaction"]>

  export type PaymentTransactionSelectScalar = {
    id?: boolean
    orderId?: boolean
    provider?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    externalReferenceId?: boolean
    proofUrl?: boolean
    verifiedByAdminId?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "provider" | "amount" | "currency" | "status" | "externalReferenceId" | "proofUrl" | "verifiedByAdminId" | "verifiedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentTransaction"]>
  export type PaymentTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    verifiedBy?: boolean | PaymentTransaction$verifiedByArgs<ExtArgs>
  }
  export type PaymentTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    verifiedBy?: boolean | PaymentTransaction$verifiedByArgs<ExtArgs>
  }
  export type PaymentTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    verifiedBy?: boolean | PaymentTransaction$verifiedByArgs<ExtArgs>
  }

  export type $PaymentTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentTransaction"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      verifiedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      provider: $Enums.PaymentProvider
      amount: Prisma.Decimal
      currency: string
      status: $Enums.TransactionStatus
      externalReferenceId: string | null
      proofUrl: string | null
      verifiedByAdminId: string | null
      verifiedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentTransaction"]>
    composites: {}
  }

  type PaymentTransactionGetPayload<S extends boolean | null | undefined | PaymentTransactionDefaultArgs> = $Result.GetResult<Prisma.$PaymentTransactionPayload, S>

  type PaymentTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentTransactionCountAggregateInputType | true
    }

  export interface PaymentTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentTransaction'], meta: { name: 'PaymentTransaction' } }
    /**
     * Find zero or one PaymentTransaction that matches the filter.
     * @param {PaymentTransactionFindUniqueArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentTransactionFindUniqueArgs>(args: SelectSubset<T, PaymentTransactionFindUniqueArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentTransactionFindUniqueOrThrowArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionFindFirstArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentTransactionFindFirstArgs>(args?: SelectSubset<T, PaymentTransactionFindFirstArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionFindFirstOrThrowArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentTransactions
     * const paymentTransactions = await prisma.paymentTransaction.findMany()
     * 
     * // Get first 10 PaymentTransactions
     * const paymentTransactions = await prisma.paymentTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentTransactionWithIdOnly = await prisma.paymentTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentTransactionFindManyArgs>(args?: SelectSubset<T, PaymentTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentTransaction.
     * @param {PaymentTransactionCreateArgs} args - Arguments to create a PaymentTransaction.
     * @example
     * // Create one PaymentTransaction
     * const PaymentTransaction = await prisma.paymentTransaction.create({
     *   data: {
     *     // ... data to create a PaymentTransaction
     *   }
     * })
     * 
     */
    create<T extends PaymentTransactionCreateArgs>(args: SelectSubset<T, PaymentTransactionCreateArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentTransactions.
     * @param {PaymentTransactionCreateManyArgs} args - Arguments to create many PaymentTransactions.
     * @example
     * // Create many PaymentTransactions
     * const paymentTransaction = await prisma.paymentTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentTransactionCreateManyArgs>(args?: SelectSubset<T, PaymentTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentTransactions and returns the data saved in the database.
     * @param {PaymentTransactionCreateManyAndReturnArgs} args - Arguments to create many PaymentTransactions.
     * @example
     * // Create many PaymentTransactions
     * const paymentTransaction = await prisma.paymentTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentTransactions and only return the `id`
     * const paymentTransactionWithIdOnly = await prisma.paymentTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentTransaction.
     * @param {PaymentTransactionDeleteArgs} args - Arguments to delete one PaymentTransaction.
     * @example
     * // Delete one PaymentTransaction
     * const PaymentTransaction = await prisma.paymentTransaction.delete({
     *   where: {
     *     // ... filter to delete one PaymentTransaction
     *   }
     * })
     * 
     */
    delete<T extends PaymentTransactionDeleteArgs>(args: SelectSubset<T, PaymentTransactionDeleteArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentTransaction.
     * @param {PaymentTransactionUpdateArgs} args - Arguments to update one PaymentTransaction.
     * @example
     * // Update one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentTransactionUpdateArgs>(args: SelectSubset<T, PaymentTransactionUpdateArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentTransactions.
     * @param {PaymentTransactionDeleteManyArgs} args - Arguments to filter PaymentTransactions to delete.
     * @example
     * // Delete a few PaymentTransactions
     * const { count } = await prisma.paymentTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentTransactionDeleteManyArgs>(args?: SelectSubset<T, PaymentTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentTransactions
     * const paymentTransaction = await prisma.paymentTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentTransactionUpdateManyArgs>(args: SelectSubset<T, PaymentTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentTransactions and returns the data updated in the database.
     * @param {PaymentTransactionUpdateManyAndReturnArgs} args - Arguments to update many PaymentTransactions.
     * @example
     * // Update many PaymentTransactions
     * const paymentTransaction = await prisma.paymentTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentTransactions and only return the `id`
     * const paymentTransactionWithIdOnly = await prisma.paymentTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentTransaction.
     * @param {PaymentTransactionUpsertArgs} args - Arguments to update or create a PaymentTransaction.
     * @example
     * // Update or create a PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.upsert({
     *   create: {
     *     // ... data to create a PaymentTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentTransaction we want to update
     *   }
     * })
     */
    upsert<T extends PaymentTransactionUpsertArgs>(args: SelectSubset<T, PaymentTransactionUpsertArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionCountArgs} args - Arguments to filter PaymentTransactions to count.
     * @example
     * // Count the number of PaymentTransactions
     * const count = await prisma.paymentTransaction.count({
     *   where: {
     *     // ... the filter for the PaymentTransactions we want to count
     *   }
     * })
    **/
    count<T extends PaymentTransactionCountArgs>(
      args?: Subset<T, PaymentTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentTransactionAggregateArgs>(args: Subset<T, PaymentTransactionAggregateArgs>): Prisma.PrismaPromise<GetPaymentTransactionAggregateType<T>>

    /**
     * Group by PaymentTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentTransactionGroupByArgs['orderBy'] }
        : { orderBy?: PaymentTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentTransaction model
   */
  readonly fields: PaymentTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    verifiedBy<T extends PaymentTransaction$verifiedByArgs<ExtArgs> = {}>(args?: Subset<T, PaymentTransaction$verifiedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentTransaction model
   */
  interface PaymentTransactionFieldRefs {
    readonly id: FieldRef<"PaymentTransaction", 'String'>
    readonly orderId: FieldRef<"PaymentTransaction", 'String'>
    readonly provider: FieldRef<"PaymentTransaction", 'PaymentProvider'>
    readonly amount: FieldRef<"PaymentTransaction", 'Decimal'>
    readonly currency: FieldRef<"PaymentTransaction", 'String'>
    readonly status: FieldRef<"PaymentTransaction", 'TransactionStatus'>
    readonly externalReferenceId: FieldRef<"PaymentTransaction", 'String'>
    readonly proofUrl: FieldRef<"PaymentTransaction", 'String'>
    readonly verifiedByAdminId: FieldRef<"PaymentTransaction", 'String'>
    readonly verifiedAt: FieldRef<"PaymentTransaction", 'DateTime'>
    readonly createdAt: FieldRef<"PaymentTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentTransaction findUnique
   */
  export type PaymentTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction findUniqueOrThrow
   */
  export type PaymentTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction findFirst
   */
  export type PaymentTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentTransactions.
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentTransactions.
     */
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * PaymentTransaction findFirstOrThrow
   */
  export type PaymentTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentTransactions.
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentTransactions.
     */
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * PaymentTransaction findMany
   */
  export type PaymentTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransactions to fetch.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentTransactions.
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * PaymentTransaction create
   */
  export type PaymentTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentTransaction.
     */
    data: XOR<PaymentTransactionCreateInput, PaymentTransactionUncheckedCreateInput>
  }

  /**
   * PaymentTransaction createMany
   */
  export type PaymentTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentTransactions.
     */
    data: PaymentTransactionCreateManyInput | PaymentTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentTransaction createManyAndReturn
   */
  export type PaymentTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentTransactions.
     */
    data: PaymentTransactionCreateManyInput | PaymentTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentTransaction update
   */
  export type PaymentTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentTransaction.
     */
    data: XOR<PaymentTransactionUpdateInput, PaymentTransactionUncheckedUpdateInput>
    /**
     * Choose, which PaymentTransaction to update.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction updateMany
   */
  export type PaymentTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentTransactions.
     */
    data: XOR<PaymentTransactionUpdateManyMutationInput, PaymentTransactionUncheckedUpdateManyInput>
    /**
     * Filter which PaymentTransactions to update
     */
    where?: PaymentTransactionWhereInput
    /**
     * Limit how many PaymentTransactions to update.
     */
    limit?: number
  }

  /**
   * PaymentTransaction updateManyAndReturn
   */
  export type PaymentTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * The data used to update PaymentTransactions.
     */
    data: XOR<PaymentTransactionUpdateManyMutationInput, PaymentTransactionUncheckedUpdateManyInput>
    /**
     * Filter which PaymentTransactions to update
     */
    where?: PaymentTransactionWhereInput
    /**
     * Limit how many PaymentTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentTransaction upsert
   */
  export type PaymentTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentTransaction to update in case it exists.
     */
    where: PaymentTransactionWhereUniqueInput
    /**
     * In case the PaymentTransaction found by the `where` argument doesn't exist, create a new PaymentTransaction with this data.
     */
    create: XOR<PaymentTransactionCreateInput, PaymentTransactionUncheckedCreateInput>
    /**
     * In case the PaymentTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentTransactionUpdateInput, PaymentTransactionUncheckedUpdateInput>
  }

  /**
   * PaymentTransaction delete
   */
  export type PaymentTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter which PaymentTransaction to delete.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction deleteMany
   */
  export type PaymentTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentTransactions to delete
     */
    where?: PaymentTransactionWhereInput
    /**
     * Limit how many PaymentTransactions to delete.
     */
    limit?: number
  }

  /**
   * PaymentTransaction.verifiedBy
   */
  export type PaymentTransaction$verifiedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PaymentTransaction without action
   */
  export type PaymentTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
  }


  /**
   * Model ProductRelation
   */

  export type AggregateProductRelation = {
    _count: ProductRelationCountAggregateOutputType | null
    _avg: ProductRelationAvgAggregateOutputType | null
    _sum: ProductRelationSumAggregateOutputType | null
    _min: ProductRelationMinAggregateOutputType | null
    _max: ProductRelationMaxAggregateOutputType | null
  }

  export type ProductRelationAvgAggregateOutputType = {
    priority: number | null
    aiScore: number | null
  }

  export type ProductRelationSumAggregateOutputType = {
    priority: number | null
    aiScore: number | null
  }

  export type ProductRelationMinAggregateOutputType = {
    id: string | null
    productId: string | null
    relatedProductId: string | null
    relationType: $Enums.RelationType | null
    priority: number | null
    aiScore: number | null
    createdAt: Date | null
  }

  export type ProductRelationMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    relatedProductId: string | null
    relationType: $Enums.RelationType | null
    priority: number | null
    aiScore: number | null
    createdAt: Date | null
  }

  export type ProductRelationCountAggregateOutputType = {
    id: number
    productId: number
    relatedProductId: number
    relationType: number
    priority: number
    aiScore: number
    createdAt: number
    _all: number
  }


  export type ProductRelationAvgAggregateInputType = {
    priority?: true
    aiScore?: true
  }

  export type ProductRelationSumAggregateInputType = {
    priority?: true
    aiScore?: true
  }

  export type ProductRelationMinAggregateInputType = {
    id?: true
    productId?: true
    relatedProductId?: true
    relationType?: true
    priority?: true
    aiScore?: true
    createdAt?: true
  }

  export type ProductRelationMaxAggregateInputType = {
    id?: true
    productId?: true
    relatedProductId?: true
    relationType?: true
    priority?: true
    aiScore?: true
    createdAt?: true
  }

  export type ProductRelationCountAggregateInputType = {
    id?: true
    productId?: true
    relatedProductId?: true
    relationType?: true
    priority?: true
    aiScore?: true
    createdAt?: true
    _all?: true
  }

  export type ProductRelationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductRelation to aggregate.
     */
    where?: ProductRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductRelations to fetch.
     */
    orderBy?: ProductRelationOrderByWithRelationInput | ProductRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductRelations
    **/
    _count?: true | ProductRelationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductRelationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductRelationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductRelationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductRelationMaxAggregateInputType
  }

  export type GetProductRelationAggregateType<T extends ProductRelationAggregateArgs> = {
        [P in keyof T & keyof AggregateProductRelation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductRelation[P]>
      : GetScalarType<T[P], AggregateProductRelation[P]>
  }




  export type ProductRelationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductRelationWhereInput
    orderBy?: ProductRelationOrderByWithAggregationInput | ProductRelationOrderByWithAggregationInput[]
    by: ProductRelationScalarFieldEnum[] | ProductRelationScalarFieldEnum
    having?: ProductRelationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductRelationCountAggregateInputType | true
    _avg?: ProductRelationAvgAggregateInputType
    _sum?: ProductRelationSumAggregateInputType
    _min?: ProductRelationMinAggregateInputType
    _max?: ProductRelationMaxAggregateInputType
  }

  export type ProductRelationGroupByOutputType = {
    id: string
    productId: string
    relatedProductId: string
    relationType: $Enums.RelationType
    priority: number
    aiScore: number | null
    createdAt: Date
    _count: ProductRelationCountAggregateOutputType | null
    _avg: ProductRelationAvgAggregateOutputType | null
    _sum: ProductRelationSumAggregateOutputType | null
    _min: ProductRelationMinAggregateOutputType | null
    _max: ProductRelationMaxAggregateOutputType | null
  }

  type GetProductRelationGroupByPayload<T extends ProductRelationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductRelationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductRelationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductRelationGroupByOutputType[P]>
            : GetScalarType<T[P], ProductRelationGroupByOutputType[P]>
        }
      >
    >


  export type ProductRelationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    relatedProductId?: boolean
    relationType?: boolean
    priority?: boolean
    aiScore?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    relatedProduct?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productRelation"]>

  export type ProductRelationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    relatedProductId?: boolean
    relationType?: boolean
    priority?: boolean
    aiScore?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    relatedProduct?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productRelation"]>

  export type ProductRelationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    relatedProductId?: boolean
    relationType?: boolean
    priority?: boolean
    aiScore?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    relatedProduct?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productRelation"]>

  export type ProductRelationSelectScalar = {
    id?: boolean
    productId?: boolean
    relatedProductId?: boolean
    relationType?: boolean
    priority?: boolean
    aiScore?: boolean
    createdAt?: boolean
  }

  export type ProductRelationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "relatedProductId" | "relationType" | "priority" | "aiScore" | "createdAt", ExtArgs["result"]["productRelation"]>
  export type ProductRelationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    relatedProduct?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductRelationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    relatedProduct?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductRelationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    relatedProduct?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductRelationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductRelation"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      relatedProduct: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      relatedProductId: string
      relationType: $Enums.RelationType
      priority: number
      aiScore: number | null
      createdAt: Date
    }, ExtArgs["result"]["productRelation"]>
    composites: {}
  }

  type ProductRelationGetPayload<S extends boolean | null | undefined | ProductRelationDefaultArgs> = $Result.GetResult<Prisma.$ProductRelationPayload, S>

  type ProductRelationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductRelationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductRelationCountAggregateInputType | true
    }

  export interface ProductRelationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductRelation'], meta: { name: 'ProductRelation' } }
    /**
     * Find zero or one ProductRelation that matches the filter.
     * @param {ProductRelationFindUniqueArgs} args - Arguments to find a ProductRelation
     * @example
     * // Get one ProductRelation
     * const productRelation = await prisma.productRelation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductRelationFindUniqueArgs>(args: SelectSubset<T, ProductRelationFindUniqueArgs<ExtArgs>>): Prisma__ProductRelationClient<$Result.GetResult<Prisma.$ProductRelationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductRelation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductRelationFindUniqueOrThrowArgs} args - Arguments to find a ProductRelation
     * @example
     * // Get one ProductRelation
     * const productRelation = await prisma.productRelation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductRelationFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductRelationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductRelationClient<$Result.GetResult<Prisma.$ProductRelationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductRelation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRelationFindFirstArgs} args - Arguments to find a ProductRelation
     * @example
     * // Get one ProductRelation
     * const productRelation = await prisma.productRelation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductRelationFindFirstArgs>(args?: SelectSubset<T, ProductRelationFindFirstArgs<ExtArgs>>): Prisma__ProductRelationClient<$Result.GetResult<Prisma.$ProductRelationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductRelation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRelationFindFirstOrThrowArgs} args - Arguments to find a ProductRelation
     * @example
     * // Get one ProductRelation
     * const productRelation = await prisma.productRelation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductRelationFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductRelationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductRelationClient<$Result.GetResult<Prisma.$ProductRelationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductRelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRelationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductRelations
     * const productRelations = await prisma.productRelation.findMany()
     * 
     * // Get first 10 ProductRelations
     * const productRelations = await prisma.productRelation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productRelationWithIdOnly = await prisma.productRelation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductRelationFindManyArgs>(args?: SelectSubset<T, ProductRelationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductRelation.
     * @param {ProductRelationCreateArgs} args - Arguments to create a ProductRelation.
     * @example
     * // Create one ProductRelation
     * const ProductRelation = await prisma.productRelation.create({
     *   data: {
     *     // ... data to create a ProductRelation
     *   }
     * })
     * 
     */
    create<T extends ProductRelationCreateArgs>(args: SelectSubset<T, ProductRelationCreateArgs<ExtArgs>>): Prisma__ProductRelationClient<$Result.GetResult<Prisma.$ProductRelationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductRelations.
     * @param {ProductRelationCreateManyArgs} args - Arguments to create many ProductRelations.
     * @example
     * // Create many ProductRelations
     * const productRelation = await prisma.productRelation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductRelationCreateManyArgs>(args?: SelectSubset<T, ProductRelationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductRelations and returns the data saved in the database.
     * @param {ProductRelationCreateManyAndReturnArgs} args - Arguments to create many ProductRelations.
     * @example
     * // Create many ProductRelations
     * const productRelation = await prisma.productRelation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductRelations and only return the `id`
     * const productRelationWithIdOnly = await prisma.productRelation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductRelationCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductRelationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductRelationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductRelation.
     * @param {ProductRelationDeleteArgs} args - Arguments to delete one ProductRelation.
     * @example
     * // Delete one ProductRelation
     * const ProductRelation = await prisma.productRelation.delete({
     *   where: {
     *     // ... filter to delete one ProductRelation
     *   }
     * })
     * 
     */
    delete<T extends ProductRelationDeleteArgs>(args: SelectSubset<T, ProductRelationDeleteArgs<ExtArgs>>): Prisma__ProductRelationClient<$Result.GetResult<Prisma.$ProductRelationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductRelation.
     * @param {ProductRelationUpdateArgs} args - Arguments to update one ProductRelation.
     * @example
     * // Update one ProductRelation
     * const productRelation = await prisma.productRelation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductRelationUpdateArgs>(args: SelectSubset<T, ProductRelationUpdateArgs<ExtArgs>>): Prisma__ProductRelationClient<$Result.GetResult<Prisma.$ProductRelationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductRelations.
     * @param {ProductRelationDeleteManyArgs} args - Arguments to filter ProductRelations to delete.
     * @example
     * // Delete a few ProductRelations
     * const { count } = await prisma.productRelation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductRelationDeleteManyArgs>(args?: SelectSubset<T, ProductRelationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRelationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductRelations
     * const productRelation = await prisma.productRelation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductRelationUpdateManyArgs>(args: SelectSubset<T, ProductRelationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductRelations and returns the data updated in the database.
     * @param {ProductRelationUpdateManyAndReturnArgs} args - Arguments to update many ProductRelations.
     * @example
     * // Update many ProductRelations
     * const productRelation = await prisma.productRelation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductRelations and only return the `id`
     * const productRelationWithIdOnly = await prisma.productRelation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductRelationUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductRelationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductRelationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductRelation.
     * @param {ProductRelationUpsertArgs} args - Arguments to update or create a ProductRelation.
     * @example
     * // Update or create a ProductRelation
     * const productRelation = await prisma.productRelation.upsert({
     *   create: {
     *     // ... data to create a ProductRelation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductRelation we want to update
     *   }
     * })
     */
    upsert<T extends ProductRelationUpsertArgs>(args: SelectSubset<T, ProductRelationUpsertArgs<ExtArgs>>): Prisma__ProductRelationClient<$Result.GetResult<Prisma.$ProductRelationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRelationCountArgs} args - Arguments to filter ProductRelations to count.
     * @example
     * // Count the number of ProductRelations
     * const count = await prisma.productRelation.count({
     *   where: {
     *     // ... the filter for the ProductRelations we want to count
     *   }
     * })
    **/
    count<T extends ProductRelationCountArgs>(
      args?: Subset<T, ProductRelationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductRelationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductRelationAggregateArgs>(args: Subset<T, ProductRelationAggregateArgs>): Prisma.PrismaPromise<GetProductRelationAggregateType<T>>

    /**
     * Group by ProductRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRelationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductRelationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductRelationGroupByArgs['orderBy'] }
        : { orderBy?: ProductRelationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductRelationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductRelationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductRelation model
   */
  readonly fields: ProductRelationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductRelation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductRelationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    relatedProduct<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductRelation model
   */
  interface ProductRelationFieldRefs {
    readonly id: FieldRef<"ProductRelation", 'String'>
    readonly productId: FieldRef<"ProductRelation", 'String'>
    readonly relatedProductId: FieldRef<"ProductRelation", 'String'>
    readonly relationType: FieldRef<"ProductRelation", 'RelationType'>
    readonly priority: FieldRef<"ProductRelation", 'Int'>
    readonly aiScore: FieldRef<"ProductRelation", 'Float'>
    readonly createdAt: FieldRef<"ProductRelation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductRelation findUnique
   */
  export type ProductRelationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRelation
     */
    select?: ProductRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRelation
     */
    omit?: ProductRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRelationInclude<ExtArgs> | null
    /**
     * Filter, which ProductRelation to fetch.
     */
    where: ProductRelationWhereUniqueInput
  }

  /**
   * ProductRelation findUniqueOrThrow
   */
  export type ProductRelationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRelation
     */
    select?: ProductRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRelation
     */
    omit?: ProductRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRelationInclude<ExtArgs> | null
    /**
     * Filter, which ProductRelation to fetch.
     */
    where: ProductRelationWhereUniqueInput
  }

  /**
   * ProductRelation findFirst
   */
  export type ProductRelationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRelation
     */
    select?: ProductRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRelation
     */
    omit?: ProductRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRelationInclude<ExtArgs> | null
    /**
     * Filter, which ProductRelation to fetch.
     */
    where?: ProductRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductRelations to fetch.
     */
    orderBy?: ProductRelationOrderByWithRelationInput | ProductRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductRelations.
     */
    cursor?: ProductRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductRelations.
     */
    distinct?: ProductRelationScalarFieldEnum | ProductRelationScalarFieldEnum[]
  }

  /**
   * ProductRelation findFirstOrThrow
   */
  export type ProductRelationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRelation
     */
    select?: ProductRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRelation
     */
    omit?: ProductRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRelationInclude<ExtArgs> | null
    /**
     * Filter, which ProductRelation to fetch.
     */
    where?: ProductRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductRelations to fetch.
     */
    orderBy?: ProductRelationOrderByWithRelationInput | ProductRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductRelations.
     */
    cursor?: ProductRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductRelations.
     */
    distinct?: ProductRelationScalarFieldEnum | ProductRelationScalarFieldEnum[]
  }

  /**
   * ProductRelation findMany
   */
  export type ProductRelationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRelation
     */
    select?: ProductRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRelation
     */
    omit?: ProductRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRelationInclude<ExtArgs> | null
    /**
     * Filter, which ProductRelations to fetch.
     */
    where?: ProductRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductRelations to fetch.
     */
    orderBy?: ProductRelationOrderByWithRelationInput | ProductRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductRelations.
     */
    cursor?: ProductRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductRelations.
     */
    skip?: number
    distinct?: ProductRelationScalarFieldEnum | ProductRelationScalarFieldEnum[]
  }

  /**
   * ProductRelation create
   */
  export type ProductRelationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRelation
     */
    select?: ProductRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRelation
     */
    omit?: ProductRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRelationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductRelation.
     */
    data: XOR<ProductRelationCreateInput, ProductRelationUncheckedCreateInput>
  }

  /**
   * ProductRelation createMany
   */
  export type ProductRelationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductRelations.
     */
    data: ProductRelationCreateManyInput | ProductRelationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductRelation createManyAndReturn
   */
  export type ProductRelationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRelation
     */
    select?: ProductRelationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRelation
     */
    omit?: ProductRelationOmit<ExtArgs> | null
    /**
     * The data used to create many ProductRelations.
     */
    data: ProductRelationCreateManyInput | ProductRelationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRelationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductRelation update
   */
  export type ProductRelationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRelation
     */
    select?: ProductRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRelation
     */
    omit?: ProductRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRelationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductRelation.
     */
    data: XOR<ProductRelationUpdateInput, ProductRelationUncheckedUpdateInput>
    /**
     * Choose, which ProductRelation to update.
     */
    where: ProductRelationWhereUniqueInput
  }

  /**
   * ProductRelation updateMany
   */
  export type ProductRelationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductRelations.
     */
    data: XOR<ProductRelationUpdateManyMutationInput, ProductRelationUncheckedUpdateManyInput>
    /**
     * Filter which ProductRelations to update
     */
    where?: ProductRelationWhereInput
    /**
     * Limit how many ProductRelations to update.
     */
    limit?: number
  }

  /**
   * ProductRelation updateManyAndReturn
   */
  export type ProductRelationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRelation
     */
    select?: ProductRelationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRelation
     */
    omit?: ProductRelationOmit<ExtArgs> | null
    /**
     * The data used to update ProductRelations.
     */
    data: XOR<ProductRelationUpdateManyMutationInput, ProductRelationUncheckedUpdateManyInput>
    /**
     * Filter which ProductRelations to update
     */
    where?: ProductRelationWhereInput
    /**
     * Limit how many ProductRelations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRelationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductRelation upsert
   */
  export type ProductRelationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRelation
     */
    select?: ProductRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRelation
     */
    omit?: ProductRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRelationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductRelation to update in case it exists.
     */
    where: ProductRelationWhereUniqueInput
    /**
     * In case the ProductRelation found by the `where` argument doesn't exist, create a new ProductRelation with this data.
     */
    create: XOR<ProductRelationCreateInput, ProductRelationUncheckedCreateInput>
    /**
     * In case the ProductRelation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductRelationUpdateInput, ProductRelationUncheckedUpdateInput>
  }

  /**
   * ProductRelation delete
   */
  export type ProductRelationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRelation
     */
    select?: ProductRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRelation
     */
    omit?: ProductRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRelationInclude<ExtArgs> | null
    /**
     * Filter which ProductRelation to delete.
     */
    where: ProductRelationWhereUniqueInput
  }

  /**
   * ProductRelation deleteMany
   */
  export type ProductRelationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductRelations to delete
     */
    where?: ProductRelationWhereInput
    /**
     * Limit how many ProductRelations to delete.
     */
    limit?: number
  }

  /**
   * ProductRelation without action
   */
  export type ProductRelationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRelation
     */
    select?: ProductRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRelation
     */
    omit?: ProductRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRelationInclude<ExtArgs> | null
  }


  /**
   * Model RentalPackageItem
   */

  export type AggregateRentalPackageItem = {
    _count: RentalPackageItemCountAggregateOutputType | null
    _avg: RentalPackageItemAvgAggregateOutputType | null
    _sum: RentalPackageItemSumAggregateOutputType | null
    _min: RentalPackageItemMinAggregateOutputType | null
    _max: RentalPackageItemMaxAggregateOutputType | null
  }

  export type RentalPackageItemAvgAggregateOutputType = {
    quantity: number | null
  }

  export type RentalPackageItemSumAggregateOutputType = {
    quantity: number | null
  }

  export type RentalPackageItemMinAggregateOutputType = {
    id: string | null
    rentalPackageId: string | null
    productId: string | null
    quantity: number | null
    createdAt: Date | null
  }

  export type RentalPackageItemMaxAggregateOutputType = {
    id: string | null
    rentalPackageId: string | null
    productId: string | null
    quantity: number | null
    createdAt: Date | null
  }

  export type RentalPackageItemCountAggregateOutputType = {
    id: number
    rentalPackageId: number
    productId: number
    quantity: number
    createdAt: number
    _all: number
  }


  export type RentalPackageItemAvgAggregateInputType = {
    quantity?: true
  }

  export type RentalPackageItemSumAggregateInputType = {
    quantity?: true
  }

  export type RentalPackageItemMinAggregateInputType = {
    id?: true
    rentalPackageId?: true
    productId?: true
    quantity?: true
    createdAt?: true
  }

  export type RentalPackageItemMaxAggregateInputType = {
    id?: true
    rentalPackageId?: true
    productId?: true
    quantity?: true
    createdAt?: true
  }

  export type RentalPackageItemCountAggregateInputType = {
    id?: true
    rentalPackageId?: true
    productId?: true
    quantity?: true
    createdAt?: true
    _all?: true
  }

  export type RentalPackageItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RentalPackageItem to aggregate.
     */
    where?: RentalPackageItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalPackageItems to fetch.
     */
    orderBy?: RentalPackageItemOrderByWithRelationInput | RentalPackageItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RentalPackageItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalPackageItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalPackageItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RentalPackageItems
    **/
    _count?: true | RentalPackageItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RentalPackageItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RentalPackageItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RentalPackageItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RentalPackageItemMaxAggregateInputType
  }

  export type GetRentalPackageItemAggregateType<T extends RentalPackageItemAggregateArgs> = {
        [P in keyof T & keyof AggregateRentalPackageItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRentalPackageItem[P]>
      : GetScalarType<T[P], AggregateRentalPackageItem[P]>
  }




  export type RentalPackageItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RentalPackageItemWhereInput
    orderBy?: RentalPackageItemOrderByWithAggregationInput | RentalPackageItemOrderByWithAggregationInput[]
    by: RentalPackageItemScalarFieldEnum[] | RentalPackageItemScalarFieldEnum
    having?: RentalPackageItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RentalPackageItemCountAggregateInputType | true
    _avg?: RentalPackageItemAvgAggregateInputType
    _sum?: RentalPackageItemSumAggregateInputType
    _min?: RentalPackageItemMinAggregateInputType
    _max?: RentalPackageItemMaxAggregateInputType
  }

  export type RentalPackageItemGroupByOutputType = {
    id: string
    rentalPackageId: string
    productId: string
    quantity: number | null
    createdAt: Date | null
    _count: RentalPackageItemCountAggregateOutputType | null
    _avg: RentalPackageItemAvgAggregateOutputType | null
    _sum: RentalPackageItemSumAggregateOutputType | null
    _min: RentalPackageItemMinAggregateOutputType | null
    _max: RentalPackageItemMaxAggregateOutputType | null
  }

  type GetRentalPackageItemGroupByPayload<T extends RentalPackageItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RentalPackageItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RentalPackageItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RentalPackageItemGroupByOutputType[P]>
            : GetScalarType<T[P], RentalPackageItemGroupByOutputType[P]>
        }
      >
    >


  export type RentalPackageItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rentalPackageId?: boolean
    productId?: boolean
    quantity?: boolean
    createdAt?: boolean
    rentalPackage?: boolean | RentalPackageDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rentalPackageItem"]>

  export type RentalPackageItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rentalPackageId?: boolean
    productId?: boolean
    quantity?: boolean
    createdAt?: boolean
    rentalPackage?: boolean | RentalPackageDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rentalPackageItem"]>

  export type RentalPackageItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rentalPackageId?: boolean
    productId?: boolean
    quantity?: boolean
    createdAt?: boolean
    rentalPackage?: boolean | RentalPackageDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rentalPackageItem"]>

  export type RentalPackageItemSelectScalar = {
    id?: boolean
    rentalPackageId?: boolean
    productId?: boolean
    quantity?: boolean
    createdAt?: boolean
  }

  export type RentalPackageItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rentalPackageId" | "productId" | "quantity" | "createdAt", ExtArgs["result"]["rentalPackageItem"]>
  export type RentalPackageItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rentalPackage?: boolean | RentalPackageDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type RentalPackageItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rentalPackage?: boolean | RentalPackageDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type RentalPackageItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rentalPackage?: boolean | RentalPackageDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $RentalPackageItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RentalPackageItem"
    objects: {
      rentalPackage: Prisma.$RentalPackagePayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rentalPackageId: string
      productId: string
      quantity: number | null
      createdAt: Date | null
    }, ExtArgs["result"]["rentalPackageItem"]>
    composites: {}
  }

  type RentalPackageItemGetPayload<S extends boolean | null | undefined | RentalPackageItemDefaultArgs> = $Result.GetResult<Prisma.$RentalPackageItemPayload, S>

  type RentalPackageItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RentalPackageItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RentalPackageItemCountAggregateInputType | true
    }

  export interface RentalPackageItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RentalPackageItem'], meta: { name: 'RentalPackageItem' } }
    /**
     * Find zero or one RentalPackageItem that matches the filter.
     * @param {RentalPackageItemFindUniqueArgs} args - Arguments to find a RentalPackageItem
     * @example
     * // Get one RentalPackageItem
     * const rentalPackageItem = await prisma.rentalPackageItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RentalPackageItemFindUniqueArgs>(args: SelectSubset<T, RentalPackageItemFindUniqueArgs<ExtArgs>>): Prisma__RentalPackageItemClient<$Result.GetResult<Prisma.$RentalPackageItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RentalPackageItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RentalPackageItemFindUniqueOrThrowArgs} args - Arguments to find a RentalPackageItem
     * @example
     * // Get one RentalPackageItem
     * const rentalPackageItem = await prisma.rentalPackageItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RentalPackageItemFindUniqueOrThrowArgs>(args: SelectSubset<T, RentalPackageItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RentalPackageItemClient<$Result.GetResult<Prisma.$RentalPackageItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RentalPackageItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPackageItemFindFirstArgs} args - Arguments to find a RentalPackageItem
     * @example
     * // Get one RentalPackageItem
     * const rentalPackageItem = await prisma.rentalPackageItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RentalPackageItemFindFirstArgs>(args?: SelectSubset<T, RentalPackageItemFindFirstArgs<ExtArgs>>): Prisma__RentalPackageItemClient<$Result.GetResult<Prisma.$RentalPackageItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RentalPackageItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPackageItemFindFirstOrThrowArgs} args - Arguments to find a RentalPackageItem
     * @example
     * // Get one RentalPackageItem
     * const rentalPackageItem = await prisma.rentalPackageItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RentalPackageItemFindFirstOrThrowArgs>(args?: SelectSubset<T, RentalPackageItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__RentalPackageItemClient<$Result.GetResult<Prisma.$RentalPackageItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RentalPackageItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPackageItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RentalPackageItems
     * const rentalPackageItems = await prisma.rentalPackageItem.findMany()
     * 
     * // Get first 10 RentalPackageItems
     * const rentalPackageItems = await prisma.rentalPackageItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rentalPackageItemWithIdOnly = await prisma.rentalPackageItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RentalPackageItemFindManyArgs>(args?: SelectSubset<T, RentalPackageItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalPackageItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RentalPackageItem.
     * @param {RentalPackageItemCreateArgs} args - Arguments to create a RentalPackageItem.
     * @example
     * // Create one RentalPackageItem
     * const RentalPackageItem = await prisma.rentalPackageItem.create({
     *   data: {
     *     // ... data to create a RentalPackageItem
     *   }
     * })
     * 
     */
    create<T extends RentalPackageItemCreateArgs>(args: SelectSubset<T, RentalPackageItemCreateArgs<ExtArgs>>): Prisma__RentalPackageItemClient<$Result.GetResult<Prisma.$RentalPackageItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RentalPackageItems.
     * @param {RentalPackageItemCreateManyArgs} args - Arguments to create many RentalPackageItems.
     * @example
     * // Create many RentalPackageItems
     * const rentalPackageItem = await prisma.rentalPackageItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RentalPackageItemCreateManyArgs>(args?: SelectSubset<T, RentalPackageItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RentalPackageItems and returns the data saved in the database.
     * @param {RentalPackageItemCreateManyAndReturnArgs} args - Arguments to create many RentalPackageItems.
     * @example
     * // Create many RentalPackageItems
     * const rentalPackageItem = await prisma.rentalPackageItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RentalPackageItems and only return the `id`
     * const rentalPackageItemWithIdOnly = await prisma.rentalPackageItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RentalPackageItemCreateManyAndReturnArgs>(args?: SelectSubset<T, RentalPackageItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalPackageItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RentalPackageItem.
     * @param {RentalPackageItemDeleteArgs} args - Arguments to delete one RentalPackageItem.
     * @example
     * // Delete one RentalPackageItem
     * const RentalPackageItem = await prisma.rentalPackageItem.delete({
     *   where: {
     *     // ... filter to delete one RentalPackageItem
     *   }
     * })
     * 
     */
    delete<T extends RentalPackageItemDeleteArgs>(args: SelectSubset<T, RentalPackageItemDeleteArgs<ExtArgs>>): Prisma__RentalPackageItemClient<$Result.GetResult<Prisma.$RentalPackageItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RentalPackageItem.
     * @param {RentalPackageItemUpdateArgs} args - Arguments to update one RentalPackageItem.
     * @example
     * // Update one RentalPackageItem
     * const rentalPackageItem = await prisma.rentalPackageItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RentalPackageItemUpdateArgs>(args: SelectSubset<T, RentalPackageItemUpdateArgs<ExtArgs>>): Prisma__RentalPackageItemClient<$Result.GetResult<Prisma.$RentalPackageItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RentalPackageItems.
     * @param {RentalPackageItemDeleteManyArgs} args - Arguments to filter RentalPackageItems to delete.
     * @example
     * // Delete a few RentalPackageItems
     * const { count } = await prisma.rentalPackageItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RentalPackageItemDeleteManyArgs>(args?: SelectSubset<T, RentalPackageItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RentalPackageItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPackageItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RentalPackageItems
     * const rentalPackageItem = await prisma.rentalPackageItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RentalPackageItemUpdateManyArgs>(args: SelectSubset<T, RentalPackageItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RentalPackageItems and returns the data updated in the database.
     * @param {RentalPackageItemUpdateManyAndReturnArgs} args - Arguments to update many RentalPackageItems.
     * @example
     * // Update many RentalPackageItems
     * const rentalPackageItem = await prisma.rentalPackageItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RentalPackageItems and only return the `id`
     * const rentalPackageItemWithIdOnly = await prisma.rentalPackageItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RentalPackageItemUpdateManyAndReturnArgs>(args: SelectSubset<T, RentalPackageItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalPackageItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RentalPackageItem.
     * @param {RentalPackageItemUpsertArgs} args - Arguments to update or create a RentalPackageItem.
     * @example
     * // Update or create a RentalPackageItem
     * const rentalPackageItem = await prisma.rentalPackageItem.upsert({
     *   create: {
     *     // ... data to create a RentalPackageItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RentalPackageItem we want to update
     *   }
     * })
     */
    upsert<T extends RentalPackageItemUpsertArgs>(args: SelectSubset<T, RentalPackageItemUpsertArgs<ExtArgs>>): Prisma__RentalPackageItemClient<$Result.GetResult<Prisma.$RentalPackageItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RentalPackageItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPackageItemCountArgs} args - Arguments to filter RentalPackageItems to count.
     * @example
     * // Count the number of RentalPackageItems
     * const count = await prisma.rentalPackageItem.count({
     *   where: {
     *     // ... the filter for the RentalPackageItems we want to count
     *   }
     * })
    **/
    count<T extends RentalPackageItemCountArgs>(
      args?: Subset<T, RentalPackageItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RentalPackageItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RentalPackageItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPackageItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RentalPackageItemAggregateArgs>(args: Subset<T, RentalPackageItemAggregateArgs>): Prisma.PrismaPromise<GetRentalPackageItemAggregateType<T>>

    /**
     * Group by RentalPackageItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPackageItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RentalPackageItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RentalPackageItemGroupByArgs['orderBy'] }
        : { orderBy?: RentalPackageItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RentalPackageItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRentalPackageItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RentalPackageItem model
   */
  readonly fields: RentalPackageItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RentalPackageItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RentalPackageItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rentalPackage<T extends RentalPackageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RentalPackageDefaultArgs<ExtArgs>>): Prisma__RentalPackageClient<$Result.GetResult<Prisma.$RentalPackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RentalPackageItem model
   */
  interface RentalPackageItemFieldRefs {
    readonly id: FieldRef<"RentalPackageItem", 'String'>
    readonly rentalPackageId: FieldRef<"RentalPackageItem", 'String'>
    readonly productId: FieldRef<"RentalPackageItem", 'String'>
    readonly quantity: FieldRef<"RentalPackageItem", 'Int'>
    readonly createdAt: FieldRef<"RentalPackageItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RentalPackageItem findUnique
   */
  export type RentalPackageItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackageItem
     */
    select?: RentalPackageItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackageItem
     */
    omit?: RentalPackageItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageItemInclude<ExtArgs> | null
    /**
     * Filter, which RentalPackageItem to fetch.
     */
    where: RentalPackageItemWhereUniqueInput
  }

  /**
   * RentalPackageItem findUniqueOrThrow
   */
  export type RentalPackageItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackageItem
     */
    select?: RentalPackageItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackageItem
     */
    omit?: RentalPackageItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageItemInclude<ExtArgs> | null
    /**
     * Filter, which RentalPackageItem to fetch.
     */
    where: RentalPackageItemWhereUniqueInput
  }

  /**
   * RentalPackageItem findFirst
   */
  export type RentalPackageItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackageItem
     */
    select?: RentalPackageItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackageItem
     */
    omit?: RentalPackageItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageItemInclude<ExtArgs> | null
    /**
     * Filter, which RentalPackageItem to fetch.
     */
    where?: RentalPackageItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalPackageItems to fetch.
     */
    orderBy?: RentalPackageItemOrderByWithRelationInput | RentalPackageItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RentalPackageItems.
     */
    cursor?: RentalPackageItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalPackageItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalPackageItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RentalPackageItems.
     */
    distinct?: RentalPackageItemScalarFieldEnum | RentalPackageItemScalarFieldEnum[]
  }

  /**
   * RentalPackageItem findFirstOrThrow
   */
  export type RentalPackageItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackageItem
     */
    select?: RentalPackageItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackageItem
     */
    omit?: RentalPackageItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageItemInclude<ExtArgs> | null
    /**
     * Filter, which RentalPackageItem to fetch.
     */
    where?: RentalPackageItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalPackageItems to fetch.
     */
    orderBy?: RentalPackageItemOrderByWithRelationInput | RentalPackageItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RentalPackageItems.
     */
    cursor?: RentalPackageItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalPackageItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalPackageItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RentalPackageItems.
     */
    distinct?: RentalPackageItemScalarFieldEnum | RentalPackageItemScalarFieldEnum[]
  }

  /**
   * RentalPackageItem findMany
   */
  export type RentalPackageItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackageItem
     */
    select?: RentalPackageItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackageItem
     */
    omit?: RentalPackageItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageItemInclude<ExtArgs> | null
    /**
     * Filter, which RentalPackageItems to fetch.
     */
    where?: RentalPackageItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalPackageItems to fetch.
     */
    orderBy?: RentalPackageItemOrderByWithRelationInput | RentalPackageItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RentalPackageItems.
     */
    cursor?: RentalPackageItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalPackageItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalPackageItems.
     */
    skip?: number
    distinct?: RentalPackageItemScalarFieldEnum | RentalPackageItemScalarFieldEnum[]
  }

  /**
   * RentalPackageItem create
   */
  export type RentalPackageItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackageItem
     */
    select?: RentalPackageItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackageItem
     */
    omit?: RentalPackageItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageItemInclude<ExtArgs> | null
    /**
     * The data needed to create a RentalPackageItem.
     */
    data: XOR<RentalPackageItemCreateInput, RentalPackageItemUncheckedCreateInput>
  }

  /**
   * RentalPackageItem createMany
   */
  export type RentalPackageItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RentalPackageItems.
     */
    data: RentalPackageItemCreateManyInput | RentalPackageItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RentalPackageItem createManyAndReturn
   */
  export type RentalPackageItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackageItem
     */
    select?: RentalPackageItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackageItem
     */
    omit?: RentalPackageItemOmit<ExtArgs> | null
    /**
     * The data used to create many RentalPackageItems.
     */
    data: RentalPackageItemCreateManyInput | RentalPackageItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RentalPackageItem update
   */
  export type RentalPackageItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackageItem
     */
    select?: RentalPackageItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackageItem
     */
    omit?: RentalPackageItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageItemInclude<ExtArgs> | null
    /**
     * The data needed to update a RentalPackageItem.
     */
    data: XOR<RentalPackageItemUpdateInput, RentalPackageItemUncheckedUpdateInput>
    /**
     * Choose, which RentalPackageItem to update.
     */
    where: RentalPackageItemWhereUniqueInput
  }

  /**
   * RentalPackageItem updateMany
   */
  export type RentalPackageItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RentalPackageItems.
     */
    data: XOR<RentalPackageItemUpdateManyMutationInput, RentalPackageItemUncheckedUpdateManyInput>
    /**
     * Filter which RentalPackageItems to update
     */
    where?: RentalPackageItemWhereInput
    /**
     * Limit how many RentalPackageItems to update.
     */
    limit?: number
  }

  /**
   * RentalPackageItem updateManyAndReturn
   */
  export type RentalPackageItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackageItem
     */
    select?: RentalPackageItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackageItem
     */
    omit?: RentalPackageItemOmit<ExtArgs> | null
    /**
     * The data used to update RentalPackageItems.
     */
    data: XOR<RentalPackageItemUpdateManyMutationInput, RentalPackageItemUncheckedUpdateManyInput>
    /**
     * Filter which RentalPackageItems to update
     */
    where?: RentalPackageItemWhereInput
    /**
     * Limit how many RentalPackageItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RentalPackageItem upsert
   */
  export type RentalPackageItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackageItem
     */
    select?: RentalPackageItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackageItem
     */
    omit?: RentalPackageItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageItemInclude<ExtArgs> | null
    /**
     * The filter to search for the RentalPackageItem to update in case it exists.
     */
    where: RentalPackageItemWhereUniqueInput
    /**
     * In case the RentalPackageItem found by the `where` argument doesn't exist, create a new RentalPackageItem with this data.
     */
    create: XOR<RentalPackageItemCreateInput, RentalPackageItemUncheckedCreateInput>
    /**
     * In case the RentalPackageItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RentalPackageItemUpdateInput, RentalPackageItemUncheckedUpdateInput>
  }

  /**
   * RentalPackageItem delete
   */
  export type RentalPackageItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackageItem
     */
    select?: RentalPackageItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackageItem
     */
    omit?: RentalPackageItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageItemInclude<ExtArgs> | null
    /**
     * Filter which RentalPackageItem to delete.
     */
    where: RentalPackageItemWhereUniqueInput
  }

  /**
   * RentalPackageItem deleteMany
   */
  export type RentalPackageItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RentalPackageItems to delete
     */
    where?: RentalPackageItemWhereInput
    /**
     * Limit how many RentalPackageItems to delete.
     */
    limit?: number
  }

  /**
   * RentalPackageItem without action
   */
  export type RentalPackageItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackageItem
     */
    select?: RentalPackageItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackageItem
     */
    omit?: RentalPackageItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageItemInclude<ExtArgs> | null
  }


  /**
   * Model RentalPackage
   */

  export type AggregateRentalPackage = {
    _count: RentalPackageCountAggregateOutputType | null
    _avg: RentalPackageAvgAggregateOutputType | null
    _sum: RentalPackageSumAggregateOutputType | null
    _min: RentalPackageMinAggregateOutputType | null
    _max: RentalPackageMaxAggregateOutputType | null
  }

  export type RentalPackageAvgAggregateOutputType = {
    price: Decimal | null
    discountPercentage: number | null
    duration: number | null
  }

  export type RentalPackageSumAggregateOutputType = {
    price: Decimal | null
    discountPercentage: number | null
    duration: number | null
  }

  export type RentalPackageMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    price: Decimal | null
    discountPercentage: number | null
    duration: number | null
    createdAt: Date | null
  }

  export type RentalPackageMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    price: Decimal | null
    discountPercentage: number | null
    duration: number | null
    createdAt: Date | null
  }

  export type RentalPackageCountAggregateOutputType = {
    id: number
    name: number
    description: number
    imageUrl: number
    price: number
    discountPercentage: number
    duration: number
    createdAt: number
    images: number
    specs: number
    _all: number
  }


  export type RentalPackageAvgAggregateInputType = {
    price?: true
    discountPercentage?: true
    duration?: true
  }

  export type RentalPackageSumAggregateInputType = {
    price?: true
    discountPercentage?: true
    duration?: true
  }

  export type RentalPackageMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    price?: true
    discountPercentage?: true
    duration?: true
    createdAt?: true
  }

  export type RentalPackageMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    price?: true
    discountPercentage?: true
    duration?: true
    createdAt?: true
  }

  export type RentalPackageCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    price?: true
    discountPercentage?: true
    duration?: true
    createdAt?: true
    images?: true
    specs?: true
    _all?: true
  }

  export type RentalPackageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RentalPackage to aggregate.
     */
    where?: RentalPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalPackages to fetch.
     */
    orderBy?: RentalPackageOrderByWithRelationInput | RentalPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RentalPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RentalPackages
    **/
    _count?: true | RentalPackageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RentalPackageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RentalPackageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RentalPackageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RentalPackageMaxAggregateInputType
  }

  export type GetRentalPackageAggregateType<T extends RentalPackageAggregateArgs> = {
        [P in keyof T & keyof AggregateRentalPackage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRentalPackage[P]>
      : GetScalarType<T[P], AggregateRentalPackage[P]>
  }




  export type RentalPackageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RentalPackageWhereInput
    orderBy?: RentalPackageOrderByWithAggregationInput | RentalPackageOrderByWithAggregationInput[]
    by: RentalPackageScalarFieldEnum[] | RentalPackageScalarFieldEnum
    having?: RentalPackageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RentalPackageCountAggregateInputType | true
    _avg?: RentalPackageAvgAggregateInputType
    _sum?: RentalPackageSumAggregateInputType
    _min?: RentalPackageMinAggregateInputType
    _max?: RentalPackageMaxAggregateInputType
  }

  export type RentalPackageGroupByOutputType = {
    id: string
    name: string
    description: string | null
    imageUrl: string | null
    price: Decimal
    discountPercentage: number | null
    duration: number
    createdAt: Date | null
    images: string[]
    specs: JsonValue | null
    _count: RentalPackageCountAggregateOutputType | null
    _avg: RentalPackageAvgAggregateOutputType | null
    _sum: RentalPackageSumAggregateOutputType | null
    _min: RentalPackageMinAggregateOutputType | null
    _max: RentalPackageMaxAggregateOutputType | null
  }

  type GetRentalPackageGroupByPayload<T extends RentalPackageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RentalPackageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RentalPackageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RentalPackageGroupByOutputType[P]>
            : GetScalarType<T[P], RentalPackageGroupByOutputType[P]>
        }
      >
    >


  export type RentalPackageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    price?: boolean
    discountPercentage?: boolean
    duration?: boolean
    createdAt?: boolean
    images?: boolean
    specs?: boolean
    rentalPackageItems?: boolean | RentalPackage$rentalPackageItemsArgs<ExtArgs>
    rentalItems?: boolean | RentalPackage$rentalItemsArgs<ExtArgs>
    _count?: boolean | RentalPackageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rentalPackage"]>

  export type RentalPackageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    price?: boolean
    discountPercentage?: boolean
    duration?: boolean
    createdAt?: boolean
    images?: boolean
    specs?: boolean
  }, ExtArgs["result"]["rentalPackage"]>

  export type RentalPackageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    price?: boolean
    discountPercentage?: boolean
    duration?: boolean
    createdAt?: boolean
    images?: boolean
    specs?: boolean
  }, ExtArgs["result"]["rentalPackage"]>

  export type RentalPackageSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    price?: boolean
    discountPercentage?: boolean
    duration?: boolean
    createdAt?: boolean
    images?: boolean
    specs?: boolean
  }

  export type RentalPackageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "imageUrl" | "price" | "discountPercentage" | "duration" | "createdAt" | "images" | "specs", ExtArgs["result"]["rentalPackage"]>
  export type RentalPackageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rentalPackageItems?: boolean | RentalPackage$rentalPackageItemsArgs<ExtArgs>
    rentalItems?: boolean | RentalPackage$rentalItemsArgs<ExtArgs>
    _count?: boolean | RentalPackageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RentalPackageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RentalPackageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RentalPackagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RentalPackage"
    objects: {
      rentalPackageItems: Prisma.$RentalPackageItemPayload<ExtArgs>[]
      rentalItems: Prisma.$RentalItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      imageUrl: string | null
      price: Prisma.Decimal
      discountPercentage: number | null
      duration: number
      createdAt: Date | null
      images: string[]
      specs: Prisma.JsonValue | null
    }, ExtArgs["result"]["rentalPackage"]>
    composites: {}
  }

  type RentalPackageGetPayload<S extends boolean | null | undefined | RentalPackageDefaultArgs> = $Result.GetResult<Prisma.$RentalPackagePayload, S>

  type RentalPackageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RentalPackageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RentalPackageCountAggregateInputType | true
    }

  export interface RentalPackageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RentalPackage'], meta: { name: 'RentalPackage' } }
    /**
     * Find zero or one RentalPackage that matches the filter.
     * @param {RentalPackageFindUniqueArgs} args - Arguments to find a RentalPackage
     * @example
     * // Get one RentalPackage
     * const rentalPackage = await prisma.rentalPackage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RentalPackageFindUniqueArgs>(args: SelectSubset<T, RentalPackageFindUniqueArgs<ExtArgs>>): Prisma__RentalPackageClient<$Result.GetResult<Prisma.$RentalPackagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RentalPackage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RentalPackageFindUniqueOrThrowArgs} args - Arguments to find a RentalPackage
     * @example
     * // Get one RentalPackage
     * const rentalPackage = await prisma.rentalPackage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RentalPackageFindUniqueOrThrowArgs>(args: SelectSubset<T, RentalPackageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RentalPackageClient<$Result.GetResult<Prisma.$RentalPackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RentalPackage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPackageFindFirstArgs} args - Arguments to find a RentalPackage
     * @example
     * // Get one RentalPackage
     * const rentalPackage = await prisma.rentalPackage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RentalPackageFindFirstArgs>(args?: SelectSubset<T, RentalPackageFindFirstArgs<ExtArgs>>): Prisma__RentalPackageClient<$Result.GetResult<Prisma.$RentalPackagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RentalPackage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPackageFindFirstOrThrowArgs} args - Arguments to find a RentalPackage
     * @example
     * // Get one RentalPackage
     * const rentalPackage = await prisma.rentalPackage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RentalPackageFindFirstOrThrowArgs>(args?: SelectSubset<T, RentalPackageFindFirstOrThrowArgs<ExtArgs>>): Prisma__RentalPackageClient<$Result.GetResult<Prisma.$RentalPackagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RentalPackages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPackageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RentalPackages
     * const rentalPackages = await prisma.rentalPackage.findMany()
     * 
     * // Get first 10 RentalPackages
     * const rentalPackages = await prisma.rentalPackage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rentalPackageWithIdOnly = await prisma.rentalPackage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RentalPackageFindManyArgs>(args?: SelectSubset<T, RentalPackageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalPackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RentalPackage.
     * @param {RentalPackageCreateArgs} args - Arguments to create a RentalPackage.
     * @example
     * // Create one RentalPackage
     * const RentalPackage = await prisma.rentalPackage.create({
     *   data: {
     *     // ... data to create a RentalPackage
     *   }
     * })
     * 
     */
    create<T extends RentalPackageCreateArgs>(args: SelectSubset<T, RentalPackageCreateArgs<ExtArgs>>): Prisma__RentalPackageClient<$Result.GetResult<Prisma.$RentalPackagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RentalPackages.
     * @param {RentalPackageCreateManyArgs} args - Arguments to create many RentalPackages.
     * @example
     * // Create many RentalPackages
     * const rentalPackage = await prisma.rentalPackage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RentalPackageCreateManyArgs>(args?: SelectSubset<T, RentalPackageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RentalPackages and returns the data saved in the database.
     * @param {RentalPackageCreateManyAndReturnArgs} args - Arguments to create many RentalPackages.
     * @example
     * // Create many RentalPackages
     * const rentalPackage = await prisma.rentalPackage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RentalPackages and only return the `id`
     * const rentalPackageWithIdOnly = await prisma.rentalPackage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RentalPackageCreateManyAndReturnArgs>(args?: SelectSubset<T, RentalPackageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalPackagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RentalPackage.
     * @param {RentalPackageDeleteArgs} args - Arguments to delete one RentalPackage.
     * @example
     * // Delete one RentalPackage
     * const RentalPackage = await prisma.rentalPackage.delete({
     *   where: {
     *     // ... filter to delete one RentalPackage
     *   }
     * })
     * 
     */
    delete<T extends RentalPackageDeleteArgs>(args: SelectSubset<T, RentalPackageDeleteArgs<ExtArgs>>): Prisma__RentalPackageClient<$Result.GetResult<Prisma.$RentalPackagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RentalPackage.
     * @param {RentalPackageUpdateArgs} args - Arguments to update one RentalPackage.
     * @example
     * // Update one RentalPackage
     * const rentalPackage = await prisma.rentalPackage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RentalPackageUpdateArgs>(args: SelectSubset<T, RentalPackageUpdateArgs<ExtArgs>>): Prisma__RentalPackageClient<$Result.GetResult<Prisma.$RentalPackagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RentalPackages.
     * @param {RentalPackageDeleteManyArgs} args - Arguments to filter RentalPackages to delete.
     * @example
     * // Delete a few RentalPackages
     * const { count } = await prisma.rentalPackage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RentalPackageDeleteManyArgs>(args?: SelectSubset<T, RentalPackageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RentalPackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPackageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RentalPackages
     * const rentalPackage = await prisma.rentalPackage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RentalPackageUpdateManyArgs>(args: SelectSubset<T, RentalPackageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RentalPackages and returns the data updated in the database.
     * @param {RentalPackageUpdateManyAndReturnArgs} args - Arguments to update many RentalPackages.
     * @example
     * // Update many RentalPackages
     * const rentalPackage = await prisma.rentalPackage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RentalPackages and only return the `id`
     * const rentalPackageWithIdOnly = await prisma.rentalPackage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RentalPackageUpdateManyAndReturnArgs>(args: SelectSubset<T, RentalPackageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalPackagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RentalPackage.
     * @param {RentalPackageUpsertArgs} args - Arguments to update or create a RentalPackage.
     * @example
     * // Update or create a RentalPackage
     * const rentalPackage = await prisma.rentalPackage.upsert({
     *   create: {
     *     // ... data to create a RentalPackage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RentalPackage we want to update
     *   }
     * })
     */
    upsert<T extends RentalPackageUpsertArgs>(args: SelectSubset<T, RentalPackageUpsertArgs<ExtArgs>>): Prisma__RentalPackageClient<$Result.GetResult<Prisma.$RentalPackagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RentalPackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPackageCountArgs} args - Arguments to filter RentalPackages to count.
     * @example
     * // Count the number of RentalPackages
     * const count = await prisma.rentalPackage.count({
     *   where: {
     *     // ... the filter for the RentalPackages we want to count
     *   }
     * })
    **/
    count<T extends RentalPackageCountArgs>(
      args?: Subset<T, RentalPackageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RentalPackageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RentalPackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RentalPackageAggregateArgs>(args: Subset<T, RentalPackageAggregateArgs>): Prisma.PrismaPromise<GetRentalPackageAggregateType<T>>

    /**
     * Group by RentalPackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPackageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RentalPackageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RentalPackageGroupByArgs['orderBy'] }
        : { orderBy?: RentalPackageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RentalPackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRentalPackageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RentalPackage model
   */
  readonly fields: RentalPackageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RentalPackage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RentalPackageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rentalPackageItems<T extends RentalPackage$rentalPackageItemsArgs<ExtArgs> = {}>(args?: Subset<T, RentalPackage$rentalPackageItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalPackageItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rentalItems<T extends RentalPackage$rentalItemsArgs<ExtArgs> = {}>(args?: Subset<T, RentalPackage$rentalItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RentalPackage model
   */
  interface RentalPackageFieldRefs {
    readonly id: FieldRef<"RentalPackage", 'String'>
    readonly name: FieldRef<"RentalPackage", 'String'>
    readonly description: FieldRef<"RentalPackage", 'String'>
    readonly imageUrl: FieldRef<"RentalPackage", 'String'>
    readonly price: FieldRef<"RentalPackage", 'Decimal'>
    readonly discountPercentage: FieldRef<"RentalPackage", 'Int'>
    readonly duration: FieldRef<"RentalPackage", 'Int'>
    readonly createdAt: FieldRef<"RentalPackage", 'DateTime'>
    readonly images: FieldRef<"RentalPackage", 'String[]'>
    readonly specs: FieldRef<"RentalPackage", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * RentalPackage findUnique
   */
  export type RentalPackageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackage
     */
    select?: RentalPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackage
     */
    omit?: RentalPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageInclude<ExtArgs> | null
    /**
     * Filter, which RentalPackage to fetch.
     */
    where: RentalPackageWhereUniqueInput
  }

  /**
   * RentalPackage findUniqueOrThrow
   */
  export type RentalPackageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackage
     */
    select?: RentalPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackage
     */
    omit?: RentalPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageInclude<ExtArgs> | null
    /**
     * Filter, which RentalPackage to fetch.
     */
    where: RentalPackageWhereUniqueInput
  }

  /**
   * RentalPackage findFirst
   */
  export type RentalPackageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackage
     */
    select?: RentalPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackage
     */
    omit?: RentalPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageInclude<ExtArgs> | null
    /**
     * Filter, which RentalPackage to fetch.
     */
    where?: RentalPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalPackages to fetch.
     */
    orderBy?: RentalPackageOrderByWithRelationInput | RentalPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RentalPackages.
     */
    cursor?: RentalPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RentalPackages.
     */
    distinct?: RentalPackageScalarFieldEnum | RentalPackageScalarFieldEnum[]
  }

  /**
   * RentalPackage findFirstOrThrow
   */
  export type RentalPackageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackage
     */
    select?: RentalPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackage
     */
    omit?: RentalPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageInclude<ExtArgs> | null
    /**
     * Filter, which RentalPackage to fetch.
     */
    where?: RentalPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalPackages to fetch.
     */
    orderBy?: RentalPackageOrderByWithRelationInput | RentalPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RentalPackages.
     */
    cursor?: RentalPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RentalPackages.
     */
    distinct?: RentalPackageScalarFieldEnum | RentalPackageScalarFieldEnum[]
  }

  /**
   * RentalPackage findMany
   */
  export type RentalPackageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackage
     */
    select?: RentalPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackage
     */
    omit?: RentalPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageInclude<ExtArgs> | null
    /**
     * Filter, which RentalPackages to fetch.
     */
    where?: RentalPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalPackages to fetch.
     */
    orderBy?: RentalPackageOrderByWithRelationInput | RentalPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RentalPackages.
     */
    cursor?: RentalPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalPackages.
     */
    skip?: number
    distinct?: RentalPackageScalarFieldEnum | RentalPackageScalarFieldEnum[]
  }

  /**
   * RentalPackage create
   */
  export type RentalPackageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackage
     */
    select?: RentalPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackage
     */
    omit?: RentalPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageInclude<ExtArgs> | null
    /**
     * The data needed to create a RentalPackage.
     */
    data: XOR<RentalPackageCreateInput, RentalPackageUncheckedCreateInput>
  }

  /**
   * RentalPackage createMany
   */
  export type RentalPackageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RentalPackages.
     */
    data: RentalPackageCreateManyInput | RentalPackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RentalPackage createManyAndReturn
   */
  export type RentalPackageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackage
     */
    select?: RentalPackageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackage
     */
    omit?: RentalPackageOmit<ExtArgs> | null
    /**
     * The data used to create many RentalPackages.
     */
    data: RentalPackageCreateManyInput | RentalPackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RentalPackage update
   */
  export type RentalPackageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackage
     */
    select?: RentalPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackage
     */
    omit?: RentalPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageInclude<ExtArgs> | null
    /**
     * The data needed to update a RentalPackage.
     */
    data: XOR<RentalPackageUpdateInput, RentalPackageUncheckedUpdateInput>
    /**
     * Choose, which RentalPackage to update.
     */
    where: RentalPackageWhereUniqueInput
  }

  /**
   * RentalPackage updateMany
   */
  export type RentalPackageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RentalPackages.
     */
    data: XOR<RentalPackageUpdateManyMutationInput, RentalPackageUncheckedUpdateManyInput>
    /**
     * Filter which RentalPackages to update
     */
    where?: RentalPackageWhereInput
    /**
     * Limit how many RentalPackages to update.
     */
    limit?: number
  }

  /**
   * RentalPackage updateManyAndReturn
   */
  export type RentalPackageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackage
     */
    select?: RentalPackageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackage
     */
    omit?: RentalPackageOmit<ExtArgs> | null
    /**
     * The data used to update RentalPackages.
     */
    data: XOR<RentalPackageUpdateManyMutationInput, RentalPackageUncheckedUpdateManyInput>
    /**
     * Filter which RentalPackages to update
     */
    where?: RentalPackageWhereInput
    /**
     * Limit how many RentalPackages to update.
     */
    limit?: number
  }

  /**
   * RentalPackage upsert
   */
  export type RentalPackageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackage
     */
    select?: RentalPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackage
     */
    omit?: RentalPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageInclude<ExtArgs> | null
    /**
     * The filter to search for the RentalPackage to update in case it exists.
     */
    where: RentalPackageWhereUniqueInput
    /**
     * In case the RentalPackage found by the `where` argument doesn't exist, create a new RentalPackage with this data.
     */
    create: XOR<RentalPackageCreateInput, RentalPackageUncheckedCreateInput>
    /**
     * In case the RentalPackage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RentalPackageUpdateInput, RentalPackageUncheckedUpdateInput>
  }

  /**
   * RentalPackage delete
   */
  export type RentalPackageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackage
     */
    select?: RentalPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackage
     */
    omit?: RentalPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageInclude<ExtArgs> | null
    /**
     * Filter which RentalPackage to delete.
     */
    where: RentalPackageWhereUniqueInput
  }

  /**
   * RentalPackage deleteMany
   */
  export type RentalPackageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RentalPackages to delete
     */
    where?: RentalPackageWhereInput
    /**
     * Limit how many RentalPackages to delete.
     */
    limit?: number
  }

  /**
   * RentalPackage.rentalPackageItems
   */
  export type RentalPackage$rentalPackageItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackageItem
     */
    select?: RentalPackageItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackageItem
     */
    omit?: RentalPackageItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageItemInclude<ExtArgs> | null
    where?: RentalPackageItemWhereInput
    orderBy?: RentalPackageItemOrderByWithRelationInput | RentalPackageItemOrderByWithRelationInput[]
    cursor?: RentalPackageItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RentalPackageItemScalarFieldEnum | RentalPackageItemScalarFieldEnum[]
  }

  /**
   * RentalPackage.rentalItems
   */
  export type RentalPackage$rentalItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalItem
     */
    select?: RentalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalItem
     */
    omit?: RentalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalItemInclude<ExtArgs> | null
    where?: RentalItemWhereInput
    orderBy?: RentalItemOrderByWithRelationInput | RentalItemOrderByWithRelationInput[]
    cursor?: RentalItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RentalItemScalarFieldEnum | RentalItemScalarFieldEnum[]
  }

  /**
   * RentalPackage without action
   */
  export type RentalPackageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackage
     */
    select?: RentalPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackage
     */
    omit?: RentalPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    monthlyPrice: Decimal | null
    discountPercentage: number | null
  }

  export type ProductSumAggregateOutputType = {
    monthlyPrice: Decimal | null
    discountPercentage: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    monthlyPrice: Decimal | null
    discountPercentage: number | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    monthlyPrice: Decimal | null
    discountPercentage: number | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    monthlyPrice: number
    discountPercentage: number
    imageUrl: number
    createdAt: number
    images: number
    specs: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    monthlyPrice?: true
    discountPercentage?: true
  }

  export type ProductSumAggregateInputType = {
    monthlyPrice?: true
    discountPercentage?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    monthlyPrice?: true
    discountPercentage?: true
    imageUrl?: true
    createdAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    monthlyPrice?: true
    discountPercentage?: true
    imageUrl?: true
    createdAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    monthlyPrice?: true
    discountPercentage?: true
    imageUrl?: true
    createdAt?: true
    images?: true
    specs?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    description: string | null
    category: string
    monthlyPrice: Decimal
    discountPercentage: number | null
    imageUrl: string | null
    createdAt: Date | null
    images: string[]
    specs: JsonValue | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    monthlyPrice?: boolean
    discountPercentage?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    images?: boolean
    specs?: boolean
    inventorySyncLogs?: boolean | Product$inventorySyncLogsArgs<ExtArgs>
    rentalPackageItems?: boolean | Product$rentalPackageItemsArgs<ExtArgs>
    productRelations?: boolean | Product$productRelationsArgs<ExtArgs>
    relatedTo?: boolean | Product$relatedToArgs<ExtArgs>
    variants?: boolean | Product$variantsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    monthlyPrice?: boolean
    discountPercentage?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    images?: boolean
    specs?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    monthlyPrice?: boolean
    discountPercentage?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    images?: boolean
    specs?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    monthlyPrice?: boolean
    discountPercentage?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    images?: boolean
    specs?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category" | "monthlyPrice" | "discountPercentage" | "imageUrl" | "createdAt" | "images" | "specs", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventorySyncLogs?: boolean | Product$inventorySyncLogsArgs<ExtArgs>
    rentalPackageItems?: boolean | Product$rentalPackageItemsArgs<ExtArgs>
    productRelations?: boolean | Product$productRelationsArgs<ExtArgs>
    relatedTo?: boolean | Product$relatedToArgs<ExtArgs>
    variants?: boolean | Product$variantsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      inventorySyncLogs: Prisma.$InventorySyncLogPayload<ExtArgs>[]
      rentalPackageItems: Prisma.$RentalPackageItemPayload<ExtArgs>[]
      productRelations: Prisma.$ProductRelationPayload<ExtArgs>[]
      relatedTo: Prisma.$ProductRelationPayload<ExtArgs>[]
      variants: Prisma.$ProductVariantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      category: string
      monthlyPrice: Prisma.Decimal
      discountPercentage: number | null
      imageUrl: string | null
      createdAt: Date | null
      images: string[]
      specs: Prisma.JsonValue | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventorySyncLogs<T extends Product$inventorySyncLogsArgs<ExtArgs> = {}>(args?: Subset<T, Product$inventorySyncLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventorySyncLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rentalPackageItems<T extends Product$rentalPackageItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$rentalPackageItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalPackageItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productRelations<T extends Product$productRelationsArgs<ExtArgs> = {}>(args?: Subset<T, Product$productRelationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    relatedTo<T extends Product$relatedToArgs<ExtArgs> = {}>(args?: Subset<T, Product$relatedToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    variants<T extends Product$variantsArgs<ExtArgs> = {}>(args?: Subset<T, Product$variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly category: FieldRef<"Product", 'String'>
    readonly monthlyPrice: FieldRef<"Product", 'Decimal'>
    readonly discountPercentage: FieldRef<"Product", 'Int'>
    readonly imageUrl: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly images: FieldRef<"Product", 'String[]'>
    readonly specs: FieldRef<"Product", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.inventorySyncLogs
   */
  export type Product$inventorySyncLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySyncLog
     */
    select?: InventorySyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySyncLog
     */
    omit?: InventorySyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySyncLogInclude<ExtArgs> | null
    where?: InventorySyncLogWhereInput
    orderBy?: InventorySyncLogOrderByWithRelationInput | InventorySyncLogOrderByWithRelationInput[]
    cursor?: InventorySyncLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventorySyncLogScalarFieldEnum | InventorySyncLogScalarFieldEnum[]
  }

  /**
   * Product.rentalPackageItems
   */
  export type Product$rentalPackageItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackageItem
     */
    select?: RentalPackageItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackageItem
     */
    omit?: RentalPackageItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageItemInclude<ExtArgs> | null
    where?: RentalPackageItemWhereInput
    orderBy?: RentalPackageItemOrderByWithRelationInput | RentalPackageItemOrderByWithRelationInput[]
    cursor?: RentalPackageItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RentalPackageItemScalarFieldEnum | RentalPackageItemScalarFieldEnum[]
  }

  /**
   * Product.productRelations
   */
  export type Product$productRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRelation
     */
    select?: ProductRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRelation
     */
    omit?: ProductRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRelationInclude<ExtArgs> | null
    where?: ProductRelationWhereInput
    orderBy?: ProductRelationOrderByWithRelationInput | ProductRelationOrderByWithRelationInput[]
    cursor?: ProductRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductRelationScalarFieldEnum | ProductRelationScalarFieldEnum[]
  }

  /**
   * Product.relatedTo
   */
  export type Product$relatedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRelation
     */
    select?: ProductRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRelation
     */
    omit?: ProductRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRelationInclude<ExtArgs> | null
    where?: ProductRelationWhereInput
    orderBy?: ProductRelationOrderByWithRelationInput | ProductRelationOrderByWithRelationInput[]
    cursor?: ProductRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductRelationScalarFieldEnum | ProductRelationScalarFieldEnum[]
  }

  /**
   * Product.variants
   */
  export type Product$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    where?: ProductVariantWhereInput
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    cursor?: ProductVariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductVariant
   */

  export type AggregateProductVariant = {
    _count: ProductVariantCountAggregateOutputType | null
    _avg: ProductVariantAvgAggregateOutputType | null
    _sum: ProductVariantSumAggregateOutputType | null
    _min: ProductVariantMinAggregateOutputType | null
    _max: ProductVariantMaxAggregateOutputType | null
  }

  export type ProductVariantAvgAggregateOutputType = {
    monthlyPrice: Decimal | null
  }

  export type ProductVariantSumAggregateOutputType = {
    monthlyPrice: Decimal | null
  }

  export type ProductVariantMinAggregateOutputType = {
    id: string | null
    productId: string | null
    color: string | null
    sku: string | null
    monthlyPrice: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariantMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    color: string | null
    sku: string | null
    monthlyPrice: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariantCountAggregateOutputType = {
    id: number
    productId: number
    color: number
    sku: number
    monthlyPrice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductVariantAvgAggregateInputType = {
    monthlyPrice?: true
  }

  export type ProductVariantSumAggregateInputType = {
    monthlyPrice?: true
  }

  export type ProductVariantMinAggregateInputType = {
    id?: true
    productId?: true
    color?: true
    sku?: true
    monthlyPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariantMaxAggregateInputType = {
    id?: true
    productId?: true
    color?: true
    sku?: true
    monthlyPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariantCountAggregateInputType = {
    id?: true
    productId?: true
    color?: true
    sku?: true
    monthlyPrice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductVariantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariant to aggregate.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductVariants
    **/
    _count?: true | ProductVariantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductVariantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductVariantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductVariantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductVariantMaxAggregateInputType
  }

  export type GetProductVariantAggregateType<T extends ProductVariantAggregateArgs> = {
        [P in keyof T & keyof AggregateProductVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductVariant[P]>
      : GetScalarType<T[P], AggregateProductVariant[P]>
  }




  export type ProductVariantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariantWhereInput
    orderBy?: ProductVariantOrderByWithAggregationInput | ProductVariantOrderByWithAggregationInput[]
    by: ProductVariantScalarFieldEnum[] | ProductVariantScalarFieldEnum
    having?: ProductVariantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductVariantCountAggregateInputType | true
    _avg?: ProductVariantAvgAggregateInputType
    _sum?: ProductVariantSumAggregateInputType
    _min?: ProductVariantMinAggregateInputType
    _max?: ProductVariantMaxAggregateInputType
  }

  export type ProductVariantGroupByOutputType = {
    id: string
    productId: string
    color: string
    sku: string
    monthlyPrice: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: ProductVariantCountAggregateOutputType | null
    _avg: ProductVariantAvgAggregateOutputType | null
    _sum: ProductVariantSumAggregateOutputType | null
    _min: ProductVariantMinAggregateOutputType | null
    _max: ProductVariantMaxAggregateOutputType | null
  }

  type GetProductVariantGroupByPayload<T extends ProductVariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductVariantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductVariantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductVariantGroupByOutputType[P]>
            : GetScalarType<T[P], ProductVariantGroupByOutputType[P]>
        }
      >
    >


  export type ProductVariantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    color?: boolean
    sku?: boolean
    monthlyPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    rentalItems?: boolean | ProductVariant$rentalItemsArgs<ExtArgs>
    units?: boolean | ProductVariant$unitsArgs<ExtArgs>
    _count?: boolean | ProductVariantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariant"]>

  export type ProductVariantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    color?: boolean
    sku?: boolean
    monthlyPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariant"]>

  export type ProductVariantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    color?: boolean
    sku?: boolean
    monthlyPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariant"]>

  export type ProductVariantSelectScalar = {
    id?: boolean
    productId?: boolean
    color?: boolean
    sku?: boolean
    monthlyPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductVariantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "color" | "sku" | "monthlyPrice" | "createdAt" | "updatedAt", ExtArgs["result"]["productVariant"]>
  export type ProductVariantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    rentalItems?: boolean | ProductVariant$rentalItemsArgs<ExtArgs>
    units?: boolean | ProductVariant$unitsArgs<ExtArgs>
    _count?: boolean | ProductVariantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductVariantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductVariantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductVariantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductVariant"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      rentalItems: Prisma.$RentalItemPayload<ExtArgs>[]
      units: Prisma.$ProductUnitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      color: string
      sku: string
      monthlyPrice: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productVariant"]>
    composites: {}
  }

  type ProductVariantGetPayload<S extends boolean | null | undefined | ProductVariantDefaultArgs> = $Result.GetResult<Prisma.$ProductVariantPayload, S>

  type ProductVariantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductVariantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductVariantCountAggregateInputType | true
    }

  export interface ProductVariantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductVariant'], meta: { name: 'ProductVariant' } }
    /**
     * Find zero or one ProductVariant that matches the filter.
     * @param {ProductVariantFindUniqueArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductVariantFindUniqueArgs>(args: SelectSubset<T, ProductVariantFindUniqueArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductVariant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductVariantFindUniqueOrThrowArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductVariantFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductVariantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductVariant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindFirstArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductVariantFindFirstArgs>(args?: SelectSubset<T, ProductVariantFindFirstArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductVariant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindFirstOrThrowArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductVariantFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductVariantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductVariants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductVariants
     * const productVariants = await prisma.productVariant.findMany()
     * 
     * // Get first 10 ProductVariants
     * const productVariants = await prisma.productVariant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productVariantWithIdOnly = await prisma.productVariant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductVariantFindManyArgs>(args?: SelectSubset<T, ProductVariantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductVariant.
     * @param {ProductVariantCreateArgs} args - Arguments to create a ProductVariant.
     * @example
     * // Create one ProductVariant
     * const ProductVariant = await prisma.productVariant.create({
     *   data: {
     *     // ... data to create a ProductVariant
     *   }
     * })
     * 
     */
    create<T extends ProductVariantCreateArgs>(args: SelectSubset<T, ProductVariantCreateArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductVariants.
     * @param {ProductVariantCreateManyArgs} args - Arguments to create many ProductVariants.
     * @example
     * // Create many ProductVariants
     * const productVariant = await prisma.productVariant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductVariantCreateManyArgs>(args?: SelectSubset<T, ProductVariantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductVariants and returns the data saved in the database.
     * @param {ProductVariantCreateManyAndReturnArgs} args - Arguments to create many ProductVariants.
     * @example
     * // Create many ProductVariants
     * const productVariant = await prisma.productVariant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductVariants and only return the `id`
     * const productVariantWithIdOnly = await prisma.productVariant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductVariantCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductVariantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductVariant.
     * @param {ProductVariantDeleteArgs} args - Arguments to delete one ProductVariant.
     * @example
     * // Delete one ProductVariant
     * const ProductVariant = await prisma.productVariant.delete({
     *   where: {
     *     // ... filter to delete one ProductVariant
     *   }
     * })
     * 
     */
    delete<T extends ProductVariantDeleteArgs>(args: SelectSubset<T, ProductVariantDeleteArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductVariant.
     * @param {ProductVariantUpdateArgs} args - Arguments to update one ProductVariant.
     * @example
     * // Update one ProductVariant
     * const productVariant = await prisma.productVariant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductVariantUpdateArgs>(args: SelectSubset<T, ProductVariantUpdateArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductVariants.
     * @param {ProductVariantDeleteManyArgs} args - Arguments to filter ProductVariants to delete.
     * @example
     * // Delete a few ProductVariants
     * const { count } = await prisma.productVariant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductVariantDeleteManyArgs>(args?: SelectSubset<T, ProductVariantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductVariants
     * const productVariant = await prisma.productVariant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductVariantUpdateManyArgs>(args: SelectSubset<T, ProductVariantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVariants and returns the data updated in the database.
     * @param {ProductVariantUpdateManyAndReturnArgs} args - Arguments to update many ProductVariants.
     * @example
     * // Update many ProductVariants
     * const productVariant = await prisma.productVariant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductVariants and only return the `id`
     * const productVariantWithIdOnly = await prisma.productVariant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductVariantUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductVariantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductVariant.
     * @param {ProductVariantUpsertArgs} args - Arguments to update or create a ProductVariant.
     * @example
     * // Update or create a ProductVariant
     * const productVariant = await prisma.productVariant.upsert({
     *   create: {
     *     // ... data to create a ProductVariant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductVariant we want to update
     *   }
     * })
     */
    upsert<T extends ProductVariantUpsertArgs>(args: SelectSubset<T, ProductVariantUpsertArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantCountArgs} args - Arguments to filter ProductVariants to count.
     * @example
     * // Count the number of ProductVariants
     * const count = await prisma.productVariant.count({
     *   where: {
     *     // ... the filter for the ProductVariants we want to count
     *   }
     * })
    **/
    count<T extends ProductVariantCountArgs>(
      args?: Subset<T, ProductVariantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductVariantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductVariantAggregateArgs>(args: Subset<T, ProductVariantAggregateArgs>): Prisma.PrismaPromise<GetProductVariantAggregateType<T>>

    /**
     * Group by ProductVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductVariantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductVariantGroupByArgs['orderBy'] }
        : { orderBy?: ProductVariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductVariantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductVariantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductVariant model
   */
  readonly fields: ProductVariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductVariant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductVariantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rentalItems<T extends ProductVariant$rentalItemsArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariant$rentalItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    units<T extends ProductVariant$unitsArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariant$unitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductUnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductVariant model
   */
  interface ProductVariantFieldRefs {
    readonly id: FieldRef<"ProductVariant", 'String'>
    readonly productId: FieldRef<"ProductVariant", 'String'>
    readonly color: FieldRef<"ProductVariant", 'String'>
    readonly sku: FieldRef<"ProductVariant", 'String'>
    readonly monthlyPrice: FieldRef<"ProductVariant", 'Decimal'>
    readonly createdAt: FieldRef<"ProductVariant", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductVariant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductVariant findUnique
   */
  export type ProductVariantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant findUniqueOrThrow
   */
  export type ProductVariantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant findFirst
   */
  export type ProductVariantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariants.
     */
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * ProductVariant findFirstOrThrow
   */
  export type ProductVariantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariants.
     */
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * ProductVariant findMany
   */
  export type ProductVariantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariants to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * ProductVariant create
   */
  export type ProductVariantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductVariant.
     */
    data: XOR<ProductVariantCreateInput, ProductVariantUncheckedCreateInput>
  }

  /**
   * ProductVariant createMany
   */
  export type ProductVariantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductVariants.
     */
    data: ProductVariantCreateManyInput | ProductVariantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductVariant createManyAndReturn
   */
  export type ProductVariantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * The data used to create many ProductVariants.
     */
    data: ProductVariantCreateManyInput | ProductVariantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductVariant update
   */
  export type ProductVariantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductVariant.
     */
    data: XOR<ProductVariantUpdateInput, ProductVariantUncheckedUpdateInput>
    /**
     * Choose, which ProductVariant to update.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant updateMany
   */
  export type ProductVariantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductVariants.
     */
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyInput>
    /**
     * Filter which ProductVariants to update
     */
    where?: ProductVariantWhereInput
    /**
     * Limit how many ProductVariants to update.
     */
    limit?: number
  }

  /**
   * ProductVariant updateManyAndReturn
   */
  export type ProductVariantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * The data used to update ProductVariants.
     */
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyInput>
    /**
     * Filter which ProductVariants to update
     */
    where?: ProductVariantWhereInput
    /**
     * Limit how many ProductVariants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductVariant upsert
   */
  export type ProductVariantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductVariant to update in case it exists.
     */
    where: ProductVariantWhereUniqueInput
    /**
     * In case the ProductVariant found by the `where` argument doesn't exist, create a new ProductVariant with this data.
     */
    create: XOR<ProductVariantCreateInput, ProductVariantUncheckedCreateInput>
    /**
     * In case the ProductVariant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductVariantUpdateInput, ProductVariantUncheckedUpdateInput>
  }

  /**
   * ProductVariant delete
   */
  export type ProductVariantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter which ProductVariant to delete.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant deleteMany
   */
  export type ProductVariantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariants to delete
     */
    where?: ProductVariantWhereInput
    /**
     * Limit how many ProductVariants to delete.
     */
    limit?: number
  }

  /**
   * ProductVariant.rentalItems
   */
  export type ProductVariant$rentalItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalItem
     */
    select?: RentalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalItem
     */
    omit?: RentalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalItemInclude<ExtArgs> | null
    where?: RentalItemWhereInput
    orderBy?: RentalItemOrderByWithRelationInput | RentalItemOrderByWithRelationInput[]
    cursor?: RentalItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RentalItemScalarFieldEnum | RentalItemScalarFieldEnum[]
  }

  /**
   * ProductVariant.units
   */
  export type ProductVariant$unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductUnit
     */
    select?: ProductUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductUnit
     */
    omit?: ProductUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductUnitInclude<ExtArgs> | null
    where?: ProductUnitWhereInput
    orderBy?: ProductUnitOrderByWithRelationInput | ProductUnitOrderByWithRelationInput[]
    cursor?: ProductUnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductUnitScalarFieldEnum | ProductUnitScalarFieldEnum[]
  }

  /**
   * ProductVariant without action
   */
  export type ProductVariantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
  }


  /**
   * Model ProductUnit
   */

  export type AggregateProductUnit = {
    _count: ProductUnitCountAggregateOutputType | null
    _min: ProductUnitMinAggregateOutputType | null
    _max: ProductUnitMaxAggregateOutputType | null
  }

  export type ProductUnitMinAggregateOutputType = {
    id: string | null
    variantId: string | null
    serialNumber: string | null
    status: $Enums.UnitStatus | null
    condition: $Enums.UnitCondition | null
    assignedOrderId: string | null
    purchaseDate: Date | null
    lastServiceDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductUnitMaxAggregateOutputType = {
    id: string | null
    variantId: string | null
    serialNumber: string | null
    status: $Enums.UnitStatus | null
    condition: $Enums.UnitCondition | null
    assignedOrderId: string | null
    purchaseDate: Date | null
    lastServiceDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductUnitCountAggregateOutputType = {
    id: number
    variantId: number
    serialNumber: number
    status: number
    condition: number
    assignedOrderId: number
    purchaseDate: number
    lastServiceDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductUnitMinAggregateInputType = {
    id?: true
    variantId?: true
    serialNumber?: true
    status?: true
    condition?: true
    assignedOrderId?: true
    purchaseDate?: true
    lastServiceDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductUnitMaxAggregateInputType = {
    id?: true
    variantId?: true
    serialNumber?: true
    status?: true
    condition?: true
    assignedOrderId?: true
    purchaseDate?: true
    lastServiceDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductUnitCountAggregateInputType = {
    id?: true
    variantId?: true
    serialNumber?: true
    status?: true
    condition?: true
    assignedOrderId?: true
    purchaseDate?: true
    lastServiceDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductUnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductUnit to aggregate.
     */
    where?: ProductUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductUnits to fetch.
     */
    orderBy?: ProductUnitOrderByWithRelationInput | ProductUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductUnits
    **/
    _count?: true | ProductUnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductUnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductUnitMaxAggregateInputType
  }

  export type GetProductUnitAggregateType<T extends ProductUnitAggregateArgs> = {
        [P in keyof T & keyof AggregateProductUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductUnit[P]>
      : GetScalarType<T[P], AggregateProductUnit[P]>
  }




  export type ProductUnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductUnitWhereInput
    orderBy?: ProductUnitOrderByWithAggregationInput | ProductUnitOrderByWithAggregationInput[]
    by: ProductUnitScalarFieldEnum[] | ProductUnitScalarFieldEnum
    having?: ProductUnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductUnitCountAggregateInputType | true
    _min?: ProductUnitMinAggregateInputType
    _max?: ProductUnitMaxAggregateInputType
  }

  export type ProductUnitGroupByOutputType = {
    id: string
    variantId: string
    serialNumber: string
    status: $Enums.UnitStatus
    condition: $Enums.UnitCondition
    assignedOrderId: string | null
    purchaseDate: Date | null
    lastServiceDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ProductUnitCountAggregateOutputType | null
    _min: ProductUnitMinAggregateOutputType | null
    _max: ProductUnitMaxAggregateOutputType | null
  }

  type GetProductUnitGroupByPayload<T extends ProductUnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductUnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductUnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductUnitGroupByOutputType[P]>
            : GetScalarType<T[P], ProductUnitGroupByOutputType[P]>
        }
      >
    >


  export type ProductUnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    variantId?: boolean
    serialNumber?: boolean
    status?: boolean
    condition?: boolean
    assignedOrderId?: boolean
    purchaseDate?: boolean
    lastServiceDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    assignedOrder?: boolean | ProductUnit$assignedOrderArgs<ExtArgs>
    rentalItems?: boolean | ProductUnit$rentalItemsArgs<ExtArgs>
    history?: boolean | ProductUnit$historyArgs<ExtArgs>
    _count?: boolean | ProductUnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productUnit"]>

  export type ProductUnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    variantId?: boolean
    serialNumber?: boolean
    status?: boolean
    condition?: boolean
    assignedOrderId?: boolean
    purchaseDate?: boolean
    lastServiceDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    assignedOrder?: boolean | ProductUnit$assignedOrderArgs<ExtArgs>
  }, ExtArgs["result"]["productUnit"]>

  export type ProductUnitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    variantId?: boolean
    serialNumber?: boolean
    status?: boolean
    condition?: boolean
    assignedOrderId?: boolean
    purchaseDate?: boolean
    lastServiceDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    assignedOrder?: boolean | ProductUnit$assignedOrderArgs<ExtArgs>
  }, ExtArgs["result"]["productUnit"]>

  export type ProductUnitSelectScalar = {
    id?: boolean
    variantId?: boolean
    serialNumber?: boolean
    status?: boolean
    condition?: boolean
    assignedOrderId?: boolean
    purchaseDate?: boolean
    lastServiceDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductUnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "variantId" | "serialNumber" | "status" | "condition" | "assignedOrderId" | "purchaseDate" | "lastServiceDate" | "createdAt" | "updatedAt", ExtArgs["result"]["productUnit"]>
  export type ProductUnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    assignedOrder?: boolean | ProductUnit$assignedOrderArgs<ExtArgs>
    rentalItems?: boolean | ProductUnit$rentalItemsArgs<ExtArgs>
    history?: boolean | ProductUnit$historyArgs<ExtArgs>
    _count?: boolean | ProductUnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductUnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    assignedOrder?: boolean | ProductUnit$assignedOrderArgs<ExtArgs>
  }
  export type ProductUnitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    assignedOrder?: boolean | ProductUnit$assignedOrderArgs<ExtArgs>
  }

  export type $ProductUnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductUnit"
    objects: {
      variant: Prisma.$ProductVariantPayload<ExtArgs>
      assignedOrder: Prisma.$OrderPayload<ExtArgs> | null
      rentalItems: Prisma.$RentalItemPayload<ExtArgs>[]
      history: Prisma.$UnitHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      variantId: string
      serialNumber: string
      status: $Enums.UnitStatus
      condition: $Enums.UnitCondition
      assignedOrderId: string | null
      purchaseDate: Date | null
      lastServiceDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productUnit"]>
    composites: {}
  }

  type ProductUnitGetPayload<S extends boolean | null | undefined | ProductUnitDefaultArgs> = $Result.GetResult<Prisma.$ProductUnitPayload, S>

  type ProductUnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductUnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductUnitCountAggregateInputType | true
    }

  export interface ProductUnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductUnit'], meta: { name: 'ProductUnit' } }
    /**
     * Find zero or one ProductUnit that matches the filter.
     * @param {ProductUnitFindUniqueArgs} args - Arguments to find a ProductUnit
     * @example
     * // Get one ProductUnit
     * const productUnit = await prisma.productUnit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductUnitFindUniqueArgs>(args: SelectSubset<T, ProductUnitFindUniqueArgs<ExtArgs>>): Prisma__ProductUnitClient<$Result.GetResult<Prisma.$ProductUnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductUnit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductUnitFindUniqueOrThrowArgs} args - Arguments to find a ProductUnit
     * @example
     * // Get one ProductUnit
     * const productUnit = await prisma.productUnit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductUnitFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductUnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductUnitClient<$Result.GetResult<Prisma.$ProductUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductUnit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUnitFindFirstArgs} args - Arguments to find a ProductUnit
     * @example
     * // Get one ProductUnit
     * const productUnit = await prisma.productUnit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductUnitFindFirstArgs>(args?: SelectSubset<T, ProductUnitFindFirstArgs<ExtArgs>>): Prisma__ProductUnitClient<$Result.GetResult<Prisma.$ProductUnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductUnit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUnitFindFirstOrThrowArgs} args - Arguments to find a ProductUnit
     * @example
     * // Get one ProductUnit
     * const productUnit = await prisma.productUnit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductUnitFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductUnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductUnitClient<$Result.GetResult<Prisma.$ProductUnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductUnits
     * const productUnits = await prisma.productUnit.findMany()
     * 
     * // Get first 10 ProductUnits
     * const productUnits = await prisma.productUnit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productUnitWithIdOnly = await prisma.productUnit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductUnitFindManyArgs>(args?: SelectSubset<T, ProductUnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductUnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductUnit.
     * @param {ProductUnitCreateArgs} args - Arguments to create a ProductUnit.
     * @example
     * // Create one ProductUnit
     * const ProductUnit = await prisma.productUnit.create({
     *   data: {
     *     // ... data to create a ProductUnit
     *   }
     * })
     * 
     */
    create<T extends ProductUnitCreateArgs>(args: SelectSubset<T, ProductUnitCreateArgs<ExtArgs>>): Prisma__ProductUnitClient<$Result.GetResult<Prisma.$ProductUnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductUnits.
     * @param {ProductUnitCreateManyArgs} args - Arguments to create many ProductUnits.
     * @example
     * // Create many ProductUnits
     * const productUnit = await prisma.productUnit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductUnitCreateManyArgs>(args?: SelectSubset<T, ProductUnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductUnits and returns the data saved in the database.
     * @param {ProductUnitCreateManyAndReturnArgs} args - Arguments to create many ProductUnits.
     * @example
     * // Create many ProductUnits
     * const productUnit = await prisma.productUnit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductUnits and only return the `id`
     * const productUnitWithIdOnly = await prisma.productUnit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductUnitCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductUnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductUnitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductUnit.
     * @param {ProductUnitDeleteArgs} args - Arguments to delete one ProductUnit.
     * @example
     * // Delete one ProductUnit
     * const ProductUnit = await prisma.productUnit.delete({
     *   where: {
     *     // ... filter to delete one ProductUnit
     *   }
     * })
     * 
     */
    delete<T extends ProductUnitDeleteArgs>(args: SelectSubset<T, ProductUnitDeleteArgs<ExtArgs>>): Prisma__ProductUnitClient<$Result.GetResult<Prisma.$ProductUnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductUnit.
     * @param {ProductUnitUpdateArgs} args - Arguments to update one ProductUnit.
     * @example
     * // Update one ProductUnit
     * const productUnit = await prisma.productUnit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUnitUpdateArgs>(args: SelectSubset<T, ProductUnitUpdateArgs<ExtArgs>>): Prisma__ProductUnitClient<$Result.GetResult<Prisma.$ProductUnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductUnits.
     * @param {ProductUnitDeleteManyArgs} args - Arguments to filter ProductUnits to delete.
     * @example
     * // Delete a few ProductUnits
     * const { count } = await prisma.productUnit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductUnitDeleteManyArgs>(args?: SelectSubset<T, ProductUnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductUnits
     * const productUnit = await prisma.productUnit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUnitUpdateManyArgs>(args: SelectSubset<T, ProductUnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductUnits and returns the data updated in the database.
     * @param {ProductUnitUpdateManyAndReturnArgs} args - Arguments to update many ProductUnits.
     * @example
     * // Update many ProductUnits
     * const productUnit = await prisma.productUnit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductUnits and only return the `id`
     * const productUnitWithIdOnly = await prisma.productUnit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUnitUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUnitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductUnitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductUnit.
     * @param {ProductUnitUpsertArgs} args - Arguments to update or create a ProductUnit.
     * @example
     * // Update or create a ProductUnit
     * const productUnit = await prisma.productUnit.upsert({
     *   create: {
     *     // ... data to create a ProductUnit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductUnit we want to update
     *   }
     * })
     */
    upsert<T extends ProductUnitUpsertArgs>(args: SelectSubset<T, ProductUnitUpsertArgs<ExtArgs>>): Prisma__ProductUnitClient<$Result.GetResult<Prisma.$ProductUnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUnitCountArgs} args - Arguments to filter ProductUnits to count.
     * @example
     * // Count the number of ProductUnits
     * const count = await prisma.productUnit.count({
     *   where: {
     *     // ... the filter for the ProductUnits we want to count
     *   }
     * })
    **/
    count<T extends ProductUnitCountArgs>(
      args?: Subset<T, ProductUnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductUnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductUnitAggregateArgs>(args: Subset<T, ProductUnitAggregateArgs>): Prisma.PrismaPromise<GetProductUnitAggregateType<T>>

    /**
     * Group by ProductUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductUnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductUnitGroupByArgs['orderBy'] }
        : { orderBy?: ProductUnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductUnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductUnit model
   */
  readonly fields: ProductUnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductUnit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductUnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variant<T extends ProductVariantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariantDefaultArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedOrder<T extends ProductUnit$assignedOrderArgs<ExtArgs> = {}>(args?: Subset<T, ProductUnit$assignedOrderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    rentalItems<T extends ProductUnit$rentalItemsArgs<ExtArgs> = {}>(args?: Subset<T, ProductUnit$rentalItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    history<T extends ProductUnit$historyArgs<ExtArgs> = {}>(args?: Subset<T, ProductUnit$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductUnit model
   */
  interface ProductUnitFieldRefs {
    readonly id: FieldRef<"ProductUnit", 'String'>
    readonly variantId: FieldRef<"ProductUnit", 'String'>
    readonly serialNumber: FieldRef<"ProductUnit", 'String'>
    readonly status: FieldRef<"ProductUnit", 'UnitStatus'>
    readonly condition: FieldRef<"ProductUnit", 'UnitCondition'>
    readonly assignedOrderId: FieldRef<"ProductUnit", 'String'>
    readonly purchaseDate: FieldRef<"ProductUnit", 'DateTime'>
    readonly lastServiceDate: FieldRef<"ProductUnit", 'DateTime'>
    readonly createdAt: FieldRef<"ProductUnit", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductUnit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductUnit findUnique
   */
  export type ProductUnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductUnit
     */
    select?: ProductUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductUnit
     */
    omit?: ProductUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductUnitInclude<ExtArgs> | null
    /**
     * Filter, which ProductUnit to fetch.
     */
    where: ProductUnitWhereUniqueInput
  }

  /**
   * ProductUnit findUniqueOrThrow
   */
  export type ProductUnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductUnit
     */
    select?: ProductUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductUnit
     */
    omit?: ProductUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductUnitInclude<ExtArgs> | null
    /**
     * Filter, which ProductUnit to fetch.
     */
    where: ProductUnitWhereUniqueInput
  }

  /**
   * ProductUnit findFirst
   */
  export type ProductUnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductUnit
     */
    select?: ProductUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductUnit
     */
    omit?: ProductUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductUnitInclude<ExtArgs> | null
    /**
     * Filter, which ProductUnit to fetch.
     */
    where?: ProductUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductUnits to fetch.
     */
    orderBy?: ProductUnitOrderByWithRelationInput | ProductUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductUnits.
     */
    cursor?: ProductUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductUnits.
     */
    distinct?: ProductUnitScalarFieldEnum | ProductUnitScalarFieldEnum[]
  }

  /**
   * ProductUnit findFirstOrThrow
   */
  export type ProductUnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductUnit
     */
    select?: ProductUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductUnit
     */
    omit?: ProductUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductUnitInclude<ExtArgs> | null
    /**
     * Filter, which ProductUnit to fetch.
     */
    where?: ProductUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductUnits to fetch.
     */
    orderBy?: ProductUnitOrderByWithRelationInput | ProductUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductUnits.
     */
    cursor?: ProductUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductUnits.
     */
    distinct?: ProductUnitScalarFieldEnum | ProductUnitScalarFieldEnum[]
  }

  /**
   * ProductUnit findMany
   */
  export type ProductUnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductUnit
     */
    select?: ProductUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductUnit
     */
    omit?: ProductUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductUnitInclude<ExtArgs> | null
    /**
     * Filter, which ProductUnits to fetch.
     */
    where?: ProductUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductUnits to fetch.
     */
    orderBy?: ProductUnitOrderByWithRelationInput | ProductUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductUnits.
     */
    cursor?: ProductUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductUnits.
     */
    skip?: number
    distinct?: ProductUnitScalarFieldEnum | ProductUnitScalarFieldEnum[]
  }

  /**
   * ProductUnit create
   */
  export type ProductUnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductUnit
     */
    select?: ProductUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductUnit
     */
    omit?: ProductUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductUnitInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductUnit.
     */
    data: XOR<ProductUnitCreateInput, ProductUnitUncheckedCreateInput>
  }

  /**
   * ProductUnit createMany
   */
  export type ProductUnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductUnits.
     */
    data: ProductUnitCreateManyInput | ProductUnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductUnit createManyAndReturn
   */
  export type ProductUnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductUnit
     */
    select?: ProductUnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductUnit
     */
    omit?: ProductUnitOmit<ExtArgs> | null
    /**
     * The data used to create many ProductUnits.
     */
    data: ProductUnitCreateManyInput | ProductUnitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductUnitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductUnit update
   */
  export type ProductUnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductUnit
     */
    select?: ProductUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductUnit
     */
    omit?: ProductUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductUnitInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductUnit.
     */
    data: XOR<ProductUnitUpdateInput, ProductUnitUncheckedUpdateInput>
    /**
     * Choose, which ProductUnit to update.
     */
    where: ProductUnitWhereUniqueInput
  }

  /**
   * ProductUnit updateMany
   */
  export type ProductUnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductUnits.
     */
    data: XOR<ProductUnitUpdateManyMutationInput, ProductUnitUncheckedUpdateManyInput>
    /**
     * Filter which ProductUnits to update
     */
    where?: ProductUnitWhereInput
    /**
     * Limit how many ProductUnits to update.
     */
    limit?: number
  }

  /**
   * ProductUnit updateManyAndReturn
   */
  export type ProductUnitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductUnit
     */
    select?: ProductUnitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductUnit
     */
    omit?: ProductUnitOmit<ExtArgs> | null
    /**
     * The data used to update ProductUnits.
     */
    data: XOR<ProductUnitUpdateManyMutationInput, ProductUnitUncheckedUpdateManyInput>
    /**
     * Filter which ProductUnits to update
     */
    where?: ProductUnitWhereInput
    /**
     * Limit how many ProductUnits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductUnitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductUnit upsert
   */
  export type ProductUnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductUnit
     */
    select?: ProductUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductUnit
     */
    omit?: ProductUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductUnitInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductUnit to update in case it exists.
     */
    where: ProductUnitWhereUniqueInput
    /**
     * In case the ProductUnit found by the `where` argument doesn't exist, create a new ProductUnit with this data.
     */
    create: XOR<ProductUnitCreateInput, ProductUnitUncheckedCreateInput>
    /**
     * In case the ProductUnit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUnitUpdateInput, ProductUnitUncheckedUpdateInput>
  }

  /**
   * ProductUnit delete
   */
  export type ProductUnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductUnit
     */
    select?: ProductUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductUnit
     */
    omit?: ProductUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductUnitInclude<ExtArgs> | null
    /**
     * Filter which ProductUnit to delete.
     */
    where: ProductUnitWhereUniqueInput
  }

  /**
   * ProductUnit deleteMany
   */
  export type ProductUnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductUnits to delete
     */
    where?: ProductUnitWhereInput
    /**
     * Limit how many ProductUnits to delete.
     */
    limit?: number
  }

  /**
   * ProductUnit.assignedOrder
   */
  export type ProductUnit$assignedOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * ProductUnit.rentalItems
   */
  export type ProductUnit$rentalItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalItem
     */
    select?: RentalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalItem
     */
    omit?: RentalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalItemInclude<ExtArgs> | null
    where?: RentalItemWhereInput
    orderBy?: RentalItemOrderByWithRelationInput | RentalItemOrderByWithRelationInput[]
    cursor?: RentalItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RentalItemScalarFieldEnum | RentalItemScalarFieldEnum[]
  }

  /**
   * ProductUnit.history
   */
  export type ProductUnit$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitHistory
     */
    select?: UnitHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitHistory
     */
    omit?: UnitHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitHistoryInclude<ExtArgs> | null
    where?: UnitHistoryWhereInput
    orderBy?: UnitHistoryOrderByWithRelationInput | UnitHistoryOrderByWithRelationInput[]
    cursor?: UnitHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitHistoryScalarFieldEnum | UnitHistoryScalarFieldEnum[]
  }

  /**
   * ProductUnit without action
   */
  export type ProductUnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductUnit
     */
    select?: ProductUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductUnit
     */
    omit?: ProductUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductUnitInclude<ExtArgs> | null
  }


  /**
   * Model UnitHistory
   */

  export type AggregateUnitHistory = {
    _count: UnitHistoryCountAggregateOutputType | null
    _min: UnitHistoryMinAggregateOutputType | null
    _max: UnitHistoryMaxAggregateOutputType | null
  }

  export type UnitHistoryMinAggregateOutputType = {
    id: string | null
    unitId: string | null
    oldStatus: string | null
    newStatus: string | null
    oldCondition: string | null
    newCondition: string | null
    details: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type UnitHistoryMaxAggregateOutputType = {
    id: string | null
    unitId: string | null
    oldStatus: string | null
    newStatus: string | null
    oldCondition: string | null
    newCondition: string | null
    details: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type UnitHistoryCountAggregateOutputType = {
    id: number
    unitId: number
    oldStatus: number
    newStatus: number
    oldCondition: number
    newCondition: number
    details: number
    createdAt: number
    userId: number
    _all: number
  }


  export type UnitHistoryMinAggregateInputType = {
    id?: true
    unitId?: true
    oldStatus?: true
    newStatus?: true
    oldCondition?: true
    newCondition?: true
    details?: true
    createdAt?: true
    userId?: true
  }

  export type UnitHistoryMaxAggregateInputType = {
    id?: true
    unitId?: true
    oldStatus?: true
    newStatus?: true
    oldCondition?: true
    newCondition?: true
    details?: true
    createdAt?: true
    userId?: true
  }

  export type UnitHistoryCountAggregateInputType = {
    id?: true
    unitId?: true
    oldStatus?: true
    newStatus?: true
    oldCondition?: true
    newCondition?: true
    details?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type UnitHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitHistory to aggregate.
     */
    where?: UnitHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitHistories to fetch.
     */
    orderBy?: UnitHistoryOrderByWithRelationInput | UnitHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitHistories
    **/
    _count?: true | UnitHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitHistoryMaxAggregateInputType
  }

  export type GetUnitHistoryAggregateType<T extends UnitHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitHistory[P]>
      : GetScalarType<T[P], AggregateUnitHistory[P]>
  }




  export type UnitHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitHistoryWhereInput
    orderBy?: UnitHistoryOrderByWithAggregationInput | UnitHistoryOrderByWithAggregationInput[]
    by: UnitHistoryScalarFieldEnum[] | UnitHistoryScalarFieldEnum
    having?: UnitHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitHistoryCountAggregateInputType | true
    _min?: UnitHistoryMinAggregateInputType
    _max?: UnitHistoryMaxAggregateInputType
  }

  export type UnitHistoryGroupByOutputType = {
    id: string
    unitId: string
    oldStatus: string | null
    newStatus: string
    oldCondition: string | null
    newCondition: string | null
    details: string | null
    createdAt: Date
    userId: string | null
    _count: UnitHistoryCountAggregateOutputType | null
    _min: UnitHistoryMinAggregateOutputType | null
    _max: UnitHistoryMaxAggregateOutputType | null
  }

  type GetUnitHistoryGroupByPayload<T extends UnitHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], UnitHistoryGroupByOutputType[P]>
        }
      >
    >


  export type UnitHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    oldStatus?: boolean
    newStatus?: boolean
    oldCondition?: boolean
    newCondition?: boolean
    details?: boolean
    createdAt?: boolean
    userId?: boolean
    unit?: boolean | ProductUnitDefaultArgs<ExtArgs>
    user?: boolean | UnitHistory$userArgs<ExtArgs>
  }, ExtArgs["result"]["unitHistory"]>

  export type UnitHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    oldStatus?: boolean
    newStatus?: boolean
    oldCondition?: boolean
    newCondition?: boolean
    details?: boolean
    createdAt?: boolean
    userId?: boolean
    unit?: boolean | ProductUnitDefaultArgs<ExtArgs>
    user?: boolean | UnitHistory$userArgs<ExtArgs>
  }, ExtArgs["result"]["unitHistory"]>

  export type UnitHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    oldStatus?: boolean
    newStatus?: boolean
    oldCondition?: boolean
    newCondition?: boolean
    details?: boolean
    createdAt?: boolean
    userId?: boolean
    unit?: boolean | ProductUnitDefaultArgs<ExtArgs>
    user?: boolean | UnitHistory$userArgs<ExtArgs>
  }, ExtArgs["result"]["unitHistory"]>

  export type UnitHistorySelectScalar = {
    id?: boolean
    unitId?: boolean
    oldStatus?: boolean
    newStatus?: boolean
    oldCondition?: boolean
    newCondition?: boolean
    details?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type UnitHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unitId" | "oldStatus" | "newStatus" | "oldCondition" | "newCondition" | "details" | "createdAt" | "userId", ExtArgs["result"]["unitHistory"]>
  export type UnitHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | ProductUnitDefaultArgs<ExtArgs>
    user?: boolean | UnitHistory$userArgs<ExtArgs>
  }
  export type UnitHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | ProductUnitDefaultArgs<ExtArgs>
    user?: boolean | UnitHistory$userArgs<ExtArgs>
  }
  export type UnitHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | ProductUnitDefaultArgs<ExtArgs>
    user?: boolean | UnitHistory$userArgs<ExtArgs>
  }

  export type $UnitHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitHistory"
    objects: {
      unit: Prisma.$ProductUnitPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unitId: string
      oldStatus: string | null
      newStatus: string
      oldCondition: string | null
      newCondition: string | null
      details: string | null
      createdAt: Date
      userId: string | null
    }, ExtArgs["result"]["unitHistory"]>
    composites: {}
  }

  type UnitHistoryGetPayload<S extends boolean | null | undefined | UnitHistoryDefaultArgs> = $Result.GetResult<Prisma.$UnitHistoryPayload, S>

  type UnitHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitHistoryCountAggregateInputType | true
    }

  export interface UnitHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitHistory'], meta: { name: 'UnitHistory' } }
    /**
     * Find zero or one UnitHistory that matches the filter.
     * @param {UnitHistoryFindUniqueArgs} args - Arguments to find a UnitHistory
     * @example
     * // Get one UnitHistory
     * const unitHistory = await prisma.unitHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitHistoryFindUniqueArgs>(args: SelectSubset<T, UnitHistoryFindUniqueArgs<ExtArgs>>): Prisma__UnitHistoryClient<$Result.GetResult<Prisma.$UnitHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitHistoryFindUniqueOrThrowArgs} args - Arguments to find a UnitHistory
     * @example
     * // Get one UnitHistory
     * const unitHistory = await prisma.unitHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitHistoryClient<$Result.GetResult<Prisma.$UnitHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitHistoryFindFirstArgs} args - Arguments to find a UnitHistory
     * @example
     * // Get one UnitHistory
     * const unitHistory = await prisma.unitHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitHistoryFindFirstArgs>(args?: SelectSubset<T, UnitHistoryFindFirstArgs<ExtArgs>>): Prisma__UnitHistoryClient<$Result.GetResult<Prisma.$UnitHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitHistoryFindFirstOrThrowArgs} args - Arguments to find a UnitHistory
     * @example
     * // Get one UnitHistory
     * const unitHistory = await prisma.unitHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitHistoryClient<$Result.GetResult<Prisma.$UnitHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitHistories
     * const unitHistories = await prisma.unitHistory.findMany()
     * 
     * // Get first 10 UnitHistories
     * const unitHistories = await prisma.unitHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitHistoryWithIdOnly = await prisma.unitHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitHistoryFindManyArgs>(args?: SelectSubset<T, UnitHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitHistory.
     * @param {UnitHistoryCreateArgs} args - Arguments to create a UnitHistory.
     * @example
     * // Create one UnitHistory
     * const UnitHistory = await prisma.unitHistory.create({
     *   data: {
     *     // ... data to create a UnitHistory
     *   }
     * })
     * 
     */
    create<T extends UnitHistoryCreateArgs>(args: SelectSubset<T, UnitHistoryCreateArgs<ExtArgs>>): Prisma__UnitHistoryClient<$Result.GetResult<Prisma.$UnitHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitHistories.
     * @param {UnitHistoryCreateManyArgs} args - Arguments to create many UnitHistories.
     * @example
     * // Create many UnitHistories
     * const unitHistory = await prisma.unitHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitHistoryCreateManyArgs>(args?: SelectSubset<T, UnitHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitHistories and returns the data saved in the database.
     * @param {UnitHistoryCreateManyAndReturnArgs} args - Arguments to create many UnitHistories.
     * @example
     * // Create many UnitHistories
     * const unitHistory = await prisma.unitHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitHistories and only return the `id`
     * const unitHistoryWithIdOnly = await prisma.unitHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnitHistory.
     * @param {UnitHistoryDeleteArgs} args - Arguments to delete one UnitHistory.
     * @example
     * // Delete one UnitHistory
     * const UnitHistory = await prisma.unitHistory.delete({
     *   where: {
     *     // ... filter to delete one UnitHistory
     *   }
     * })
     * 
     */
    delete<T extends UnitHistoryDeleteArgs>(args: SelectSubset<T, UnitHistoryDeleteArgs<ExtArgs>>): Prisma__UnitHistoryClient<$Result.GetResult<Prisma.$UnitHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitHistory.
     * @param {UnitHistoryUpdateArgs} args - Arguments to update one UnitHistory.
     * @example
     * // Update one UnitHistory
     * const unitHistory = await prisma.unitHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitHistoryUpdateArgs>(args: SelectSubset<T, UnitHistoryUpdateArgs<ExtArgs>>): Prisma__UnitHistoryClient<$Result.GetResult<Prisma.$UnitHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitHistories.
     * @param {UnitHistoryDeleteManyArgs} args - Arguments to filter UnitHistories to delete.
     * @example
     * // Delete a few UnitHistories
     * const { count } = await prisma.unitHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitHistoryDeleteManyArgs>(args?: SelectSubset<T, UnitHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitHistories
     * const unitHistory = await prisma.unitHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitHistoryUpdateManyArgs>(args: SelectSubset<T, UnitHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitHistories and returns the data updated in the database.
     * @param {UnitHistoryUpdateManyAndReturnArgs} args - Arguments to update many UnitHistories.
     * @example
     * // Update many UnitHistories
     * const unitHistory = await prisma.unitHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnitHistories and only return the `id`
     * const unitHistoryWithIdOnly = await prisma.unitHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnitHistory.
     * @param {UnitHistoryUpsertArgs} args - Arguments to update or create a UnitHistory.
     * @example
     * // Update or create a UnitHistory
     * const unitHistory = await prisma.unitHistory.upsert({
     *   create: {
     *     // ... data to create a UnitHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitHistory we want to update
     *   }
     * })
     */
    upsert<T extends UnitHistoryUpsertArgs>(args: SelectSubset<T, UnitHistoryUpsertArgs<ExtArgs>>): Prisma__UnitHistoryClient<$Result.GetResult<Prisma.$UnitHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitHistoryCountArgs} args - Arguments to filter UnitHistories to count.
     * @example
     * // Count the number of UnitHistories
     * const count = await prisma.unitHistory.count({
     *   where: {
     *     // ... the filter for the UnitHistories we want to count
     *   }
     * })
    **/
    count<T extends UnitHistoryCountArgs>(
      args?: Subset<T, UnitHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitHistoryAggregateArgs>(args: Subset<T, UnitHistoryAggregateArgs>): Prisma.PrismaPromise<GetUnitHistoryAggregateType<T>>

    /**
     * Group by UnitHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitHistoryGroupByArgs['orderBy'] }
        : { orderBy?: UnitHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitHistory model
   */
  readonly fields: UnitHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends ProductUnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductUnitDefaultArgs<ExtArgs>>): Prisma__ProductUnitClient<$Result.GetResult<Prisma.$ProductUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UnitHistory$userArgs<ExtArgs> = {}>(args?: Subset<T, UnitHistory$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitHistory model
   */
  interface UnitHistoryFieldRefs {
    readonly id: FieldRef<"UnitHistory", 'String'>
    readonly unitId: FieldRef<"UnitHistory", 'String'>
    readonly oldStatus: FieldRef<"UnitHistory", 'String'>
    readonly newStatus: FieldRef<"UnitHistory", 'String'>
    readonly oldCondition: FieldRef<"UnitHistory", 'String'>
    readonly newCondition: FieldRef<"UnitHistory", 'String'>
    readonly details: FieldRef<"UnitHistory", 'String'>
    readonly createdAt: FieldRef<"UnitHistory", 'DateTime'>
    readonly userId: FieldRef<"UnitHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UnitHistory findUnique
   */
  export type UnitHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitHistory
     */
    select?: UnitHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitHistory
     */
    omit?: UnitHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UnitHistory to fetch.
     */
    where: UnitHistoryWhereUniqueInput
  }

  /**
   * UnitHistory findUniqueOrThrow
   */
  export type UnitHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitHistory
     */
    select?: UnitHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitHistory
     */
    omit?: UnitHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UnitHistory to fetch.
     */
    where: UnitHistoryWhereUniqueInput
  }

  /**
   * UnitHistory findFirst
   */
  export type UnitHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitHistory
     */
    select?: UnitHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitHistory
     */
    omit?: UnitHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UnitHistory to fetch.
     */
    where?: UnitHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitHistories to fetch.
     */
    orderBy?: UnitHistoryOrderByWithRelationInput | UnitHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitHistories.
     */
    cursor?: UnitHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitHistories.
     */
    distinct?: UnitHistoryScalarFieldEnum | UnitHistoryScalarFieldEnum[]
  }

  /**
   * UnitHistory findFirstOrThrow
   */
  export type UnitHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitHistory
     */
    select?: UnitHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitHistory
     */
    omit?: UnitHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UnitHistory to fetch.
     */
    where?: UnitHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitHistories to fetch.
     */
    orderBy?: UnitHistoryOrderByWithRelationInput | UnitHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitHistories.
     */
    cursor?: UnitHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitHistories.
     */
    distinct?: UnitHistoryScalarFieldEnum | UnitHistoryScalarFieldEnum[]
  }

  /**
   * UnitHistory findMany
   */
  export type UnitHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitHistory
     */
    select?: UnitHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitHistory
     */
    omit?: UnitHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UnitHistories to fetch.
     */
    where?: UnitHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitHistories to fetch.
     */
    orderBy?: UnitHistoryOrderByWithRelationInput | UnitHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitHistories.
     */
    cursor?: UnitHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitHistories.
     */
    skip?: number
    distinct?: UnitHistoryScalarFieldEnum | UnitHistoryScalarFieldEnum[]
  }

  /**
   * UnitHistory create
   */
  export type UnitHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitHistory
     */
    select?: UnitHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitHistory
     */
    omit?: UnitHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitHistory.
     */
    data: XOR<UnitHistoryCreateInput, UnitHistoryUncheckedCreateInput>
  }

  /**
   * UnitHistory createMany
   */
  export type UnitHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitHistories.
     */
    data: UnitHistoryCreateManyInput | UnitHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitHistory createManyAndReturn
   */
  export type UnitHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitHistory
     */
    select?: UnitHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitHistory
     */
    omit?: UnitHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many UnitHistories.
     */
    data: UnitHistoryCreateManyInput | UnitHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitHistory update
   */
  export type UnitHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitHistory
     */
    select?: UnitHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitHistory
     */
    omit?: UnitHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitHistory.
     */
    data: XOR<UnitHistoryUpdateInput, UnitHistoryUncheckedUpdateInput>
    /**
     * Choose, which UnitHistory to update.
     */
    where: UnitHistoryWhereUniqueInput
  }

  /**
   * UnitHistory updateMany
   */
  export type UnitHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitHistories.
     */
    data: XOR<UnitHistoryUpdateManyMutationInput, UnitHistoryUncheckedUpdateManyInput>
    /**
     * Filter which UnitHistories to update
     */
    where?: UnitHistoryWhereInput
    /**
     * Limit how many UnitHistories to update.
     */
    limit?: number
  }

  /**
   * UnitHistory updateManyAndReturn
   */
  export type UnitHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitHistory
     */
    select?: UnitHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitHistory
     */
    omit?: UnitHistoryOmit<ExtArgs> | null
    /**
     * The data used to update UnitHistories.
     */
    data: XOR<UnitHistoryUpdateManyMutationInput, UnitHistoryUncheckedUpdateManyInput>
    /**
     * Filter which UnitHistories to update
     */
    where?: UnitHistoryWhereInput
    /**
     * Limit how many UnitHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitHistory upsert
   */
  export type UnitHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitHistory
     */
    select?: UnitHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitHistory
     */
    omit?: UnitHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitHistory to update in case it exists.
     */
    where: UnitHistoryWhereUniqueInput
    /**
     * In case the UnitHistory found by the `where` argument doesn't exist, create a new UnitHistory with this data.
     */
    create: XOR<UnitHistoryCreateInput, UnitHistoryUncheckedCreateInput>
    /**
     * In case the UnitHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitHistoryUpdateInput, UnitHistoryUncheckedUpdateInput>
  }

  /**
   * UnitHistory delete
   */
  export type UnitHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitHistory
     */
    select?: UnitHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitHistory
     */
    omit?: UnitHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitHistoryInclude<ExtArgs> | null
    /**
     * Filter which UnitHistory to delete.
     */
    where: UnitHistoryWhereUniqueInput
  }

  /**
   * UnitHistory deleteMany
   */
  export type UnitHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitHistories to delete
     */
    where?: UnitHistoryWhereInput
    /**
     * Limit how many UnitHistories to delete.
     */
    limit?: number
  }

  /**
   * UnitHistory.user
   */
  export type UnitHistory$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * UnitHistory without action
   */
  export type UnitHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitHistory
     */
    select?: UnitHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitHistory
     */
    omit?: UnitHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitHistoryInclude<ExtArgs> | null
  }


  /**
   * Model SystemNotification
   */

  export type AggregateSystemNotification = {
    _count: SystemNotificationCountAggregateOutputType | null
    _min: SystemNotificationMinAggregateOutputType | null
    _max: SystemNotificationMaxAggregateOutputType | null
  }

  export type SystemNotificationMinAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    message: string | null
    isRead: boolean | null
    userId: string | null
    entityId: string | null
    entityType: string | null
    relatedType: string | null
    createdAt: Date | null
  }

  export type SystemNotificationMaxAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    message: string | null
    isRead: boolean | null
    userId: string | null
    entityId: string | null
    entityType: string | null
    relatedType: string | null
    createdAt: Date | null
  }

  export type SystemNotificationCountAggregateOutputType = {
    id: number
    type: number
    title: number
    message: number
    isRead: number
    userId: number
    entityId: number
    entityType: number
    relatedType: number
    createdAt: number
    _all: number
  }


  export type SystemNotificationMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    userId?: true
    entityId?: true
    entityType?: true
    relatedType?: true
    createdAt?: true
  }

  export type SystemNotificationMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    userId?: true
    entityId?: true
    entityType?: true
    relatedType?: true
    createdAt?: true
  }

  export type SystemNotificationCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    userId?: true
    entityId?: true
    entityType?: true
    relatedType?: true
    createdAt?: true
    _all?: true
  }

  export type SystemNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemNotification to aggregate.
     */
    where?: SystemNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemNotifications to fetch.
     */
    orderBy?: SystemNotificationOrderByWithRelationInput | SystemNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemNotifications
    **/
    _count?: true | SystemNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemNotificationMaxAggregateInputType
  }

  export type GetSystemNotificationAggregateType<T extends SystemNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemNotification[P]>
      : GetScalarType<T[P], AggregateSystemNotification[P]>
  }




  export type SystemNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemNotificationWhereInput
    orderBy?: SystemNotificationOrderByWithAggregationInput | SystemNotificationOrderByWithAggregationInput[]
    by: SystemNotificationScalarFieldEnum[] | SystemNotificationScalarFieldEnum
    having?: SystemNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemNotificationCountAggregateInputType | true
    _min?: SystemNotificationMinAggregateInputType
    _max?: SystemNotificationMaxAggregateInputType
  }

  export type SystemNotificationGroupByOutputType = {
    id: string
    type: string
    title: string
    message: string
    isRead: boolean
    userId: string | null
    entityId: string | null
    entityType: string | null
    relatedType: string | null
    createdAt: Date | null
    _count: SystemNotificationCountAggregateOutputType | null
    _min: SystemNotificationMinAggregateOutputType | null
    _max: SystemNotificationMaxAggregateOutputType | null
  }

  type GetSystemNotificationGroupByPayload<T extends SystemNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], SystemNotificationGroupByOutputType[P]>
        }
      >
    >


  export type SystemNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    userId?: boolean
    entityId?: boolean
    entityType?: boolean
    relatedType?: boolean
    createdAt?: boolean
    user?: boolean | SystemNotification$userArgs<ExtArgs>
  }, ExtArgs["result"]["systemNotification"]>

  export type SystemNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    userId?: boolean
    entityId?: boolean
    entityType?: boolean
    relatedType?: boolean
    createdAt?: boolean
    user?: boolean | SystemNotification$userArgs<ExtArgs>
  }, ExtArgs["result"]["systemNotification"]>

  export type SystemNotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    userId?: boolean
    entityId?: boolean
    entityType?: boolean
    relatedType?: boolean
    createdAt?: boolean
    user?: boolean | SystemNotification$userArgs<ExtArgs>
  }, ExtArgs["result"]["systemNotification"]>

  export type SystemNotificationSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    userId?: boolean
    entityId?: boolean
    entityType?: boolean
    relatedType?: boolean
    createdAt?: boolean
  }

  export type SystemNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "title" | "message" | "isRead" | "userId" | "entityId" | "entityType" | "relatedType" | "createdAt", ExtArgs["result"]["systemNotification"]>
  export type SystemNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SystemNotification$userArgs<ExtArgs>
  }
  export type SystemNotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SystemNotification$userArgs<ExtArgs>
  }
  export type SystemNotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SystemNotification$userArgs<ExtArgs>
  }

  export type $SystemNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemNotification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      title: string
      message: string
      isRead: boolean
      userId: string | null
      entityId: string | null
      entityType: string | null
      relatedType: string | null
      createdAt: Date | null
    }, ExtArgs["result"]["systemNotification"]>
    composites: {}
  }

  type SystemNotificationGetPayload<S extends boolean | null | undefined | SystemNotificationDefaultArgs> = $Result.GetResult<Prisma.$SystemNotificationPayload, S>

  type SystemNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemNotificationCountAggregateInputType | true
    }

  export interface SystemNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemNotification'], meta: { name: 'SystemNotification' } }
    /**
     * Find zero or one SystemNotification that matches the filter.
     * @param {SystemNotificationFindUniqueArgs} args - Arguments to find a SystemNotification
     * @example
     * // Get one SystemNotification
     * const systemNotification = await prisma.systemNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemNotificationFindUniqueArgs>(args: SelectSubset<T, SystemNotificationFindUniqueArgs<ExtArgs>>): Prisma__SystemNotificationClient<$Result.GetResult<Prisma.$SystemNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemNotificationFindUniqueOrThrowArgs} args - Arguments to find a SystemNotification
     * @example
     * // Get one SystemNotification
     * const systemNotification = await prisma.systemNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemNotificationClient<$Result.GetResult<Prisma.$SystemNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemNotificationFindFirstArgs} args - Arguments to find a SystemNotification
     * @example
     * // Get one SystemNotification
     * const systemNotification = await prisma.systemNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemNotificationFindFirstArgs>(args?: SelectSubset<T, SystemNotificationFindFirstArgs<ExtArgs>>): Prisma__SystemNotificationClient<$Result.GetResult<Prisma.$SystemNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemNotificationFindFirstOrThrowArgs} args - Arguments to find a SystemNotification
     * @example
     * // Get one SystemNotification
     * const systemNotification = await prisma.systemNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemNotificationClient<$Result.GetResult<Prisma.$SystemNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemNotifications
     * const systemNotifications = await prisma.systemNotification.findMany()
     * 
     * // Get first 10 SystemNotifications
     * const systemNotifications = await prisma.systemNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemNotificationWithIdOnly = await prisma.systemNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemNotificationFindManyArgs>(args?: SelectSubset<T, SystemNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemNotification.
     * @param {SystemNotificationCreateArgs} args - Arguments to create a SystemNotification.
     * @example
     * // Create one SystemNotification
     * const SystemNotification = await prisma.systemNotification.create({
     *   data: {
     *     // ... data to create a SystemNotification
     *   }
     * })
     * 
     */
    create<T extends SystemNotificationCreateArgs>(args: SelectSubset<T, SystemNotificationCreateArgs<ExtArgs>>): Prisma__SystemNotificationClient<$Result.GetResult<Prisma.$SystemNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemNotifications.
     * @param {SystemNotificationCreateManyArgs} args - Arguments to create many SystemNotifications.
     * @example
     * // Create many SystemNotifications
     * const systemNotification = await prisma.systemNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemNotificationCreateManyArgs>(args?: SelectSubset<T, SystemNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemNotifications and returns the data saved in the database.
     * @param {SystemNotificationCreateManyAndReturnArgs} args - Arguments to create many SystemNotifications.
     * @example
     * // Create many SystemNotifications
     * const systemNotification = await prisma.systemNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemNotifications and only return the `id`
     * const systemNotificationWithIdOnly = await prisma.systemNotification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemNotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemNotification.
     * @param {SystemNotificationDeleteArgs} args - Arguments to delete one SystemNotification.
     * @example
     * // Delete one SystemNotification
     * const SystemNotification = await prisma.systemNotification.delete({
     *   where: {
     *     // ... filter to delete one SystemNotification
     *   }
     * })
     * 
     */
    delete<T extends SystemNotificationDeleteArgs>(args: SelectSubset<T, SystemNotificationDeleteArgs<ExtArgs>>): Prisma__SystemNotificationClient<$Result.GetResult<Prisma.$SystemNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemNotification.
     * @param {SystemNotificationUpdateArgs} args - Arguments to update one SystemNotification.
     * @example
     * // Update one SystemNotification
     * const systemNotification = await prisma.systemNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemNotificationUpdateArgs>(args: SelectSubset<T, SystemNotificationUpdateArgs<ExtArgs>>): Prisma__SystemNotificationClient<$Result.GetResult<Prisma.$SystemNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemNotifications.
     * @param {SystemNotificationDeleteManyArgs} args - Arguments to filter SystemNotifications to delete.
     * @example
     * // Delete a few SystemNotifications
     * const { count } = await prisma.systemNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemNotificationDeleteManyArgs>(args?: SelectSubset<T, SystemNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemNotifications
     * const systemNotification = await prisma.systemNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemNotificationUpdateManyArgs>(args: SelectSubset<T, SystemNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemNotifications and returns the data updated in the database.
     * @param {SystemNotificationUpdateManyAndReturnArgs} args - Arguments to update many SystemNotifications.
     * @example
     * // Update many SystemNotifications
     * const systemNotification = await prisma.systemNotification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemNotifications and only return the `id`
     * const systemNotificationWithIdOnly = await prisma.systemNotification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemNotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemNotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemNotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemNotification.
     * @param {SystemNotificationUpsertArgs} args - Arguments to update or create a SystemNotification.
     * @example
     * // Update or create a SystemNotification
     * const systemNotification = await prisma.systemNotification.upsert({
     *   create: {
     *     // ... data to create a SystemNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemNotification we want to update
     *   }
     * })
     */
    upsert<T extends SystemNotificationUpsertArgs>(args: SelectSubset<T, SystemNotificationUpsertArgs<ExtArgs>>): Prisma__SystemNotificationClient<$Result.GetResult<Prisma.$SystemNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemNotificationCountArgs} args - Arguments to filter SystemNotifications to count.
     * @example
     * // Count the number of SystemNotifications
     * const count = await prisma.systemNotification.count({
     *   where: {
     *     // ... the filter for the SystemNotifications we want to count
     *   }
     * })
    **/
    count<T extends SystemNotificationCountArgs>(
      args?: Subset<T, SystemNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemNotificationAggregateArgs>(args: Subset<T, SystemNotificationAggregateArgs>): Prisma.PrismaPromise<GetSystemNotificationAggregateType<T>>

    /**
     * Group by SystemNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemNotificationGroupByArgs['orderBy'] }
        : { orderBy?: SystemNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemNotification model
   */
  readonly fields: SystemNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends SystemNotification$userArgs<ExtArgs> = {}>(args?: Subset<T, SystemNotification$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemNotification model
   */
  interface SystemNotificationFieldRefs {
    readonly id: FieldRef<"SystemNotification", 'String'>
    readonly type: FieldRef<"SystemNotification", 'String'>
    readonly title: FieldRef<"SystemNotification", 'String'>
    readonly message: FieldRef<"SystemNotification", 'String'>
    readonly isRead: FieldRef<"SystemNotification", 'Boolean'>
    readonly userId: FieldRef<"SystemNotification", 'String'>
    readonly entityId: FieldRef<"SystemNotification", 'String'>
    readonly entityType: FieldRef<"SystemNotification", 'String'>
    readonly relatedType: FieldRef<"SystemNotification", 'String'>
    readonly createdAt: FieldRef<"SystemNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemNotification findUnique
   */
  export type SystemNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemNotification
     */
    select?: SystemNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemNotification
     */
    omit?: SystemNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemNotificationInclude<ExtArgs> | null
    /**
     * Filter, which SystemNotification to fetch.
     */
    where: SystemNotificationWhereUniqueInput
  }

  /**
   * SystemNotification findUniqueOrThrow
   */
  export type SystemNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemNotification
     */
    select?: SystemNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemNotification
     */
    omit?: SystemNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemNotificationInclude<ExtArgs> | null
    /**
     * Filter, which SystemNotification to fetch.
     */
    where: SystemNotificationWhereUniqueInput
  }

  /**
   * SystemNotification findFirst
   */
  export type SystemNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemNotification
     */
    select?: SystemNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemNotification
     */
    omit?: SystemNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemNotificationInclude<ExtArgs> | null
    /**
     * Filter, which SystemNotification to fetch.
     */
    where?: SystemNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemNotifications to fetch.
     */
    orderBy?: SystemNotificationOrderByWithRelationInput | SystemNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemNotifications.
     */
    cursor?: SystemNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemNotifications.
     */
    distinct?: SystemNotificationScalarFieldEnum | SystemNotificationScalarFieldEnum[]
  }

  /**
   * SystemNotification findFirstOrThrow
   */
  export type SystemNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemNotification
     */
    select?: SystemNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemNotification
     */
    omit?: SystemNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemNotificationInclude<ExtArgs> | null
    /**
     * Filter, which SystemNotification to fetch.
     */
    where?: SystemNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemNotifications to fetch.
     */
    orderBy?: SystemNotificationOrderByWithRelationInput | SystemNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemNotifications.
     */
    cursor?: SystemNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemNotifications.
     */
    distinct?: SystemNotificationScalarFieldEnum | SystemNotificationScalarFieldEnum[]
  }

  /**
   * SystemNotification findMany
   */
  export type SystemNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemNotification
     */
    select?: SystemNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemNotification
     */
    omit?: SystemNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemNotificationInclude<ExtArgs> | null
    /**
     * Filter, which SystemNotifications to fetch.
     */
    where?: SystemNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemNotifications to fetch.
     */
    orderBy?: SystemNotificationOrderByWithRelationInput | SystemNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemNotifications.
     */
    cursor?: SystemNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemNotifications.
     */
    skip?: number
    distinct?: SystemNotificationScalarFieldEnum | SystemNotificationScalarFieldEnum[]
  }

  /**
   * SystemNotification create
   */
  export type SystemNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemNotification
     */
    select?: SystemNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemNotification
     */
    omit?: SystemNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a SystemNotification.
     */
    data: XOR<SystemNotificationCreateInput, SystemNotificationUncheckedCreateInput>
  }

  /**
   * SystemNotification createMany
   */
  export type SystemNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemNotifications.
     */
    data: SystemNotificationCreateManyInput | SystemNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemNotification createManyAndReturn
   */
  export type SystemNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemNotification
     */
    select?: SystemNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemNotification
     */
    omit?: SystemNotificationOmit<ExtArgs> | null
    /**
     * The data used to create many SystemNotifications.
     */
    data: SystemNotificationCreateManyInput | SystemNotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemNotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SystemNotification update
   */
  export type SystemNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemNotification
     */
    select?: SystemNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemNotification
     */
    omit?: SystemNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a SystemNotification.
     */
    data: XOR<SystemNotificationUpdateInput, SystemNotificationUncheckedUpdateInput>
    /**
     * Choose, which SystemNotification to update.
     */
    where: SystemNotificationWhereUniqueInput
  }

  /**
   * SystemNotification updateMany
   */
  export type SystemNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemNotifications.
     */
    data: XOR<SystemNotificationUpdateManyMutationInput, SystemNotificationUncheckedUpdateManyInput>
    /**
     * Filter which SystemNotifications to update
     */
    where?: SystemNotificationWhereInput
    /**
     * Limit how many SystemNotifications to update.
     */
    limit?: number
  }

  /**
   * SystemNotification updateManyAndReturn
   */
  export type SystemNotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemNotification
     */
    select?: SystemNotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemNotification
     */
    omit?: SystemNotificationOmit<ExtArgs> | null
    /**
     * The data used to update SystemNotifications.
     */
    data: XOR<SystemNotificationUpdateManyMutationInput, SystemNotificationUncheckedUpdateManyInput>
    /**
     * Filter which SystemNotifications to update
     */
    where?: SystemNotificationWhereInput
    /**
     * Limit how many SystemNotifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemNotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SystemNotification upsert
   */
  export type SystemNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemNotification
     */
    select?: SystemNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemNotification
     */
    omit?: SystemNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the SystemNotification to update in case it exists.
     */
    where: SystemNotificationWhereUniqueInput
    /**
     * In case the SystemNotification found by the `where` argument doesn't exist, create a new SystemNotification with this data.
     */
    create: XOR<SystemNotificationCreateInput, SystemNotificationUncheckedCreateInput>
    /**
     * In case the SystemNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemNotificationUpdateInput, SystemNotificationUncheckedUpdateInput>
  }

  /**
   * SystemNotification delete
   */
  export type SystemNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemNotification
     */
    select?: SystemNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemNotification
     */
    omit?: SystemNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemNotificationInclude<ExtArgs> | null
    /**
     * Filter which SystemNotification to delete.
     */
    where: SystemNotificationWhereUniqueInput
  }

  /**
   * SystemNotification deleteMany
   */
  export type SystemNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemNotifications to delete
     */
    where?: SystemNotificationWhereInput
    /**
     * Limit how many SystemNotifications to delete.
     */
    limit?: number
  }

  /**
   * SystemNotification.user
   */
  export type SystemNotification$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SystemNotification without action
   */
  export type SystemNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemNotification
     */
    select?: SystemNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemNotification
     */
    omit?: SystemNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemNotificationInclude<ExtArgs> | null
  }


  /**
   * Model RentalItem
   */

  export type AggregateRentalItem = {
    _count: RentalItemCountAggregateOutputType | null
    _avg: RentalItemAvgAggregateOutputType | null
    _sum: RentalItemSumAggregateOutputType | null
    _min: RentalItemMinAggregateOutputType | null
    _max: RentalItemMaxAggregateOutputType | null
  }

  export type RentalItemAvgAggregateOutputType = {
    quantity: number | null
  }

  export type RentalItemSumAggregateOutputType = {
    quantity: number | null
  }

  export type RentalItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    variantId: string | null
    packageId: string | null
    quantity: number | null
    createdAt: Date | null
    unitId: string | null
  }

  export type RentalItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    variantId: string | null
    packageId: string | null
    quantity: number | null
    createdAt: Date | null
    unitId: string | null
  }

  export type RentalItemCountAggregateOutputType = {
    id: number
    orderId: number
    variantId: number
    packageId: number
    quantity: number
    createdAt: number
    unitId: number
    _all: number
  }


  export type RentalItemAvgAggregateInputType = {
    quantity?: true
  }

  export type RentalItemSumAggregateInputType = {
    quantity?: true
  }

  export type RentalItemMinAggregateInputType = {
    id?: true
    orderId?: true
    variantId?: true
    packageId?: true
    quantity?: true
    createdAt?: true
    unitId?: true
  }

  export type RentalItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    variantId?: true
    packageId?: true
    quantity?: true
    createdAt?: true
    unitId?: true
  }

  export type RentalItemCountAggregateInputType = {
    id?: true
    orderId?: true
    variantId?: true
    packageId?: true
    quantity?: true
    createdAt?: true
    unitId?: true
    _all?: true
  }

  export type RentalItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RentalItem to aggregate.
     */
    where?: RentalItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalItems to fetch.
     */
    orderBy?: RentalItemOrderByWithRelationInput | RentalItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RentalItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RentalItems
    **/
    _count?: true | RentalItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RentalItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RentalItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RentalItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RentalItemMaxAggregateInputType
  }

  export type GetRentalItemAggregateType<T extends RentalItemAggregateArgs> = {
        [P in keyof T & keyof AggregateRentalItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRentalItem[P]>
      : GetScalarType<T[P], AggregateRentalItem[P]>
  }




  export type RentalItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RentalItemWhereInput
    orderBy?: RentalItemOrderByWithAggregationInput | RentalItemOrderByWithAggregationInput[]
    by: RentalItemScalarFieldEnum[] | RentalItemScalarFieldEnum
    having?: RentalItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RentalItemCountAggregateInputType | true
    _avg?: RentalItemAvgAggregateInputType
    _sum?: RentalItemSumAggregateInputType
    _min?: RentalItemMinAggregateInputType
    _max?: RentalItemMaxAggregateInputType
  }

  export type RentalItemGroupByOutputType = {
    id: string
    orderId: string
    variantId: string | null
    packageId: string | null
    quantity: number | null
    createdAt: Date | null
    unitId: string | null
    _count: RentalItemCountAggregateOutputType | null
    _avg: RentalItemAvgAggregateOutputType | null
    _sum: RentalItemSumAggregateOutputType | null
    _min: RentalItemMinAggregateOutputType | null
    _max: RentalItemMaxAggregateOutputType | null
  }

  type GetRentalItemGroupByPayload<T extends RentalItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RentalItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RentalItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RentalItemGroupByOutputType[P]>
            : GetScalarType<T[P], RentalItemGroupByOutputType[P]>
        }
      >
    >


  export type RentalItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    variantId?: boolean
    packageId?: boolean
    quantity?: boolean
    createdAt?: boolean
    unitId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    rentalPackage?: boolean | RentalItem$rentalPackageArgs<ExtArgs>
    variant?: boolean | RentalItem$variantArgs<ExtArgs>
    unit?: boolean | RentalItem$unitArgs<ExtArgs>
    deliveryItems?: boolean | RentalItem$deliveryItemsArgs<ExtArgs>
    _count?: boolean | RentalItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rentalItem"]>

  export type RentalItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    variantId?: boolean
    packageId?: boolean
    quantity?: boolean
    createdAt?: boolean
    unitId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    rentalPackage?: boolean | RentalItem$rentalPackageArgs<ExtArgs>
    variant?: boolean | RentalItem$variantArgs<ExtArgs>
    unit?: boolean | RentalItem$unitArgs<ExtArgs>
  }, ExtArgs["result"]["rentalItem"]>

  export type RentalItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    variantId?: boolean
    packageId?: boolean
    quantity?: boolean
    createdAt?: boolean
    unitId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    rentalPackage?: boolean | RentalItem$rentalPackageArgs<ExtArgs>
    variant?: boolean | RentalItem$variantArgs<ExtArgs>
    unit?: boolean | RentalItem$unitArgs<ExtArgs>
  }, ExtArgs["result"]["rentalItem"]>

  export type RentalItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    variantId?: boolean
    packageId?: boolean
    quantity?: boolean
    createdAt?: boolean
    unitId?: boolean
  }

  export type RentalItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "variantId" | "packageId" | "quantity" | "createdAt" | "unitId", ExtArgs["result"]["rentalItem"]>
  export type RentalItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    rentalPackage?: boolean | RentalItem$rentalPackageArgs<ExtArgs>
    variant?: boolean | RentalItem$variantArgs<ExtArgs>
    unit?: boolean | RentalItem$unitArgs<ExtArgs>
    deliveryItems?: boolean | RentalItem$deliveryItemsArgs<ExtArgs>
    _count?: boolean | RentalItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RentalItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    rentalPackage?: boolean | RentalItem$rentalPackageArgs<ExtArgs>
    variant?: boolean | RentalItem$variantArgs<ExtArgs>
    unit?: boolean | RentalItem$unitArgs<ExtArgs>
  }
  export type RentalItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    rentalPackage?: boolean | RentalItem$rentalPackageArgs<ExtArgs>
    variant?: boolean | RentalItem$variantArgs<ExtArgs>
    unit?: boolean | RentalItem$unitArgs<ExtArgs>
  }

  export type $RentalItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RentalItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      rentalPackage: Prisma.$RentalPackagePayload<ExtArgs> | null
      variant: Prisma.$ProductVariantPayload<ExtArgs> | null
      unit: Prisma.$ProductUnitPayload<ExtArgs> | null
      deliveryItems: Prisma.$DeliveryItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      variantId: string | null
      packageId: string | null
      quantity: number | null
      createdAt: Date | null
      unitId: string | null
    }, ExtArgs["result"]["rentalItem"]>
    composites: {}
  }

  type RentalItemGetPayload<S extends boolean | null | undefined | RentalItemDefaultArgs> = $Result.GetResult<Prisma.$RentalItemPayload, S>

  type RentalItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RentalItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RentalItemCountAggregateInputType | true
    }

  export interface RentalItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RentalItem'], meta: { name: 'RentalItem' } }
    /**
     * Find zero or one RentalItem that matches the filter.
     * @param {RentalItemFindUniqueArgs} args - Arguments to find a RentalItem
     * @example
     * // Get one RentalItem
     * const rentalItem = await prisma.rentalItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RentalItemFindUniqueArgs>(args: SelectSubset<T, RentalItemFindUniqueArgs<ExtArgs>>): Prisma__RentalItemClient<$Result.GetResult<Prisma.$RentalItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RentalItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RentalItemFindUniqueOrThrowArgs} args - Arguments to find a RentalItem
     * @example
     * // Get one RentalItem
     * const rentalItem = await prisma.rentalItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RentalItemFindUniqueOrThrowArgs>(args: SelectSubset<T, RentalItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RentalItemClient<$Result.GetResult<Prisma.$RentalItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RentalItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalItemFindFirstArgs} args - Arguments to find a RentalItem
     * @example
     * // Get one RentalItem
     * const rentalItem = await prisma.rentalItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RentalItemFindFirstArgs>(args?: SelectSubset<T, RentalItemFindFirstArgs<ExtArgs>>): Prisma__RentalItemClient<$Result.GetResult<Prisma.$RentalItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RentalItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalItemFindFirstOrThrowArgs} args - Arguments to find a RentalItem
     * @example
     * // Get one RentalItem
     * const rentalItem = await prisma.rentalItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RentalItemFindFirstOrThrowArgs>(args?: SelectSubset<T, RentalItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__RentalItemClient<$Result.GetResult<Prisma.$RentalItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RentalItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RentalItems
     * const rentalItems = await prisma.rentalItem.findMany()
     * 
     * // Get first 10 RentalItems
     * const rentalItems = await prisma.rentalItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rentalItemWithIdOnly = await prisma.rentalItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RentalItemFindManyArgs>(args?: SelectSubset<T, RentalItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RentalItem.
     * @param {RentalItemCreateArgs} args - Arguments to create a RentalItem.
     * @example
     * // Create one RentalItem
     * const RentalItem = await prisma.rentalItem.create({
     *   data: {
     *     // ... data to create a RentalItem
     *   }
     * })
     * 
     */
    create<T extends RentalItemCreateArgs>(args: SelectSubset<T, RentalItemCreateArgs<ExtArgs>>): Prisma__RentalItemClient<$Result.GetResult<Prisma.$RentalItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RentalItems.
     * @param {RentalItemCreateManyArgs} args - Arguments to create many RentalItems.
     * @example
     * // Create many RentalItems
     * const rentalItem = await prisma.rentalItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RentalItemCreateManyArgs>(args?: SelectSubset<T, RentalItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RentalItems and returns the data saved in the database.
     * @param {RentalItemCreateManyAndReturnArgs} args - Arguments to create many RentalItems.
     * @example
     * // Create many RentalItems
     * const rentalItem = await prisma.rentalItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RentalItems and only return the `id`
     * const rentalItemWithIdOnly = await prisma.rentalItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RentalItemCreateManyAndReturnArgs>(args?: SelectSubset<T, RentalItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RentalItem.
     * @param {RentalItemDeleteArgs} args - Arguments to delete one RentalItem.
     * @example
     * // Delete one RentalItem
     * const RentalItem = await prisma.rentalItem.delete({
     *   where: {
     *     // ... filter to delete one RentalItem
     *   }
     * })
     * 
     */
    delete<T extends RentalItemDeleteArgs>(args: SelectSubset<T, RentalItemDeleteArgs<ExtArgs>>): Prisma__RentalItemClient<$Result.GetResult<Prisma.$RentalItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RentalItem.
     * @param {RentalItemUpdateArgs} args - Arguments to update one RentalItem.
     * @example
     * // Update one RentalItem
     * const rentalItem = await prisma.rentalItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RentalItemUpdateArgs>(args: SelectSubset<T, RentalItemUpdateArgs<ExtArgs>>): Prisma__RentalItemClient<$Result.GetResult<Prisma.$RentalItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RentalItems.
     * @param {RentalItemDeleteManyArgs} args - Arguments to filter RentalItems to delete.
     * @example
     * // Delete a few RentalItems
     * const { count } = await prisma.rentalItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RentalItemDeleteManyArgs>(args?: SelectSubset<T, RentalItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RentalItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RentalItems
     * const rentalItem = await prisma.rentalItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RentalItemUpdateManyArgs>(args: SelectSubset<T, RentalItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RentalItems and returns the data updated in the database.
     * @param {RentalItemUpdateManyAndReturnArgs} args - Arguments to update many RentalItems.
     * @example
     * // Update many RentalItems
     * const rentalItem = await prisma.rentalItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RentalItems and only return the `id`
     * const rentalItemWithIdOnly = await prisma.rentalItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RentalItemUpdateManyAndReturnArgs>(args: SelectSubset<T, RentalItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RentalItem.
     * @param {RentalItemUpsertArgs} args - Arguments to update or create a RentalItem.
     * @example
     * // Update or create a RentalItem
     * const rentalItem = await prisma.rentalItem.upsert({
     *   create: {
     *     // ... data to create a RentalItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RentalItem we want to update
     *   }
     * })
     */
    upsert<T extends RentalItemUpsertArgs>(args: SelectSubset<T, RentalItemUpsertArgs<ExtArgs>>): Prisma__RentalItemClient<$Result.GetResult<Prisma.$RentalItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RentalItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalItemCountArgs} args - Arguments to filter RentalItems to count.
     * @example
     * // Count the number of RentalItems
     * const count = await prisma.rentalItem.count({
     *   where: {
     *     // ... the filter for the RentalItems we want to count
     *   }
     * })
    **/
    count<T extends RentalItemCountArgs>(
      args?: Subset<T, RentalItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RentalItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RentalItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RentalItemAggregateArgs>(args: Subset<T, RentalItemAggregateArgs>): Prisma.PrismaPromise<GetRentalItemAggregateType<T>>

    /**
     * Group by RentalItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RentalItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RentalItemGroupByArgs['orderBy'] }
        : { orderBy?: RentalItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RentalItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRentalItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RentalItem model
   */
  readonly fields: RentalItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RentalItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RentalItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rentalPackage<T extends RentalItem$rentalPackageArgs<ExtArgs> = {}>(args?: Subset<T, RentalItem$rentalPackageArgs<ExtArgs>>): Prisma__RentalPackageClient<$Result.GetResult<Prisma.$RentalPackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    variant<T extends RentalItem$variantArgs<ExtArgs> = {}>(args?: Subset<T, RentalItem$variantArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    unit<T extends RentalItem$unitArgs<ExtArgs> = {}>(args?: Subset<T, RentalItem$unitArgs<ExtArgs>>): Prisma__ProductUnitClient<$Result.GetResult<Prisma.$ProductUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    deliveryItems<T extends RentalItem$deliveryItemsArgs<ExtArgs> = {}>(args?: Subset<T, RentalItem$deliveryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RentalItem model
   */
  interface RentalItemFieldRefs {
    readonly id: FieldRef<"RentalItem", 'String'>
    readonly orderId: FieldRef<"RentalItem", 'String'>
    readonly variantId: FieldRef<"RentalItem", 'String'>
    readonly packageId: FieldRef<"RentalItem", 'String'>
    readonly quantity: FieldRef<"RentalItem", 'Int'>
    readonly createdAt: FieldRef<"RentalItem", 'DateTime'>
    readonly unitId: FieldRef<"RentalItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RentalItem findUnique
   */
  export type RentalItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalItem
     */
    select?: RentalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalItem
     */
    omit?: RentalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalItemInclude<ExtArgs> | null
    /**
     * Filter, which RentalItem to fetch.
     */
    where: RentalItemWhereUniqueInput
  }

  /**
   * RentalItem findUniqueOrThrow
   */
  export type RentalItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalItem
     */
    select?: RentalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalItem
     */
    omit?: RentalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalItemInclude<ExtArgs> | null
    /**
     * Filter, which RentalItem to fetch.
     */
    where: RentalItemWhereUniqueInput
  }

  /**
   * RentalItem findFirst
   */
  export type RentalItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalItem
     */
    select?: RentalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalItem
     */
    omit?: RentalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalItemInclude<ExtArgs> | null
    /**
     * Filter, which RentalItem to fetch.
     */
    where?: RentalItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalItems to fetch.
     */
    orderBy?: RentalItemOrderByWithRelationInput | RentalItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RentalItems.
     */
    cursor?: RentalItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RentalItems.
     */
    distinct?: RentalItemScalarFieldEnum | RentalItemScalarFieldEnum[]
  }

  /**
   * RentalItem findFirstOrThrow
   */
  export type RentalItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalItem
     */
    select?: RentalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalItem
     */
    omit?: RentalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalItemInclude<ExtArgs> | null
    /**
     * Filter, which RentalItem to fetch.
     */
    where?: RentalItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalItems to fetch.
     */
    orderBy?: RentalItemOrderByWithRelationInput | RentalItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RentalItems.
     */
    cursor?: RentalItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RentalItems.
     */
    distinct?: RentalItemScalarFieldEnum | RentalItemScalarFieldEnum[]
  }

  /**
   * RentalItem findMany
   */
  export type RentalItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalItem
     */
    select?: RentalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalItem
     */
    omit?: RentalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalItemInclude<ExtArgs> | null
    /**
     * Filter, which RentalItems to fetch.
     */
    where?: RentalItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalItems to fetch.
     */
    orderBy?: RentalItemOrderByWithRelationInput | RentalItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RentalItems.
     */
    cursor?: RentalItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalItems.
     */
    skip?: number
    distinct?: RentalItemScalarFieldEnum | RentalItemScalarFieldEnum[]
  }

  /**
   * RentalItem create
   */
  export type RentalItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalItem
     */
    select?: RentalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalItem
     */
    omit?: RentalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalItemInclude<ExtArgs> | null
    /**
     * The data needed to create a RentalItem.
     */
    data: XOR<RentalItemCreateInput, RentalItemUncheckedCreateInput>
  }

  /**
   * RentalItem createMany
   */
  export type RentalItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RentalItems.
     */
    data: RentalItemCreateManyInput | RentalItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RentalItem createManyAndReturn
   */
  export type RentalItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalItem
     */
    select?: RentalItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RentalItem
     */
    omit?: RentalItemOmit<ExtArgs> | null
    /**
     * The data used to create many RentalItems.
     */
    data: RentalItemCreateManyInput | RentalItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RentalItem update
   */
  export type RentalItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalItem
     */
    select?: RentalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalItem
     */
    omit?: RentalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalItemInclude<ExtArgs> | null
    /**
     * The data needed to update a RentalItem.
     */
    data: XOR<RentalItemUpdateInput, RentalItemUncheckedUpdateInput>
    /**
     * Choose, which RentalItem to update.
     */
    where: RentalItemWhereUniqueInput
  }

  /**
   * RentalItem updateMany
   */
  export type RentalItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RentalItems.
     */
    data: XOR<RentalItemUpdateManyMutationInput, RentalItemUncheckedUpdateManyInput>
    /**
     * Filter which RentalItems to update
     */
    where?: RentalItemWhereInput
    /**
     * Limit how many RentalItems to update.
     */
    limit?: number
  }

  /**
   * RentalItem updateManyAndReturn
   */
  export type RentalItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalItem
     */
    select?: RentalItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RentalItem
     */
    omit?: RentalItemOmit<ExtArgs> | null
    /**
     * The data used to update RentalItems.
     */
    data: XOR<RentalItemUpdateManyMutationInput, RentalItemUncheckedUpdateManyInput>
    /**
     * Filter which RentalItems to update
     */
    where?: RentalItemWhereInput
    /**
     * Limit how many RentalItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RentalItem upsert
   */
  export type RentalItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalItem
     */
    select?: RentalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalItem
     */
    omit?: RentalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalItemInclude<ExtArgs> | null
    /**
     * The filter to search for the RentalItem to update in case it exists.
     */
    where: RentalItemWhereUniqueInput
    /**
     * In case the RentalItem found by the `where` argument doesn't exist, create a new RentalItem with this data.
     */
    create: XOR<RentalItemCreateInput, RentalItemUncheckedCreateInput>
    /**
     * In case the RentalItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RentalItemUpdateInput, RentalItemUncheckedUpdateInput>
  }

  /**
   * RentalItem delete
   */
  export type RentalItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalItem
     */
    select?: RentalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalItem
     */
    omit?: RentalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalItemInclude<ExtArgs> | null
    /**
     * Filter which RentalItem to delete.
     */
    where: RentalItemWhereUniqueInput
  }

  /**
   * RentalItem deleteMany
   */
  export type RentalItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RentalItems to delete
     */
    where?: RentalItemWhereInput
    /**
     * Limit how many RentalItems to delete.
     */
    limit?: number
  }

  /**
   * RentalItem.rentalPackage
   */
  export type RentalItem$rentalPackageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPackage
     */
    select?: RentalPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPackage
     */
    omit?: RentalPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalPackageInclude<ExtArgs> | null
    where?: RentalPackageWhereInput
  }

  /**
   * RentalItem.variant
   */
  export type RentalItem$variantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    where?: ProductVariantWhereInput
  }

  /**
   * RentalItem.unit
   */
  export type RentalItem$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductUnit
     */
    select?: ProductUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductUnit
     */
    omit?: ProductUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductUnitInclude<ExtArgs> | null
    where?: ProductUnitWhereInput
  }

  /**
   * RentalItem.deliveryItems
   */
  export type RentalItem$deliveryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryItem
     */
    omit?: DeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryItemInclude<ExtArgs> | null
    where?: DeliveryItemWhereInput
    orderBy?: DeliveryItemOrderByWithRelationInput | DeliveryItemOrderByWithRelationInput[]
    cursor?: DeliveryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryItemScalarFieldEnum | DeliveryItemScalarFieldEnum[]
  }

  /**
   * RentalItem without action
   */
  export type RentalItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalItem
     */
    select?: RentalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalItem
     */
    omit?: RentalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalItemInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
    plainPassword: string | null
    email: string | null
    fullName: string | null
    whatsapp: string | null
    baliAddress: string | null
    mapsAddressLink: string | null
    role: string | null
    createdAt: Date | null
    isVerified: boolean | null
    resetPasswordExpires: Date | null
    resetPasswordToken: string | null
    isActive: boolean | null
    profileImage: string | null
    identityFile: string | null
    identityType: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
    plainPassword: string | null
    email: string | null
    fullName: string | null
    whatsapp: string | null
    baliAddress: string | null
    mapsAddressLink: string | null
    role: string | null
    createdAt: Date | null
    isVerified: boolean | null
    resetPasswordExpires: Date | null
    resetPasswordToken: string | null
    isActive: boolean | null
    profileImage: string | null
    identityFile: string | null
    identityType: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    plainPassword: number
    email: number
    fullName: number
    whatsapp: number
    baliAddress: number
    mapsAddressLink: number
    role: number
    createdAt: number
    isVerified: number
    resetPasswordExpires: number
    resetPasswordToken: number
    isActive: number
    profileImage: number
    identityFile: number
    identityType: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    plainPassword?: true
    email?: true
    fullName?: true
    whatsapp?: true
    baliAddress?: true
    mapsAddressLink?: true
    role?: true
    createdAt?: true
    isVerified?: true
    resetPasswordExpires?: true
    resetPasswordToken?: true
    isActive?: true
    profileImage?: true
    identityFile?: true
    identityType?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    plainPassword?: true
    email?: true
    fullName?: true
    whatsapp?: true
    baliAddress?: true
    mapsAddressLink?: true
    role?: true
    createdAt?: true
    isVerified?: true
    resetPasswordExpires?: true
    resetPasswordToken?: true
    isActive?: true
    profileImage?: true
    identityFile?: true
    identityType?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    plainPassword?: true
    email?: true
    fullName?: true
    whatsapp?: true
    baliAddress?: true
    mapsAddressLink?: true
    role?: true
    createdAt?: true
    isVerified?: true
    resetPasswordExpires?: true
    resetPasswordToken?: true
    isActive?: true
    profileImage?: true
    identityFile?: true
    identityType?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    password: string
    plainPassword: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress: string | null
    mapsAddressLink: string | null
    role: string
    createdAt: Date | null
    isVerified: boolean
    resetPasswordExpires: Date | null
    resetPasswordToken: string | null
    isActive: boolean
    profileImage: string | null
    identityFile: string | null
    identityType: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    plainPassword?: boolean
    email?: boolean
    fullName?: boolean
    whatsapp?: boolean
    baliAddress?: boolean
    mapsAddressLink?: boolean
    role?: boolean
    createdAt?: boolean
    isVerified?: boolean
    resetPasswordExpires?: boolean
    resetPasswordToken?: boolean
    isActive?: boolean
    profileImage?: boolean
    identityFile?: boolean
    identityType?: boolean
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    inventoryResolutions?: boolean | User$inventoryResolutionsArgs<ExtArgs>
    inventoryUpdates?: boolean | User$inventoryUpdatesArgs<ExtArgs>
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    orders_orders_payment_confirmed_byTousers?: boolean | User$orders_orders_payment_confirmed_byTousersArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    workerAttendance?: boolean | User$workerAttendanceArgs<ExtArgs>
    claimedDeliveries?: boolean | User$claimedDeliveriesArgs<ExtArgs>
    deliveryLogs?: boolean | User$deliveryLogsArgs<ExtArgs>
    deliveryEditLogs?: boolean | User$deliveryEditLogsArgs<ExtArgs>
    sentNotifications?: boolean | User$sentNotificationsArgs<ExtArgs>
    receivedNotifications?: boolean | User$receivedNotificationsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    chatGroupMemberships?: boolean | User$chatGroupMembershipsArgs<ExtArgs>
    sentGroupMessages?: boolean | User$sentGroupMessagesArgs<ExtArgs>
    notificationDismissals?: boolean | User$notificationDismissalsArgs<ExtArgs>
    systemNotifications?: boolean | User$systemNotificationsArgs<ExtArgs>
    verifiedTransactions?: boolean | User$verifiedTransactionsArgs<ExtArgs>
    unitActions?: boolean | User$unitActionsArgs<ExtArgs>
    aiActionApprovals?: boolean | User$aiActionApprovalsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    plainPassword?: boolean
    email?: boolean
    fullName?: boolean
    whatsapp?: boolean
    baliAddress?: boolean
    mapsAddressLink?: boolean
    role?: boolean
    createdAt?: boolean
    isVerified?: boolean
    resetPasswordExpires?: boolean
    resetPasswordToken?: boolean
    isActive?: boolean
    profileImage?: boolean
    identityFile?: boolean
    identityType?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    plainPassword?: boolean
    email?: boolean
    fullName?: boolean
    whatsapp?: boolean
    baliAddress?: boolean
    mapsAddressLink?: boolean
    role?: boolean
    createdAt?: boolean
    isVerified?: boolean
    resetPasswordExpires?: boolean
    resetPasswordToken?: boolean
    isActive?: boolean
    profileImage?: boolean
    identityFile?: boolean
    identityType?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    plainPassword?: boolean
    email?: boolean
    fullName?: boolean
    whatsapp?: boolean
    baliAddress?: boolean
    mapsAddressLink?: boolean
    role?: boolean
    createdAt?: boolean
    isVerified?: boolean
    resetPasswordExpires?: boolean
    resetPasswordToken?: boolean
    isActive?: boolean
    profileImage?: boolean
    identityFile?: boolean
    identityType?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password" | "plainPassword" | "email" | "fullName" | "whatsapp" | "baliAddress" | "mapsAddressLink" | "role" | "createdAt" | "isVerified" | "resetPasswordExpires" | "resetPasswordToken" | "isActive" | "profileImage" | "identityFile" | "identityType", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    inventoryResolutions?: boolean | User$inventoryResolutionsArgs<ExtArgs>
    inventoryUpdates?: boolean | User$inventoryUpdatesArgs<ExtArgs>
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    orders_orders_payment_confirmed_byTousers?: boolean | User$orders_orders_payment_confirmed_byTousersArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    workerAttendance?: boolean | User$workerAttendanceArgs<ExtArgs>
    claimedDeliveries?: boolean | User$claimedDeliveriesArgs<ExtArgs>
    deliveryLogs?: boolean | User$deliveryLogsArgs<ExtArgs>
    deliveryEditLogs?: boolean | User$deliveryEditLogsArgs<ExtArgs>
    sentNotifications?: boolean | User$sentNotificationsArgs<ExtArgs>
    receivedNotifications?: boolean | User$receivedNotificationsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    chatGroupMemberships?: boolean | User$chatGroupMembershipsArgs<ExtArgs>
    sentGroupMessages?: boolean | User$sentGroupMessagesArgs<ExtArgs>
    notificationDismissals?: boolean | User$notificationDismissalsArgs<ExtArgs>
    systemNotifications?: boolean | User$systemNotificationsArgs<ExtArgs>
    verifiedTransactions?: boolean | User$verifiedTransactionsArgs<ExtArgs>
    unitActions?: boolean | User$unitActionsArgs<ExtArgs>
    aiActionApprovals?: boolean | User$aiActionApprovalsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      activityLogs: Prisma.$ActivityLogPayload<ExtArgs>[]
      inventoryResolutions: Prisma.$InventorySyncLogPayload<ExtArgs>[]
      inventoryUpdates: Prisma.$InventorySyncLogPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      orders_orders_payment_confirmed_byTousers: Prisma.$OrderPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      workerAttendance: Prisma.$WorkerAttendancePayload<ExtArgs>[]
      claimedDeliveries: Prisma.$DeliveryPayload<ExtArgs>[]
      deliveryLogs: Prisma.$DeliveryLogPayload<ExtArgs>[]
      deliveryEditLogs: Prisma.$DeliveryEditLogPayload<ExtArgs>[]
      sentNotifications: Prisma.$WorkerNotificationPayload<ExtArgs>[]
      receivedNotifications: Prisma.$WorkerNotificationPayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      receivedMessages: Prisma.$MessagePayload<ExtArgs>[]
      chatGroupMemberships: Prisma.$ChatGroupMemberPayload<ExtArgs>[]
      sentGroupMessages: Prisma.$GroupMessagePayload<ExtArgs>[]
      notificationDismissals: Prisma.$NotificationDismissalPayload<ExtArgs>[]
      systemNotifications: Prisma.$SystemNotificationPayload<ExtArgs>[]
      verifiedTransactions: Prisma.$PaymentTransactionPayload<ExtArgs>[]
      unitActions: Prisma.$UnitHistoryPayload<ExtArgs>[]
      aiActionApprovals: Prisma.$AiActionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      password: string
      plainPassword: string | null
      email: string
      fullName: string
      whatsapp: string
      baliAddress: string | null
      mapsAddressLink: string | null
      role: string
      createdAt: Date | null
      isVerified: boolean
      resetPasswordExpires: Date | null
      resetPasswordToken: string | null
      isActive: boolean
      profileImage: string | null
      identityFile: string | null
      identityType: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activityLogs<T extends User$activityLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$activityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryResolutions<T extends User$inventoryResolutionsArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryResolutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventorySyncLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryUpdates<T extends User$inventoryUpdatesArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryUpdatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventorySyncLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends User$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, User$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders_orders_payment_confirmed_byTousers<T extends User$orders_orders_payment_confirmed_byTousersArgs<ExtArgs> = {}>(args?: Subset<T, User$orders_orders_payment_confirmed_byTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workerAttendance<T extends User$workerAttendanceArgs<ExtArgs> = {}>(args?: Subset<T, User$workerAttendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    claimedDeliveries<T extends User$claimedDeliveriesArgs<ExtArgs> = {}>(args?: Subset<T, User$claimedDeliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveryLogs<T extends User$deliveryLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$deliveryLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveryEditLogs<T extends User$deliveryEditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$deliveryEditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryEditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentNotifications<T extends User$sentNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$sentNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedNotifications<T extends User$receivedNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedMessages<T extends User$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatGroupMemberships<T extends User$chatGroupMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$chatGroupMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentGroupMessages<T extends User$sentGroupMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentGroupMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationDismissals<T extends User$notificationDismissalsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationDismissalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationDismissalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    systemNotifications<T extends User$systemNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$systemNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verifiedTransactions<T extends User$verifiedTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$verifiedTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unitActions<T extends User$unitActionsArgs<ExtArgs> = {}>(args?: Subset<T, User$unitActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiActionApprovals<T extends User$aiActionApprovalsArgs<ExtArgs> = {}>(args?: Subset<T, User$aiActionApprovalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly plainPassword: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly whatsapp: FieldRef<"User", 'String'>
    readonly baliAddress: FieldRef<"User", 'String'>
    readonly mapsAddressLink: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly resetPasswordExpires: FieldRef<"User", 'DateTime'>
    readonly resetPasswordToken: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly profileImage: FieldRef<"User", 'String'>
    readonly identityFile: FieldRef<"User", 'String'>
    readonly identityType: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.activityLogs
   */
  export type User$activityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * User.inventoryResolutions
   */
  export type User$inventoryResolutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySyncLog
     */
    select?: InventorySyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySyncLog
     */
    omit?: InventorySyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySyncLogInclude<ExtArgs> | null
    where?: InventorySyncLogWhereInput
    orderBy?: InventorySyncLogOrderByWithRelationInput | InventorySyncLogOrderByWithRelationInput[]
    cursor?: InventorySyncLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventorySyncLogScalarFieldEnum | InventorySyncLogScalarFieldEnum[]
  }

  /**
   * User.inventoryUpdates
   */
  export type User$inventoryUpdatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySyncLog
     */
    select?: InventorySyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySyncLog
     */
    omit?: InventorySyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySyncLogInclude<ExtArgs> | null
    where?: InventorySyncLogWhereInput
    orderBy?: InventorySyncLogOrderByWithRelationInput | InventorySyncLogOrderByWithRelationInput[]
    cursor?: InventorySyncLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventorySyncLogScalarFieldEnum | InventorySyncLogScalarFieldEnum[]
  }

  /**
   * User.invoices
   */
  export type User$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User.orders_orders_payment_confirmed_byTousers
   */
  export type User$orders_orders_payment_confirmed_byTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.workerAttendance
   */
  export type User$workerAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAttendance
     */
    select?: WorkerAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAttendance
     */
    omit?: WorkerAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAttendanceInclude<ExtArgs> | null
    where?: WorkerAttendanceWhereInput
    orderBy?: WorkerAttendanceOrderByWithRelationInput | WorkerAttendanceOrderByWithRelationInput[]
    cursor?: WorkerAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkerAttendanceScalarFieldEnum | WorkerAttendanceScalarFieldEnum[]
  }

  /**
   * User.claimedDeliveries
   */
  export type User$claimedDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    where?: DeliveryWhereInput
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    cursor?: DeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * User.deliveryLogs
   */
  export type User$deliveryLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogInclude<ExtArgs> | null
    where?: DeliveryLogWhereInput
    orderBy?: DeliveryLogOrderByWithRelationInput | DeliveryLogOrderByWithRelationInput[]
    cursor?: DeliveryLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryLogScalarFieldEnum | DeliveryLogScalarFieldEnum[]
  }

  /**
   * User.deliveryEditLogs
   */
  export type User$deliveryEditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEditLog
     */
    select?: DeliveryEditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEditLog
     */
    omit?: DeliveryEditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEditLogInclude<ExtArgs> | null
    where?: DeliveryEditLogWhereInput
    orderBy?: DeliveryEditLogOrderByWithRelationInput | DeliveryEditLogOrderByWithRelationInput[]
    cursor?: DeliveryEditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryEditLogScalarFieldEnum | DeliveryEditLogScalarFieldEnum[]
  }

  /**
   * User.sentNotifications
   */
  export type User$sentNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerNotification
     */
    select?: WorkerNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerNotification
     */
    omit?: WorkerNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerNotificationInclude<ExtArgs> | null
    where?: WorkerNotificationWhereInput
    orderBy?: WorkerNotificationOrderByWithRelationInput | WorkerNotificationOrderByWithRelationInput[]
    cursor?: WorkerNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkerNotificationScalarFieldEnum | WorkerNotificationScalarFieldEnum[]
  }

  /**
   * User.receivedNotifications
   */
  export type User$receivedNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerNotification
     */
    select?: WorkerNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerNotification
     */
    omit?: WorkerNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerNotificationInclude<ExtArgs> | null
    where?: WorkerNotificationWhereInput
    orderBy?: WorkerNotificationOrderByWithRelationInput | WorkerNotificationOrderByWithRelationInput[]
    cursor?: WorkerNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkerNotificationScalarFieldEnum | WorkerNotificationScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.receivedMessages
   */
  export type User$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.chatGroupMemberships
   */
  export type User$chatGroupMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberInclude<ExtArgs> | null
    where?: ChatGroupMemberWhereInput
    orderBy?: ChatGroupMemberOrderByWithRelationInput | ChatGroupMemberOrderByWithRelationInput[]
    cursor?: ChatGroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatGroupMemberScalarFieldEnum | ChatGroupMemberScalarFieldEnum[]
  }

  /**
   * User.sentGroupMessages
   */
  export type User$sentGroupMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessage
     */
    select?: GroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessage
     */
    omit?: GroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageInclude<ExtArgs> | null
    where?: GroupMessageWhereInput
    orderBy?: GroupMessageOrderByWithRelationInput | GroupMessageOrderByWithRelationInput[]
    cursor?: GroupMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMessageScalarFieldEnum | GroupMessageScalarFieldEnum[]
  }

  /**
   * User.notificationDismissals
   */
  export type User$notificationDismissalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDismissal
     */
    select?: NotificationDismissalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDismissal
     */
    omit?: NotificationDismissalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDismissalInclude<ExtArgs> | null
    where?: NotificationDismissalWhereInput
    orderBy?: NotificationDismissalOrderByWithRelationInput | NotificationDismissalOrderByWithRelationInput[]
    cursor?: NotificationDismissalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationDismissalScalarFieldEnum | NotificationDismissalScalarFieldEnum[]
  }

  /**
   * User.systemNotifications
   */
  export type User$systemNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemNotification
     */
    select?: SystemNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemNotification
     */
    omit?: SystemNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemNotificationInclude<ExtArgs> | null
    where?: SystemNotificationWhereInput
    orderBy?: SystemNotificationOrderByWithRelationInput | SystemNotificationOrderByWithRelationInput[]
    cursor?: SystemNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SystemNotificationScalarFieldEnum | SystemNotificationScalarFieldEnum[]
  }

  /**
   * User.verifiedTransactions
   */
  export type User$verifiedTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    where?: PaymentTransactionWhereInput
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    cursor?: PaymentTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * User.unitActions
   */
  export type User$unitActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitHistory
     */
    select?: UnitHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitHistory
     */
    omit?: UnitHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitHistoryInclude<ExtArgs> | null
    where?: UnitHistoryWhereInput
    orderBy?: UnitHistoryOrderByWithRelationInput | UnitHistoryOrderByWithRelationInput[]
    cursor?: UnitHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitHistoryScalarFieldEnum | UnitHistoryScalarFieldEnum[]
  }

  /**
   * User.aiActionApprovals
   */
  export type User$aiActionApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAction
     */
    select?: AiActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAction
     */
    omit?: AiActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiActionInclude<ExtArgs> | null
    where?: AiActionWhereInput
    orderBy?: AiActionOrderByWithRelationInput | AiActionOrderByWithRelationInput[]
    cursor?: AiActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiActionScalarFieldEnum | AiActionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model ChatGroup
   */

  export type AggregateChatGroup = {
    _count: ChatGroupCountAggregateOutputType | null
    _min: ChatGroupMinAggregateOutputType | null
    _max: ChatGroupMaxAggregateOutputType | null
  }

  export type ChatGroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatGroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatGroupCountAggregateOutputType = {
    id: number
    name: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChatGroupMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatGroupMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatGroupCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChatGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatGroup to aggregate.
     */
    where?: ChatGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatGroups to fetch.
     */
    orderBy?: ChatGroupOrderByWithRelationInput | ChatGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatGroups
    **/
    _count?: true | ChatGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatGroupMaxAggregateInputType
  }

  export type GetChatGroupAggregateType<T extends ChatGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateChatGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatGroup[P]>
      : GetScalarType<T[P], AggregateChatGroup[P]>
  }




  export type ChatGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatGroupWhereInput
    orderBy?: ChatGroupOrderByWithAggregationInput | ChatGroupOrderByWithAggregationInput[]
    by: ChatGroupScalarFieldEnum[] | ChatGroupScalarFieldEnum
    having?: ChatGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatGroupCountAggregateInputType | true
    _min?: ChatGroupMinAggregateInputType
    _max?: ChatGroupMaxAggregateInputType
  }

  export type ChatGroupGroupByOutputType = {
    id: string
    name: string
    type: string
    createdAt: Date
    updatedAt: Date
    _count: ChatGroupCountAggregateOutputType | null
    _min: ChatGroupMinAggregateOutputType | null
    _max: ChatGroupMaxAggregateOutputType | null
  }

  type GetChatGroupGroupByPayload<T extends ChatGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupGroupByOutputType[P]>
        }
      >
    >


  export type ChatGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | ChatGroup$membersArgs<ExtArgs>
    messages?: boolean | ChatGroup$messagesArgs<ExtArgs>
    _count?: boolean | ChatGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatGroup"]>

  export type ChatGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["chatGroup"]>

  export type ChatGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["chatGroup"]>

  export type ChatGroupSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChatGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "createdAt" | "updatedAt", ExtArgs["result"]["chatGroup"]>
  export type ChatGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ChatGroup$membersArgs<ExtArgs>
    messages?: boolean | ChatGroup$messagesArgs<ExtArgs>
    _count?: boolean | ChatGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ChatGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChatGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatGroup"
    objects: {
      members: Prisma.$ChatGroupMemberPayload<ExtArgs>[]
      messages: Prisma.$GroupMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chatGroup"]>
    composites: {}
  }

  type ChatGroupGetPayload<S extends boolean | null | undefined | ChatGroupDefaultArgs> = $Result.GetResult<Prisma.$ChatGroupPayload, S>

  type ChatGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatGroupCountAggregateInputType | true
    }

  export interface ChatGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatGroup'], meta: { name: 'ChatGroup' } }
    /**
     * Find zero or one ChatGroup that matches the filter.
     * @param {ChatGroupFindUniqueArgs} args - Arguments to find a ChatGroup
     * @example
     * // Get one ChatGroup
     * const chatGroup = await prisma.chatGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatGroupFindUniqueArgs>(args: SelectSubset<T, ChatGroupFindUniqueArgs<ExtArgs>>): Prisma__ChatGroupClient<$Result.GetResult<Prisma.$ChatGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatGroupFindUniqueOrThrowArgs} args - Arguments to find a ChatGroup
     * @example
     * // Get one ChatGroup
     * const chatGroup = await prisma.chatGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatGroupClient<$Result.GetResult<Prisma.$ChatGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupFindFirstArgs} args - Arguments to find a ChatGroup
     * @example
     * // Get one ChatGroup
     * const chatGroup = await prisma.chatGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatGroupFindFirstArgs>(args?: SelectSubset<T, ChatGroupFindFirstArgs<ExtArgs>>): Prisma__ChatGroupClient<$Result.GetResult<Prisma.$ChatGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupFindFirstOrThrowArgs} args - Arguments to find a ChatGroup
     * @example
     * // Get one ChatGroup
     * const chatGroup = await prisma.chatGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatGroupClient<$Result.GetResult<Prisma.$ChatGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatGroups
     * const chatGroups = await prisma.chatGroup.findMany()
     * 
     * // Get first 10 ChatGroups
     * const chatGroups = await prisma.chatGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatGroupWithIdOnly = await prisma.chatGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatGroupFindManyArgs>(args?: SelectSubset<T, ChatGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatGroup.
     * @param {ChatGroupCreateArgs} args - Arguments to create a ChatGroup.
     * @example
     * // Create one ChatGroup
     * const ChatGroup = await prisma.chatGroup.create({
     *   data: {
     *     // ... data to create a ChatGroup
     *   }
     * })
     * 
     */
    create<T extends ChatGroupCreateArgs>(args: SelectSubset<T, ChatGroupCreateArgs<ExtArgs>>): Prisma__ChatGroupClient<$Result.GetResult<Prisma.$ChatGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatGroups.
     * @param {ChatGroupCreateManyArgs} args - Arguments to create many ChatGroups.
     * @example
     * // Create many ChatGroups
     * const chatGroup = await prisma.chatGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatGroupCreateManyArgs>(args?: SelectSubset<T, ChatGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatGroups and returns the data saved in the database.
     * @param {ChatGroupCreateManyAndReturnArgs} args - Arguments to create many ChatGroups.
     * @example
     * // Create many ChatGroups
     * const chatGroup = await prisma.chatGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatGroups and only return the `id`
     * const chatGroupWithIdOnly = await prisma.chatGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatGroup.
     * @param {ChatGroupDeleteArgs} args - Arguments to delete one ChatGroup.
     * @example
     * // Delete one ChatGroup
     * const ChatGroup = await prisma.chatGroup.delete({
     *   where: {
     *     // ... filter to delete one ChatGroup
     *   }
     * })
     * 
     */
    delete<T extends ChatGroupDeleteArgs>(args: SelectSubset<T, ChatGroupDeleteArgs<ExtArgs>>): Prisma__ChatGroupClient<$Result.GetResult<Prisma.$ChatGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatGroup.
     * @param {ChatGroupUpdateArgs} args - Arguments to update one ChatGroup.
     * @example
     * // Update one ChatGroup
     * const chatGroup = await prisma.chatGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatGroupUpdateArgs>(args: SelectSubset<T, ChatGroupUpdateArgs<ExtArgs>>): Prisma__ChatGroupClient<$Result.GetResult<Prisma.$ChatGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatGroups.
     * @param {ChatGroupDeleteManyArgs} args - Arguments to filter ChatGroups to delete.
     * @example
     * // Delete a few ChatGroups
     * const { count } = await prisma.chatGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatGroupDeleteManyArgs>(args?: SelectSubset<T, ChatGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatGroups
     * const chatGroup = await prisma.chatGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatGroupUpdateManyArgs>(args: SelectSubset<T, ChatGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatGroups and returns the data updated in the database.
     * @param {ChatGroupUpdateManyAndReturnArgs} args - Arguments to update many ChatGroups.
     * @example
     * // Update many ChatGroups
     * const chatGroup = await prisma.chatGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatGroups and only return the `id`
     * const chatGroupWithIdOnly = await prisma.chatGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatGroup.
     * @param {ChatGroupUpsertArgs} args - Arguments to update or create a ChatGroup.
     * @example
     * // Update or create a ChatGroup
     * const chatGroup = await prisma.chatGroup.upsert({
     *   create: {
     *     // ... data to create a ChatGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatGroup we want to update
     *   }
     * })
     */
    upsert<T extends ChatGroupUpsertArgs>(args: SelectSubset<T, ChatGroupUpsertArgs<ExtArgs>>): Prisma__ChatGroupClient<$Result.GetResult<Prisma.$ChatGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupCountArgs} args - Arguments to filter ChatGroups to count.
     * @example
     * // Count the number of ChatGroups
     * const count = await prisma.chatGroup.count({
     *   where: {
     *     // ... the filter for the ChatGroups we want to count
     *   }
     * })
    **/
    count<T extends ChatGroupCountArgs>(
      args?: Subset<T, ChatGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatGroupAggregateArgs>(args: Subset<T, ChatGroupAggregateArgs>): Prisma.PrismaPromise<GetChatGroupAggregateType<T>>

    /**
     * Group by ChatGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatGroup model
   */
  readonly fields: ChatGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends ChatGroup$membersArgs<ExtArgs> = {}>(args?: Subset<T, ChatGroup$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends ChatGroup$messagesArgs<ExtArgs> = {}>(args?: Subset<T, ChatGroup$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatGroup model
   */
  interface ChatGroupFieldRefs {
    readonly id: FieldRef<"ChatGroup", 'String'>
    readonly name: FieldRef<"ChatGroup", 'String'>
    readonly type: FieldRef<"ChatGroup", 'String'>
    readonly createdAt: FieldRef<"ChatGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"ChatGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatGroup findUnique
   */
  export type ChatGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroup
     */
    select?: ChatGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroup
     */
    omit?: ChatGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupInclude<ExtArgs> | null
    /**
     * Filter, which ChatGroup to fetch.
     */
    where: ChatGroupWhereUniqueInput
  }

  /**
   * ChatGroup findUniqueOrThrow
   */
  export type ChatGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroup
     */
    select?: ChatGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroup
     */
    omit?: ChatGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupInclude<ExtArgs> | null
    /**
     * Filter, which ChatGroup to fetch.
     */
    where: ChatGroupWhereUniqueInput
  }

  /**
   * ChatGroup findFirst
   */
  export type ChatGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroup
     */
    select?: ChatGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroup
     */
    omit?: ChatGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupInclude<ExtArgs> | null
    /**
     * Filter, which ChatGroup to fetch.
     */
    where?: ChatGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatGroups to fetch.
     */
    orderBy?: ChatGroupOrderByWithRelationInput | ChatGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatGroups.
     */
    cursor?: ChatGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatGroups.
     */
    distinct?: ChatGroupScalarFieldEnum | ChatGroupScalarFieldEnum[]
  }

  /**
   * ChatGroup findFirstOrThrow
   */
  export type ChatGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroup
     */
    select?: ChatGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroup
     */
    omit?: ChatGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupInclude<ExtArgs> | null
    /**
     * Filter, which ChatGroup to fetch.
     */
    where?: ChatGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatGroups to fetch.
     */
    orderBy?: ChatGroupOrderByWithRelationInput | ChatGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatGroups.
     */
    cursor?: ChatGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatGroups.
     */
    distinct?: ChatGroupScalarFieldEnum | ChatGroupScalarFieldEnum[]
  }

  /**
   * ChatGroup findMany
   */
  export type ChatGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroup
     */
    select?: ChatGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroup
     */
    omit?: ChatGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupInclude<ExtArgs> | null
    /**
     * Filter, which ChatGroups to fetch.
     */
    where?: ChatGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatGroups to fetch.
     */
    orderBy?: ChatGroupOrderByWithRelationInput | ChatGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatGroups.
     */
    cursor?: ChatGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatGroups.
     */
    skip?: number
    distinct?: ChatGroupScalarFieldEnum | ChatGroupScalarFieldEnum[]
  }

  /**
   * ChatGroup create
   */
  export type ChatGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroup
     */
    select?: ChatGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroup
     */
    omit?: ChatGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatGroup.
     */
    data: XOR<ChatGroupCreateInput, ChatGroupUncheckedCreateInput>
  }

  /**
   * ChatGroup createMany
   */
  export type ChatGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatGroups.
     */
    data: ChatGroupCreateManyInput | ChatGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatGroup createManyAndReturn
   */
  export type ChatGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroup
     */
    select?: ChatGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroup
     */
    omit?: ChatGroupOmit<ExtArgs> | null
    /**
     * The data used to create many ChatGroups.
     */
    data: ChatGroupCreateManyInput | ChatGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatGroup update
   */
  export type ChatGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroup
     */
    select?: ChatGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroup
     */
    omit?: ChatGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatGroup.
     */
    data: XOR<ChatGroupUpdateInput, ChatGroupUncheckedUpdateInput>
    /**
     * Choose, which ChatGroup to update.
     */
    where: ChatGroupWhereUniqueInput
  }

  /**
   * ChatGroup updateMany
   */
  export type ChatGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatGroups.
     */
    data: XOR<ChatGroupUpdateManyMutationInput, ChatGroupUncheckedUpdateManyInput>
    /**
     * Filter which ChatGroups to update
     */
    where?: ChatGroupWhereInput
    /**
     * Limit how many ChatGroups to update.
     */
    limit?: number
  }

  /**
   * ChatGroup updateManyAndReturn
   */
  export type ChatGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroup
     */
    select?: ChatGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroup
     */
    omit?: ChatGroupOmit<ExtArgs> | null
    /**
     * The data used to update ChatGroups.
     */
    data: XOR<ChatGroupUpdateManyMutationInput, ChatGroupUncheckedUpdateManyInput>
    /**
     * Filter which ChatGroups to update
     */
    where?: ChatGroupWhereInput
    /**
     * Limit how many ChatGroups to update.
     */
    limit?: number
  }

  /**
   * ChatGroup upsert
   */
  export type ChatGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroup
     */
    select?: ChatGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroup
     */
    omit?: ChatGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatGroup to update in case it exists.
     */
    where: ChatGroupWhereUniqueInput
    /**
     * In case the ChatGroup found by the `where` argument doesn't exist, create a new ChatGroup with this data.
     */
    create: XOR<ChatGroupCreateInput, ChatGroupUncheckedCreateInput>
    /**
     * In case the ChatGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatGroupUpdateInput, ChatGroupUncheckedUpdateInput>
  }

  /**
   * ChatGroup delete
   */
  export type ChatGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroup
     */
    select?: ChatGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroup
     */
    omit?: ChatGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupInclude<ExtArgs> | null
    /**
     * Filter which ChatGroup to delete.
     */
    where: ChatGroupWhereUniqueInput
  }

  /**
   * ChatGroup deleteMany
   */
  export type ChatGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatGroups to delete
     */
    where?: ChatGroupWhereInput
    /**
     * Limit how many ChatGroups to delete.
     */
    limit?: number
  }

  /**
   * ChatGroup.members
   */
  export type ChatGroup$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberInclude<ExtArgs> | null
    where?: ChatGroupMemberWhereInput
    orderBy?: ChatGroupMemberOrderByWithRelationInput | ChatGroupMemberOrderByWithRelationInput[]
    cursor?: ChatGroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatGroupMemberScalarFieldEnum | ChatGroupMemberScalarFieldEnum[]
  }

  /**
   * ChatGroup.messages
   */
  export type ChatGroup$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessage
     */
    select?: GroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessage
     */
    omit?: GroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageInclude<ExtArgs> | null
    where?: GroupMessageWhereInput
    orderBy?: GroupMessageOrderByWithRelationInput | GroupMessageOrderByWithRelationInput[]
    cursor?: GroupMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMessageScalarFieldEnum | GroupMessageScalarFieldEnum[]
  }

  /**
   * ChatGroup without action
   */
  export type ChatGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroup
     */
    select?: ChatGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroup
     */
    omit?: ChatGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupInclude<ExtArgs> | null
  }


  /**
   * Model ChatGroupMember
   */

  export type AggregateChatGroupMember = {
    _count: ChatGroupMemberCountAggregateOutputType | null
    _min: ChatGroupMemberMinAggregateOutputType | null
    _max: ChatGroupMemberMaxAggregateOutputType | null
  }

  export type ChatGroupMemberMinAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
  }

  export type ChatGroupMemberMaxAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
  }

  export type ChatGroupMemberCountAggregateOutputType = {
    id: number
    groupId: number
    userId: number
    role: number
    joinedAt: number
    _all: number
  }


  export type ChatGroupMemberMinAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type ChatGroupMemberMaxAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type ChatGroupMemberCountAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    role?: true
    joinedAt?: true
    _all?: true
  }

  export type ChatGroupMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatGroupMember to aggregate.
     */
    where?: ChatGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatGroupMembers to fetch.
     */
    orderBy?: ChatGroupMemberOrderByWithRelationInput | ChatGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatGroupMembers
    **/
    _count?: true | ChatGroupMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatGroupMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatGroupMemberMaxAggregateInputType
  }

  export type GetChatGroupMemberAggregateType<T extends ChatGroupMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateChatGroupMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatGroupMember[P]>
      : GetScalarType<T[P], AggregateChatGroupMember[P]>
  }




  export type ChatGroupMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatGroupMemberWhereInput
    orderBy?: ChatGroupMemberOrderByWithAggregationInput | ChatGroupMemberOrderByWithAggregationInput[]
    by: ChatGroupMemberScalarFieldEnum[] | ChatGroupMemberScalarFieldEnum
    having?: ChatGroupMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatGroupMemberCountAggregateInputType | true
    _min?: ChatGroupMemberMinAggregateInputType
    _max?: ChatGroupMemberMaxAggregateInputType
  }

  export type ChatGroupMemberGroupByOutputType = {
    id: string
    groupId: string
    userId: string
    role: string
    joinedAt: Date
    _count: ChatGroupMemberCountAggregateOutputType | null
    _min: ChatGroupMemberMinAggregateOutputType | null
    _max: ChatGroupMemberMaxAggregateOutputType | null
  }

  type GetChatGroupMemberGroupByPayload<T extends ChatGroupMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupMemberGroupByOutputType[P]>
        }
      >
    >


  export type ChatGroupMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    group?: boolean | ChatGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatGroupMember"]>

  export type ChatGroupMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    group?: boolean | ChatGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatGroupMember"]>

  export type ChatGroupMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    group?: boolean | ChatGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatGroupMember"]>

  export type ChatGroupMemberSelectScalar = {
    id?: boolean
    groupId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
  }

  export type ChatGroupMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupId" | "userId" | "role" | "joinedAt", ExtArgs["result"]["chatGroupMember"]>
  export type ChatGroupMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | ChatGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChatGroupMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | ChatGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChatGroupMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | ChatGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatGroupMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatGroupMember"
    objects: {
      group: Prisma.$ChatGroupPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      groupId: string
      userId: string
      role: string
      joinedAt: Date
    }, ExtArgs["result"]["chatGroupMember"]>
    composites: {}
  }

  type ChatGroupMemberGetPayload<S extends boolean | null | undefined | ChatGroupMemberDefaultArgs> = $Result.GetResult<Prisma.$ChatGroupMemberPayload, S>

  type ChatGroupMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatGroupMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatGroupMemberCountAggregateInputType | true
    }

  export interface ChatGroupMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatGroupMember'], meta: { name: 'ChatGroupMember' } }
    /**
     * Find zero or one ChatGroupMember that matches the filter.
     * @param {ChatGroupMemberFindUniqueArgs} args - Arguments to find a ChatGroupMember
     * @example
     * // Get one ChatGroupMember
     * const chatGroupMember = await prisma.chatGroupMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatGroupMemberFindUniqueArgs>(args: SelectSubset<T, ChatGroupMemberFindUniqueArgs<ExtArgs>>): Prisma__ChatGroupMemberClient<$Result.GetResult<Prisma.$ChatGroupMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatGroupMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatGroupMemberFindUniqueOrThrowArgs} args - Arguments to find a ChatGroupMember
     * @example
     * // Get one ChatGroupMember
     * const chatGroupMember = await prisma.chatGroupMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatGroupMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatGroupMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatGroupMemberClient<$Result.GetResult<Prisma.$ChatGroupMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatGroupMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupMemberFindFirstArgs} args - Arguments to find a ChatGroupMember
     * @example
     * // Get one ChatGroupMember
     * const chatGroupMember = await prisma.chatGroupMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatGroupMemberFindFirstArgs>(args?: SelectSubset<T, ChatGroupMemberFindFirstArgs<ExtArgs>>): Prisma__ChatGroupMemberClient<$Result.GetResult<Prisma.$ChatGroupMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatGroupMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupMemberFindFirstOrThrowArgs} args - Arguments to find a ChatGroupMember
     * @example
     * // Get one ChatGroupMember
     * const chatGroupMember = await prisma.chatGroupMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatGroupMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatGroupMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatGroupMemberClient<$Result.GetResult<Prisma.$ChatGroupMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatGroupMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatGroupMembers
     * const chatGroupMembers = await prisma.chatGroupMember.findMany()
     * 
     * // Get first 10 ChatGroupMembers
     * const chatGroupMembers = await prisma.chatGroupMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatGroupMemberWithIdOnly = await prisma.chatGroupMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatGroupMemberFindManyArgs>(args?: SelectSubset<T, ChatGroupMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatGroupMember.
     * @param {ChatGroupMemberCreateArgs} args - Arguments to create a ChatGroupMember.
     * @example
     * // Create one ChatGroupMember
     * const ChatGroupMember = await prisma.chatGroupMember.create({
     *   data: {
     *     // ... data to create a ChatGroupMember
     *   }
     * })
     * 
     */
    create<T extends ChatGroupMemberCreateArgs>(args: SelectSubset<T, ChatGroupMemberCreateArgs<ExtArgs>>): Prisma__ChatGroupMemberClient<$Result.GetResult<Prisma.$ChatGroupMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatGroupMembers.
     * @param {ChatGroupMemberCreateManyArgs} args - Arguments to create many ChatGroupMembers.
     * @example
     * // Create many ChatGroupMembers
     * const chatGroupMember = await prisma.chatGroupMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatGroupMemberCreateManyArgs>(args?: SelectSubset<T, ChatGroupMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatGroupMembers and returns the data saved in the database.
     * @param {ChatGroupMemberCreateManyAndReturnArgs} args - Arguments to create many ChatGroupMembers.
     * @example
     * // Create many ChatGroupMembers
     * const chatGroupMember = await prisma.chatGroupMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatGroupMembers and only return the `id`
     * const chatGroupMemberWithIdOnly = await prisma.chatGroupMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatGroupMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatGroupMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatGroupMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatGroupMember.
     * @param {ChatGroupMemberDeleteArgs} args - Arguments to delete one ChatGroupMember.
     * @example
     * // Delete one ChatGroupMember
     * const ChatGroupMember = await prisma.chatGroupMember.delete({
     *   where: {
     *     // ... filter to delete one ChatGroupMember
     *   }
     * })
     * 
     */
    delete<T extends ChatGroupMemberDeleteArgs>(args: SelectSubset<T, ChatGroupMemberDeleteArgs<ExtArgs>>): Prisma__ChatGroupMemberClient<$Result.GetResult<Prisma.$ChatGroupMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatGroupMember.
     * @param {ChatGroupMemberUpdateArgs} args - Arguments to update one ChatGroupMember.
     * @example
     * // Update one ChatGroupMember
     * const chatGroupMember = await prisma.chatGroupMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatGroupMemberUpdateArgs>(args: SelectSubset<T, ChatGroupMemberUpdateArgs<ExtArgs>>): Prisma__ChatGroupMemberClient<$Result.GetResult<Prisma.$ChatGroupMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatGroupMembers.
     * @param {ChatGroupMemberDeleteManyArgs} args - Arguments to filter ChatGroupMembers to delete.
     * @example
     * // Delete a few ChatGroupMembers
     * const { count } = await prisma.chatGroupMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatGroupMemberDeleteManyArgs>(args?: SelectSubset<T, ChatGroupMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatGroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatGroupMembers
     * const chatGroupMember = await prisma.chatGroupMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatGroupMemberUpdateManyArgs>(args: SelectSubset<T, ChatGroupMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatGroupMembers and returns the data updated in the database.
     * @param {ChatGroupMemberUpdateManyAndReturnArgs} args - Arguments to update many ChatGroupMembers.
     * @example
     * // Update many ChatGroupMembers
     * const chatGroupMember = await prisma.chatGroupMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatGroupMembers and only return the `id`
     * const chatGroupMemberWithIdOnly = await prisma.chatGroupMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatGroupMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatGroupMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatGroupMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatGroupMember.
     * @param {ChatGroupMemberUpsertArgs} args - Arguments to update or create a ChatGroupMember.
     * @example
     * // Update or create a ChatGroupMember
     * const chatGroupMember = await prisma.chatGroupMember.upsert({
     *   create: {
     *     // ... data to create a ChatGroupMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatGroupMember we want to update
     *   }
     * })
     */
    upsert<T extends ChatGroupMemberUpsertArgs>(args: SelectSubset<T, ChatGroupMemberUpsertArgs<ExtArgs>>): Prisma__ChatGroupMemberClient<$Result.GetResult<Prisma.$ChatGroupMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatGroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupMemberCountArgs} args - Arguments to filter ChatGroupMembers to count.
     * @example
     * // Count the number of ChatGroupMembers
     * const count = await prisma.chatGroupMember.count({
     *   where: {
     *     // ... the filter for the ChatGroupMembers we want to count
     *   }
     * })
    **/
    count<T extends ChatGroupMemberCountArgs>(
      args?: Subset<T, ChatGroupMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatGroupMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatGroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatGroupMemberAggregateArgs>(args: Subset<T, ChatGroupMemberAggregateArgs>): Prisma.PrismaPromise<GetChatGroupMemberAggregateType<T>>

    /**
     * Group by ChatGroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupMemberGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatGroupMember model
   */
  readonly fields: ChatGroupMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatGroupMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatGroupMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends ChatGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatGroupDefaultArgs<ExtArgs>>): Prisma__ChatGroupClient<$Result.GetResult<Prisma.$ChatGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatGroupMember model
   */
  interface ChatGroupMemberFieldRefs {
    readonly id: FieldRef<"ChatGroupMember", 'String'>
    readonly groupId: FieldRef<"ChatGroupMember", 'String'>
    readonly userId: FieldRef<"ChatGroupMember", 'String'>
    readonly role: FieldRef<"ChatGroupMember", 'String'>
    readonly joinedAt: FieldRef<"ChatGroupMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatGroupMember findUnique
   */
  export type ChatGroupMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChatGroupMember to fetch.
     */
    where: ChatGroupMemberWhereUniqueInput
  }

  /**
   * ChatGroupMember findUniqueOrThrow
   */
  export type ChatGroupMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChatGroupMember to fetch.
     */
    where: ChatGroupMemberWhereUniqueInput
  }

  /**
   * ChatGroupMember findFirst
   */
  export type ChatGroupMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChatGroupMember to fetch.
     */
    where?: ChatGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatGroupMembers to fetch.
     */
    orderBy?: ChatGroupMemberOrderByWithRelationInput | ChatGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatGroupMembers.
     */
    cursor?: ChatGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatGroupMembers.
     */
    distinct?: ChatGroupMemberScalarFieldEnum | ChatGroupMemberScalarFieldEnum[]
  }

  /**
   * ChatGroupMember findFirstOrThrow
   */
  export type ChatGroupMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChatGroupMember to fetch.
     */
    where?: ChatGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatGroupMembers to fetch.
     */
    orderBy?: ChatGroupMemberOrderByWithRelationInput | ChatGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatGroupMembers.
     */
    cursor?: ChatGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatGroupMembers.
     */
    distinct?: ChatGroupMemberScalarFieldEnum | ChatGroupMemberScalarFieldEnum[]
  }

  /**
   * ChatGroupMember findMany
   */
  export type ChatGroupMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChatGroupMembers to fetch.
     */
    where?: ChatGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatGroupMembers to fetch.
     */
    orderBy?: ChatGroupMemberOrderByWithRelationInput | ChatGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatGroupMembers.
     */
    cursor?: ChatGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatGroupMembers.
     */
    skip?: number
    distinct?: ChatGroupMemberScalarFieldEnum | ChatGroupMemberScalarFieldEnum[]
  }

  /**
   * ChatGroupMember create
   */
  export type ChatGroupMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatGroupMember.
     */
    data: XOR<ChatGroupMemberCreateInput, ChatGroupMemberUncheckedCreateInput>
  }

  /**
   * ChatGroupMember createMany
   */
  export type ChatGroupMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatGroupMembers.
     */
    data: ChatGroupMemberCreateManyInput | ChatGroupMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatGroupMember createManyAndReturn
   */
  export type ChatGroupMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * The data used to create many ChatGroupMembers.
     */
    data: ChatGroupMemberCreateManyInput | ChatGroupMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatGroupMember update
   */
  export type ChatGroupMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatGroupMember.
     */
    data: XOR<ChatGroupMemberUpdateInput, ChatGroupMemberUncheckedUpdateInput>
    /**
     * Choose, which ChatGroupMember to update.
     */
    where: ChatGroupMemberWhereUniqueInput
  }

  /**
   * ChatGroupMember updateMany
   */
  export type ChatGroupMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatGroupMembers.
     */
    data: XOR<ChatGroupMemberUpdateManyMutationInput, ChatGroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which ChatGroupMembers to update
     */
    where?: ChatGroupMemberWhereInput
    /**
     * Limit how many ChatGroupMembers to update.
     */
    limit?: number
  }

  /**
   * ChatGroupMember updateManyAndReturn
   */
  export type ChatGroupMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * The data used to update ChatGroupMembers.
     */
    data: XOR<ChatGroupMemberUpdateManyMutationInput, ChatGroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which ChatGroupMembers to update
     */
    where?: ChatGroupMemberWhereInput
    /**
     * Limit how many ChatGroupMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatGroupMember upsert
   */
  export type ChatGroupMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatGroupMember to update in case it exists.
     */
    where: ChatGroupMemberWhereUniqueInput
    /**
     * In case the ChatGroupMember found by the `where` argument doesn't exist, create a new ChatGroupMember with this data.
     */
    create: XOR<ChatGroupMemberCreateInput, ChatGroupMemberUncheckedCreateInput>
    /**
     * In case the ChatGroupMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatGroupMemberUpdateInput, ChatGroupMemberUncheckedUpdateInput>
  }

  /**
   * ChatGroupMember delete
   */
  export type ChatGroupMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberInclude<ExtArgs> | null
    /**
     * Filter which ChatGroupMember to delete.
     */
    where: ChatGroupMemberWhereUniqueInput
  }

  /**
   * ChatGroupMember deleteMany
   */
  export type ChatGroupMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatGroupMembers to delete
     */
    where?: ChatGroupMemberWhereInput
    /**
     * Limit how many ChatGroupMembers to delete.
     */
    limit?: number
  }

  /**
   * ChatGroupMember without action
   */
  export type ChatGroupMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatGroupMember
     */
    select?: ChatGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatGroupMember
     */
    omit?: ChatGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatGroupMemberInclude<ExtArgs> | null
  }


  /**
   * Model GroupMessage
   */

  export type AggregateGroupMessage = {
    _count: GroupMessageCountAggregateOutputType | null
    _min: GroupMessageMinAggregateOutputType | null
    _max: GroupMessageMaxAggregateOutputType | null
  }

  export type GroupMessageMinAggregateOutputType = {
    id: string | null
    groupId: string | null
    senderId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type GroupMessageMaxAggregateOutputType = {
    id: string | null
    groupId: string | null
    senderId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type GroupMessageCountAggregateOutputType = {
    id: number
    groupId: number
    senderId: number
    content: number
    createdAt: number
    _all: number
  }


  export type GroupMessageMinAggregateInputType = {
    id?: true
    groupId?: true
    senderId?: true
    content?: true
    createdAt?: true
  }

  export type GroupMessageMaxAggregateInputType = {
    id?: true
    groupId?: true
    senderId?: true
    content?: true
    createdAt?: true
  }

  export type GroupMessageCountAggregateInputType = {
    id?: true
    groupId?: true
    senderId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type GroupMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMessage to aggregate.
     */
    where?: GroupMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMessages to fetch.
     */
    orderBy?: GroupMessageOrderByWithRelationInput | GroupMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupMessages
    **/
    _count?: true | GroupMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMessageMaxAggregateInputType
  }

  export type GetGroupMessageAggregateType<T extends GroupMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupMessage[P]>
      : GetScalarType<T[P], AggregateGroupMessage[P]>
  }




  export type GroupMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMessageWhereInput
    orderBy?: GroupMessageOrderByWithAggregationInput | GroupMessageOrderByWithAggregationInput[]
    by: GroupMessageScalarFieldEnum[] | GroupMessageScalarFieldEnum
    having?: GroupMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupMessageCountAggregateInputType | true
    _min?: GroupMessageMinAggregateInputType
    _max?: GroupMessageMaxAggregateInputType
  }

  export type GroupMessageGroupByOutputType = {
    id: string
    groupId: string
    senderId: string
    content: string
    createdAt: Date
    _count: GroupMessageCountAggregateOutputType | null
    _min: GroupMessageMinAggregateOutputType | null
    _max: GroupMessageMaxAggregateOutputType | null
  }

  type GetGroupMessageGroupByPayload<T extends GroupMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupMessageGroupByOutputType[P]>
            : GetScalarType<T[P], GroupMessageGroupByOutputType[P]>
        }
      >
    >


  export type GroupMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    senderId?: boolean
    content?: boolean
    createdAt?: boolean
    group?: boolean | ChatGroupDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMessage"]>

  export type GroupMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    senderId?: boolean
    content?: boolean
    createdAt?: boolean
    group?: boolean | ChatGroupDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMessage"]>

  export type GroupMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    senderId?: boolean
    content?: boolean
    createdAt?: boolean
    group?: boolean | ChatGroupDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMessage"]>

  export type GroupMessageSelectScalar = {
    id?: boolean
    groupId?: boolean
    senderId?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type GroupMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupId" | "senderId" | "content" | "createdAt", ExtArgs["result"]["groupMessage"]>
  export type GroupMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | ChatGroupDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GroupMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | ChatGroupDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GroupMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | ChatGroupDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GroupMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupMessage"
    objects: {
      group: Prisma.$ChatGroupPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      groupId: string
      senderId: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["groupMessage"]>
    composites: {}
  }

  type GroupMessageGetPayload<S extends boolean | null | undefined | GroupMessageDefaultArgs> = $Result.GetResult<Prisma.$GroupMessagePayload, S>

  type GroupMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupMessageCountAggregateInputType | true
    }

  export interface GroupMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupMessage'], meta: { name: 'GroupMessage' } }
    /**
     * Find zero or one GroupMessage that matches the filter.
     * @param {GroupMessageFindUniqueArgs} args - Arguments to find a GroupMessage
     * @example
     * // Get one GroupMessage
     * const groupMessage = await prisma.groupMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupMessageFindUniqueArgs>(args: SelectSubset<T, GroupMessageFindUniqueArgs<ExtArgs>>): Prisma__GroupMessageClient<$Result.GetResult<Prisma.$GroupMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GroupMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupMessageFindUniqueOrThrowArgs} args - Arguments to find a GroupMessage
     * @example
     * // Get one GroupMessage
     * const groupMessage = await prisma.groupMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupMessageClient<$Result.GetResult<Prisma.$GroupMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessageFindFirstArgs} args - Arguments to find a GroupMessage
     * @example
     * // Get one GroupMessage
     * const groupMessage = await prisma.groupMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupMessageFindFirstArgs>(args?: SelectSubset<T, GroupMessageFindFirstArgs<ExtArgs>>): Prisma__GroupMessageClient<$Result.GetResult<Prisma.$GroupMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessageFindFirstOrThrowArgs} args - Arguments to find a GroupMessage
     * @example
     * // Get one GroupMessage
     * const groupMessage = await prisma.groupMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupMessageClient<$Result.GetResult<Prisma.$GroupMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GroupMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupMessages
     * const groupMessages = await prisma.groupMessage.findMany()
     * 
     * // Get first 10 GroupMessages
     * const groupMessages = await prisma.groupMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupMessageWithIdOnly = await prisma.groupMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupMessageFindManyArgs>(args?: SelectSubset<T, GroupMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GroupMessage.
     * @param {GroupMessageCreateArgs} args - Arguments to create a GroupMessage.
     * @example
     * // Create one GroupMessage
     * const GroupMessage = await prisma.groupMessage.create({
     *   data: {
     *     // ... data to create a GroupMessage
     *   }
     * })
     * 
     */
    create<T extends GroupMessageCreateArgs>(args: SelectSubset<T, GroupMessageCreateArgs<ExtArgs>>): Prisma__GroupMessageClient<$Result.GetResult<Prisma.$GroupMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GroupMessages.
     * @param {GroupMessageCreateManyArgs} args - Arguments to create many GroupMessages.
     * @example
     * // Create many GroupMessages
     * const groupMessage = await prisma.groupMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupMessageCreateManyArgs>(args?: SelectSubset<T, GroupMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupMessages and returns the data saved in the database.
     * @param {GroupMessageCreateManyAndReturnArgs} args - Arguments to create many GroupMessages.
     * @example
     * // Create many GroupMessages
     * const groupMessage = await prisma.groupMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupMessages and only return the `id`
     * const groupMessageWithIdOnly = await prisma.groupMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GroupMessage.
     * @param {GroupMessageDeleteArgs} args - Arguments to delete one GroupMessage.
     * @example
     * // Delete one GroupMessage
     * const GroupMessage = await prisma.groupMessage.delete({
     *   where: {
     *     // ... filter to delete one GroupMessage
     *   }
     * })
     * 
     */
    delete<T extends GroupMessageDeleteArgs>(args: SelectSubset<T, GroupMessageDeleteArgs<ExtArgs>>): Prisma__GroupMessageClient<$Result.GetResult<Prisma.$GroupMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GroupMessage.
     * @param {GroupMessageUpdateArgs} args - Arguments to update one GroupMessage.
     * @example
     * // Update one GroupMessage
     * const groupMessage = await prisma.groupMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupMessageUpdateArgs>(args: SelectSubset<T, GroupMessageUpdateArgs<ExtArgs>>): Prisma__GroupMessageClient<$Result.GetResult<Prisma.$GroupMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GroupMessages.
     * @param {GroupMessageDeleteManyArgs} args - Arguments to filter GroupMessages to delete.
     * @example
     * // Delete a few GroupMessages
     * const { count } = await prisma.groupMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupMessageDeleteManyArgs>(args?: SelectSubset<T, GroupMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupMessages
     * const groupMessage = await prisma.groupMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupMessageUpdateManyArgs>(args: SelectSubset<T, GroupMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMessages and returns the data updated in the database.
     * @param {GroupMessageUpdateManyAndReturnArgs} args - Arguments to update many GroupMessages.
     * @example
     * // Update many GroupMessages
     * const groupMessage = await prisma.groupMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GroupMessages and only return the `id`
     * const groupMessageWithIdOnly = await prisma.groupMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GroupMessage.
     * @param {GroupMessageUpsertArgs} args - Arguments to update or create a GroupMessage.
     * @example
     * // Update or create a GroupMessage
     * const groupMessage = await prisma.groupMessage.upsert({
     *   create: {
     *     // ... data to create a GroupMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupMessage we want to update
     *   }
     * })
     */
    upsert<T extends GroupMessageUpsertArgs>(args: SelectSubset<T, GroupMessageUpsertArgs<ExtArgs>>): Prisma__GroupMessageClient<$Result.GetResult<Prisma.$GroupMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GroupMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessageCountArgs} args - Arguments to filter GroupMessages to count.
     * @example
     * // Count the number of GroupMessages
     * const count = await prisma.groupMessage.count({
     *   where: {
     *     // ... the filter for the GroupMessages we want to count
     *   }
     * })
    **/
    count<T extends GroupMessageCountArgs>(
      args?: Subset<T, GroupMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupMessageAggregateArgs>(args: Subset<T, GroupMessageAggregateArgs>): Prisma.PrismaPromise<GetGroupMessageAggregateType<T>>

    /**
     * Group by GroupMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupMessageGroupByArgs['orderBy'] }
        : { orderBy?: GroupMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupMessage model
   */
  readonly fields: GroupMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends ChatGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatGroupDefaultArgs<ExtArgs>>): Prisma__ChatGroupClient<$Result.GetResult<Prisma.$ChatGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupMessage model
   */
  interface GroupMessageFieldRefs {
    readonly id: FieldRef<"GroupMessage", 'String'>
    readonly groupId: FieldRef<"GroupMessage", 'String'>
    readonly senderId: FieldRef<"GroupMessage", 'String'>
    readonly content: FieldRef<"GroupMessage", 'String'>
    readonly createdAt: FieldRef<"GroupMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GroupMessage findUnique
   */
  export type GroupMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessage
     */
    select?: GroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessage
     */
    omit?: GroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageInclude<ExtArgs> | null
    /**
     * Filter, which GroupMessage to fetch.
     */
    where: GroupMessageWhereUniqueInput
  }

  /**
   * GroupMessage findUniqueOrThrow
   */
  export type GroupMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessage
     */
    select?: GroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessage
     */
    omit?: GroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageInclude<ExtArgs> | null
    /**
     * Filter, which GroupMessage to fetch.
     */
    where: GroupMessageWhereUniqueInput
  }

  /**
   * GroupMessage findFirst
   */
  export type GroupMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessage
     */
    select?: GroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessage
     */
    omit?: GroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageInclude<ExtArgs> | null
    /**
     * Filter, which GroupMessage to fetch.
     */
    where?: GroupMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMessages to fetch.
     */
    orderBy?: GroupMessageOrderByWithRelationInput | GroupMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMessages.
     */
    cursor?: GroupMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMessages.
     */
    distinct?: GroupMessageScalarFieldEnum | GroupMessageScalarFieldEnum[]
  }

  /**
   * GroupMessage findFirstOrThrow
   */
  export type GroupMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessage
     */
    select?: GroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessage
     */
    omit?: GroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageInclude<ExtArgs> | null
    /**
     * Filter, which GroupMessage to fetch.
     */
    where?: GroupMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMessages to fetch.
     */
    orderBy?: GroupMessageOrderByWithRelationInput | GroupMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMessages.
     */
    cursor?: GroupMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMessages.
     */
    distinct?: GroupMessageScalarFieldEnum | GroupMessageScalarFieldEnum[]
  }

  /**
   * GroupMessage findMany
   */
  export type GroupMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessage
     */
    select?: GroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessage
     */
    omit?: GroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageInclude<ExtArgs> | null
    /**
     * Filter, which GroupMessages to fetch.
     */
    where?: GroupMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMessages to fetch.
     */
    orderBy?: GroupMessageOrderByWithRelationInput | GroupMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupMessages.
     */
    cursor?: GroupMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMessages.
     */
    skip?: number
    distinct?: GroupMessageScalarFieldEnum | GroupMessageScalarFieldEnum[]
  }

  /**
   * GroupMessage create
   */
  export type GroupMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessage
     */
    select?: GroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessage
     */
    omit?: GroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupMessage.
     */
    data: XOR<GroupMessageCreateInput, GroupMessageUncheckedCreateInput>
  }

  /**
   * GroupMessage createMany
   */
  export type GroupMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupMessages.
     */
    data: GroupMessageCreateManyInput | GroupMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupMessage createManyAndReturn
   */
  export type GroupMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessage
     */
    select?: GroupMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessage
     */
    omit?: GroupMessageOmit<ExtArgs> | null
    /**
     * The data used to create many GroupMessages.
     */
    data: GroupMessageCreateManyInput | GroupMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMessage update
   */
  export type GroupMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessage
     */
    select?: GroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessage
     */
    omit?: GroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupMessage.
     */
    data: XOR<GroupMessageUpdateInput, GroupMessageUncheckedUpdateInput>
    /**
     * Choose, which GroupMessage to update.
     */
    where: GroupMessageWhereUniqueInput
  }

  /**
   * GroupMessage updateMany
   */
  export type GroupMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupMessages.
     */
    data: XOR<GroupMessageUpdateManyMutationInput, GroupMessageUncheckedUpdateManyInput>
    /**
     * Filter which GroupMessages to update
     */
    where?: GroupMessageWhereInput
    /**
     * Limit how many GroupMessages to update.
     */
    limit?: number
  }

  /**
   * GroupMessage updateManyAndReturn
   */
  export type GroupMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessage
     */
    select?: GroupMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessage
     */
    omit?: GroupMessageOmit<ExtArgs> | null
    /**
     * The data used to update GroupMessages.
     */
    data: XOR<GroupMessageUpdateManyMutationInput, GroupMessageUncheckedUpdateManyInput>
    /**
     * Filter which GroupMessages to update
     */
    where?: GroupMessageWhereInput
    /**
     * Limit how many GroupMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMessage upsert
   */
  export type GroupMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessage
     */
    select?: GroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessage
     */
    omit?: GroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupMessage to update in case it exists.
     */
    where: GroupMessageWhereUniqueInput
    /**
     * In case the GroupMessage found by the `where` argument doesn't exist, create a new GroupMessage with this data.
     */
    create: XOR<GroupMessageCreateInput, GroupMessageUncheckedCreateInput>
    /**
     * In case the GroupMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupMessageUpdateInput, GroupMessageUncheckedUpdateInput>
  }

  /**
   * GroupMessage delete
   */
  export type GroupMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessage
     */
    select?: GroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessage
     */
    omit?: GroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageInclude<ExtArgs> | null
    /**
     * Filter which GroupMessage to delete.
     */
    where: GroupMessageWhereUniqueInput
  }

  /**
   * GroupMessage deleteMany
   */
  export type GroupMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMessages to delete
     */
    where?: GroupMessageWhereInput
    /**
     * Limit how many GroupMessages to delete.
     */
    limit?: number
  }

  /**
   * GroupMessage without action
   */
  export type GroupMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessage
     */
    select?: GroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessage
     */
    omit?: GroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageInclude<ExtArgs> | null
  }


  /**
   * Model SiteSetting
   */

  export type AggregateSiteSetting = {
    _count: SiteSettingCountAggregateOutputType | null
    _min: SiteSettingMinAggregateOutputType | null
    _max: SiteSettingMaxAggregateOutputType | null
  }

  export type SiteSettingMinAggregateOutputType = {
    key: string | null
    section: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SiteSettingMaxAggregateOutputType = {
    key: string | null
    section: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SiteSettingCountAggregateOutputType = {
    key: number
    value: number
    section: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SiteSettingMinAggregateInputType = {
    key?: true
    section?: true
    created_at?: true
    updated_at?: true
  }

  export type SiteSettingMaxAggregateInputType = {
    key?: true
    section?: true
    created_at?: true
    updated_at?: true
  }

  export type SiteSettingCountAggregateInputType = {
    key?: true
    value?: true
    section?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SiteSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteSetting to aggregate.
     */
    where?: SiteSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     */
    orderBy?: SiteSettingOrderByWithRelationInput | SiteSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SiteSettings
    **/
    _count?: true | SiteSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteSettingMaxAggregateInputType
  }

  export type GetSiteSettingAggregateType<T extends SiteSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSiteSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSiteSetting[P]>
      : GetScalarType<T[P], AggregateSiteSetting[P]>
  }




  export type SiteSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteSettingWhereInput
    orderBy?: SiteSettingOrderByWithAggregationInput | SiteSettingOrderByWithAggregationInput[]
    by: SiteSettingScalarFieldEnum[] | SiteSettingScalarFieldEnum
    having?: SiteSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteSettingCountAggregateInputType | true
    _min?: SiteSettingMinAggregateInputType
    _max?: SiteSettingMaxAggregateInputType
  }

  export type SiteSettingGroupByOutputType = {
    key: string
    value: JsonValue | null
    section: string | null
    created_at: Date
    updated_at: Date
    _count: SiteSettingCountAggregateOutputType | null
    _min: SiteSettingMinAggregateOutputType | null
    _max: SiteSettingMaxAggregateOutputType | null
  }

  type GetSiteSettingGroupByPayload<T extends SiteSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteSettingGroupByOutputType[P]>
            : GetScalarType<T[P], SiteSettingGroupByOutputType[P]>
        }
      >
    >


  export type SiteSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    section?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["siteSetting"]>

  export type SiteSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    section?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["siteSetting"]>

  export type SiteSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    section?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["siteSetting"]>

  export type SiteSettingSelectScalar = {
    key?: boolean
    value?: boolean
    section?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type SiteSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "value" | "section" | "created_at" | "updated_at", ExtArgs["result"]["siteSetting"]>

  export type $SiteSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SiteSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      value: Prisma.JsonValue | null
      section: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["siteSetting"]>
    composites: {}
  }

  type SiteSettingGetPayload<S extends boolean | null | undefined | SiteSettingDefaultArgs> = $Result.GetResult<Prisma.$SiteSettingPayload, S>

  type SiteSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SiteSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SiteSettingCountAggregateInputType | true
    }

  export interface SiteSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SiteSetting'], meta: { name: 'SiteSetting' } }
    /**
     * Find zero or one SiteSetting that matches the filter.
     * @param {SiteSettingFindUniqueArgs} args - Arguments to find a SiteSetting
     * @example
     * // Get one SiteSetting
     * const siteSetting = await prisma.siteSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteSettingFindUniqueArgs>(args: SelectSubset<T, SiteSettingFindUniqueArgs<ExtArgs>>): Prisma__SiteSettingClient<$Result.GetResult<Prisma.$SiteSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SiteSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SiteSettingFindUniqueOrThrowArgs} args - Arguments to find a SiteSetting
     * @example
     * // Get one SiteSetting
     * const siteSetting = await prisma.siteSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SiteSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SiteSettingClient<$Result.GetResult<Prisma.$SiteSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingFindFirstArgs} args - Arguments to find a SiteSetting
     * @example
     * // Get one SiteSetting
     * const siteSetting = await prisma.siteSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteSettingFindFirstArgs>(args?: SelectSubset<T, SiteSettingFindFirstArgs<ExtArgs>>): Prisma__SiteSettingClient<$Result.GetResult<Prisma.$SiteSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingFindFirstOrThrowArgs} args - Arguments to find a SiteSetting
     * @example
     * // Get one SiteSetting
     * const siteSetting = await prisma.siteSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SiteSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SiteSettingClient<$Result.GetResult<Prisma.$SiteSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SiteSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SiteSettings
     * const siteSettings = await prisma.siteSetting.findMany()
     * 
     * // Get first 10 SiteSettings
     * const siteSettings = await prisma.siteSetting.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const siteSettingWithKeyOnly = await prisma.siteSetting.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends SiteSettingFindManyArgs>(args?: SelectSubset<T, SiteSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SiteSetting.
     * @param {SiteSettingCreateArgs} args - Arguments to create a SiteSetting.
     * @example
     * // Create one SiteSetting
     * const SiteSetting = await prisma.siteSetting.create({
     *   data: {
     *     // ... data to create a SiteSetting
     *   }
     * })
     * 
     */
    create<T extends SiteSettingCreateArgs>(args: SelectSubset<T, SiteSettingCreateArgs<ExtArgs>>): Prisma__SiteSettingClient<$Result.GetResult<Prisma.$SiteSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SiteSettings.
     * @param {SiteSettingCreateManyArgs} args - Arguments to create many SiteSettings.
     * @example
     * // Create many SiteSettings
     * const siteSetting = await prisma.siteSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SiteSettingCreateManyArgs>(args?: SelectSubset<T, SiteSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SiteSettings and returns the data saved in the database.
     * @param {SiteSettingCreateManyAndReturnArgs} args - Arguments to create many SiteSettings.
     * @example
     * // Create many SiteSettings
     * const siteSetting = await prisma.siteSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SiteSettings and only return the `key`
     * const siteSettingWithKeyOnly = await prisma.siteSetting.createManyAndReturn({
     *   select: { key: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SiteSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SiteSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SiteSetting.
     * @param {SiteSettingDeleteArgs} args - Arguments to delete one SiteSetting.
     * @example
     * // Delete one SiteSetting
     * const SiteSetting = await prisma.siteSetting.delete({
     *   where: {
     *     // ... filter to delete one SiteSetting
     *   }
     * })
     * 
     */
    delete<T extends SiteSettingDeleteArgs>(args: SelectSubset<T, SiteSettingDeleteArgs<ExtArgs>>): Prisma__SiteSettingClient<$Result.GetResult<Prisma.$SiteSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SiteSetting.
     * @param {SiteSettingUpdateArgs} args - Arguments to update one SiteSetting.
     * @example
     * // Update one SiteSetting
     * const siteSetting = await prisma.siteSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SiteSettingUpdateArgs>(args: SelectSubset<T, SiteSettingUpdateArgs<ExtArgs>>): Prisma__SiteSettingClient<$Result.GetResult<Prisma.$SiteSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SiteSettings.
     * @param {SiteSettingDeleteManyArgs} args - Arguments to filter SiteSettings to delete.
     * @example
     * // Delete a few SiteSettings
     * const { count } = await prisma.siteSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SiteSettingDeleteManyArgs>(args?: SelectSubset<T, SiteSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SiteSettings
     * const siteSetting = await prisma.siteSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SiteSettingUpdateManyArgs>(args: SelectSubset<T, SiteSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteSettings and returns the data updated in the database.
     * @param {SiteSettingUpdateManyAndReturnArgs} args - Arguments to update many SiteSettings.
     * @example
     * // Update many SiteSettings
     * const siteSetting = await prisma.siteSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SiteSettings and only return the `key`
     * const siteSettingWithKeyOnly = await prisma.siteSetting.updateManyAndReturn({
     *   select: { key: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SiteSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, SiteSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SiteSetting.
     * @param {SiteSettingUpsertArgs} args - Arguments to update or create a SiteSetting.
     * @example
     * // Update or create a SiteSetting
     * const siteSetting = await prisma.siteSetting.upsert({
     *   create: {
     *     // ... data to create a SiteSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SiteSetting we want to update
     *   }
     * })
     */
    upsert<T extends SiteSettingUpsertArgs>(args: SelectSubset<T, SiteSettingUpsertArgs<ExtArgs>>): Prisma__SiteSettingClient<$Result.GetResult<Prisma.$SiteSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingCountArgs} args - Arguments to filter SiteSettings to count.
     * @example
     * // Count the number of SiteSettings
     * const count = await prisma.siteSetting.count({
     *   where: {
     *     // ... the filter for the SiteSettings we want to count
     *   }
     * })
    **/
    count<T extends SiteSettingCountArgs>(
      args?: Subset<T, SiteSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SiteSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteSettingAggregateArgs>(args: Subset<T, SiteSettingAggregateArgs>): Prisma.PrismaPromise<GetSiteSettingAggregateType<T>>

    /**
     * Group by SiteSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteSettingGroupByArgs['orderBy'] }
        : { orderBy?: SiteSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SiteSetting model
   */
  readonly fields: SiteSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SiteSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SiteSetting model
   */
  interface SiteSettingFieldRefs {
    readonly key: FieldRef<"SiteSetting", 'String'>
    readonly value: FieldRef<"SiteSetting", 'Json'>
    readonly section: FieldRef<"SiteSetting", 'String'>
    readonly created_at: FieldRef<"SiteSetting", 'DateTime'>
    readonly updated_at: FieldRef<"SiteSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SiteSetting findUnique
   */
  export type SiteSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSetting
     */
    select?: SiteSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSetting
     */
    omit?: SiteSettingOmit<ExtArgs> | null
    /**
     * Filter, which SiteSetting to fetch.
     */
    where: SiteSettingWhereUniqueInput
  }

  /**
   * SiteSetting findUniqueOrThrow
   */
  export type SiteSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSetting
     */
    select?: SiteSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSetting
     */
    omit?: SiteSettingOmit<ExtArgs> | null
    /**
     * Filter, which SiteSetting to fetch.
     */
    where: SiteSettingWhereUniqueInput
  }

  /**
   * SiteSetting findFirst
   */
  export type SiteSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSetting
     */
    select?: SiteSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSetting
     */
    omit?: SiteSettingOmit<ExtArgs> | null
    /**
     * Filter, which SiteSetting to fetch.
     */
    where?: SiteSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     */
    orderBy?: SiteSettingOrderByWithRelationInput | SiteSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteSettings.
     */
    cursor?: SiteSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteSettings.
     */
    distinct?: SiteSettingScalarFieldEnum | SiteSettingScalarFieldEnum[]
  }

  /**
   * SiteSetting findFirstOrThrow
   */
  export type SiteSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSetting
     */
    select?: SiteSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSetting
     */
    omit?: SiteSettingOmit<ExtArgs> | null
    /**
     * Filter, which SiteSetting to fetch.
     */
    where?: SiteSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     */
    orderBy?: SiteSettingOrderByWithRelationInput | SiteSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteSettings.
     */
    cursor?: SiteSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteSettings.
     */
    distinct?: SiteSettingScalarFieldEnum | SiteSettingScalarFieldEnum[]
  }

  /**
   * SiteSetting findMany
   */
  export type SiteSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSetting
     */
    select?: SiteSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSetting
     */
    omit?: SiteSettingOmit<ExtArgs> | null
    /**
     * Filter, which SiteSettings to fetch.
     */
    where?: SiteSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     */
    orderBy?: SiteSettingOrderByWithRelationInput | SiteSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SiteSettings.
     */
    cursor?: SiteSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     */
    skip?: number
    distinct?: SiteSettingScalarFieldEnum | SiteSettingScalarFieldEnum[]
  }

  /**
   * SiteSetting create
   */
  export type SiteSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSetting
     */
    select?: SiteSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSetting
     */
    omit?: SiteSettingOmit<ExtArgs> | null
    /**
     * The data needed to create a SiteSetting.
     */
    data: XOR<SiteSettingCreateInput, SiteSettingUncheckedCreateInput>
  }

  /**
   * SiteSetting createMany
   */
  export type SiteSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SiteSettings.
     */
    data: SiteSettingCreateManyInput | SiteSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SiteSetting createManyAndReturn
   */
  export type SiteSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSetting
     */
    select?: SiteSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSetting
     */
    omit?: SiteSettingOmit<ExtArgs> | null
    /**
     * The data used to create many SiteSettings.
     */
    data: SiteSettingCreateManyInput | SiteSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SiteSetting update
   */
  export type SiteSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSetting
     */
    select?: SiteSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSetting
     */
    omit?: SiteSettingOmit<ExtArgs> | null
    /**
     * The data needed to update a SiteSetting.
     */
    data: XOR<SiteSettingUpdateInput, SiteSettingUncheckedUpdateInput>
    /**
     * Choose, which SiteSetting to update.
     */
    where: SiteSettingWhereUniqueInput
  }

  /**
   * SiteSetting updateMany
   */
  export type SiteSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SiteSettings.
     */
    data: XOR<SiteSettingUpdateManyMutationInput, SiteSettingUncheckedUpdateManyInput>
    /**
     * Filter which SiteSettings to update
     */
    where?: SiteSettingWhereInput
    /**
     * Limit how many SiteSettings to update.
     */
    limit?: number
  }

  /**
   * SiteSetting updateManyAndReturn
   */
  export type SiteSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSetting
     */
    select?: SiteSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSetting
     */
    omit?: SiteSettingOmit<ExtArgs> | null
    /**
     * The data used to update SiteSettings.
     */
    data: XOR<SiteSettingUpdateManyMutationInput, SiteSettingUncheckedUpdateManyInput>
    /**
     * Filter which SiteSettings to update
     */
    where?: SiteSettingWhereInput
    /**
     * Limit how many SiteSettings to update.
     */
    limit?: number
  }

  /**
   * SiteSetting upsert
   */
  export type SiteSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSetting
     */
    select?: SiteSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSetting
     */
    omit?: SiteSettingOmit<ExtArgs> | null
    /**
     * The filter to search for the SiteSetting to update in case it exists.
     */
    where: SiteSettingWhereUniqueInput
    /**
     * In case the SiteSetting found by the `where` argument doesn't exist, create a new SiteSetting with this data.
     */
    create: XOR<SiteSettingCreateInput, SiteSettingUncheckedCreateInput>
    /**
     * In case the SiteSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteSettingUpdateInput, SiteSettingUncheckedUpdateInput>
  }

  /**
   * SiteSetting delete
   */
  export type SiteSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSetting
     */
    select?: SiteSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSetting
     */
    omit?: SiteSettingOmit<ExtArgs> | null
    /**
     * Filter which SiteSetting to delete.
     */
    where: SiteSettingWhereUniqueInput
  }

  /**
   * SiteSetting deleteMany
   */
  export type SiteSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteSettings to delete
     */
    where?: SiteSettingWhereInput
    /**
     * Limit how many SiteSettings to delete.
     */
    limit?: number
  }

  /**
   * SiteSetting without action
   */
  export type SiteSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSetting
     */
    select?: SiteSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSetting
     */
    omit?: SiteSettingOmit<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: string | null
    action: string | null
    entity: string | null
    details: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: string | null
    action: string | null
    entity: string | null
    details: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    action: number
    entity: number
    details: number
    createdAt: number
    userId: number
    _all: number
  }


  export type ActivityLogMinAggregateInputType = {
    id?: true
    action?: true
    entity?: true
    details?: true
    createdAt?: true
    userId?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    action?: true
    entity?: true
    details?: true
    createdAt?: true
    userId?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    action?: true
    entity?: true
    details?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: string
    action: string
    entity: string
    details: string | null
    createdAt: Date
    userId: string | null
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entity?: boolean
    details?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entity?: boolean
    details?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entity?: boolean
    details?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    action?: boolean
    entity?: boolean
    details?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type ActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action" | "entity" | "details" | "createdAt" | "userId", ExtArgs["result"]["activityLog"]>
  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }
  export type ActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }
  export type ActivityLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      entity: string
      details: string | null
      createdAt: Date
      userId: string | null
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs and returns the data updated in the database.
     * @param {ActivityLogUpdateManyAndReturnArgs} args - Arguments to update many ActivityLogs.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ActivityLog$userArgs<ExtArgs> = {}>(args?: Subset<T, ActivityLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'String'>
    readonly action: FieldRef<"ActivityLog", 'String'>
    readonly entity: FieldRef<"ActivityLog", 'String'>
    readonly details: FieldRef<"ActivityLog", 'String'>
    readonly createdAt: FieldRef<"ActivityLog", 'DateTime'>
    readonly userId: FieldRef<"ActivityLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog createManyAndReturn
   */
  export type ActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
  }

  /**
   * ActivityLog updateManyAndReturn
   */
  export type ActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * ActivityLog.user
   */
  export type ActivityLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model WorkerAttendance
   */

  export type AggregateWorkerAttendance = {
    _count: WorkerAttendanceCountAggregateOutputType | null
    _min: WorkerAttendanceMinAggregateOutputType | null
    _max: WorkerAttendanceMaxAggregateOutputType | null
  }

  export type WorkerAttendanceMinAggregateOutputType = {
    id: string | null
    workerId: string | null
    date: Date | null
    status: $Enums.attendance_status | null
    checkInTime: Date | null
    checkOutTime: Date | null
    notes: string | null
    createdAt: Date | null
  }

  export type WorkerAttendanceMaxAggregateOutputType = {
    id: string | null
    workerId: string | null
    date: Date | null
    status: $Enums.attendance_status | null
    checkInTime: Date | null
    checkOutTime: Date | null
    notes: string | null
    createdAt: Date | null
  }

  export type WorkerAttendanceCountAggregateOutputType = {
    id: number
    workerId: number
    date: number
    status: number
    checkInTime: number
    checkOutTime: number
    notes: number
    createdAt: number
    _all: number
  }


  export type WorkerAttendanceMinAggregateInputType = {
    id?: true
    workerId?: true
    date?: true
    status?: true
    checkInTime?: true
    checkOutTime?: true
    notes?: true
    createdAt?: true
  }

  export type WorkerAttendanceMaxAggregateInputType = {
    id?: true
    workerId?: true
    date?: true
    status?: true
    checkInTime?: true
    checkOutTime?: true
    notes?: true
    createdAt?: true
  }

  export type WorkerAttendanceCountAggregateInputType = {
    id?: true
    workerId?: true
    date?: true
    status?: true
    checkInTime?: true
    checkOutTime?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type WorkerAttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkerAttendance to aggregate.
     */
    where?: WorkerAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerAttendances to fetch.
     */
    orderBy?: WorkerAttendanceOrderByWithRelationInput | WorkerAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkerAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkerAttendances
    **/
    _count?: true | WorkerAttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkerAttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkerAttendanceMaxAggregateInputType
  }

  export type GetWorkerAttendanceAggregateType<T extends WorkerAttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkerAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkerAttendance[P]>
      : GetScalarType<T[P], AggregateWorkerAttendance[P]>
  }




  export type WorkerAttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerAttendanceWhereInput
    orderBy?: WorkerAttendanceOrderByWithAggregationInput | WorkerAttendanceOrderByWithAggregationInput[]
    by: WorkerAttendanceScalarFieldEnum[] | WorkerAttendanceScalarFieldEnum
    having?: WorkerAttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkerAttendanceCountAggregateInputType | true
    _min?: WorkerAttendanceMinAggregateInputType
    _max?: WorkerAttendanceMaxAggregateInputType
  }

  export type WorkerAttendanceGroupByOutputType = {
    id: string
    workerId: string
    date: Date
    status: $Enums.attendance_status | null
    checkInTime: Date | null
    checkOutTime: Date | null
    notes: string | null
    createdAt: Date | null
    _count: WorkerAttendanceCountAggregateOutputType | null
    _min: WorkerAttendanceMinAggregateOutputType | null
    _max: WorkerAttendanceMaxAggregateOutputType | null
  }

  type GetWorkerAttendanceGroupByPayload<T extends WorkerAttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkerAttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkerAttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkerAttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], WorkerAttendanceGroupByOutputType[P]>
        }
      >
    >


  export type WorkerAttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workerId?: boolean
    date?: boolean
    status?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    notes?: boolean
    createdAt?: boolean
    worker?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workerAttendance"]>

  export type WorkerAttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workerId?: boolean
    date?: boolean
    status?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    notes?: boolean
    createdAt?: boolean
    worker?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workerAttendance"]>

  export type WorkerAttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workerId?: boolean
    date?: boolean
    status?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    notes?: boolean
    createdAt?: boolean
    worker?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workerAttendance"]>

  export type WorkerAttendanceSelectScalar = {
    id?: boolean
    workerId?: boolean
    date?: boolean
    status?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type WorkerAttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workerId" | "date" | "status" | "checkInTime" | "checkOutTime" | "notes" | "createdAt", ExtArgs["result"]["workerAttendance"]>
  export type WorkerAttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    worker?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WorkerAttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    worker?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WorkerAttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    worker?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WorkerAttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkerAttendance"
    objects: {
      worker: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workerId: string
      date: Date
      status: $Enums.attendance_status | null
      checkInTime: Date | null
      checkOutTime: Date | null
      notes: string | null
      createdAt: Date | null
    }, ExtArgs["result"]["workerAttendance"]>
    composites: {}
  }

  type WorkerAttendanceGetPayload<S extends boolean | null | undefined | WorkerAttendanceDefaultArgs> = $Result.GetResult<Prisma.$WorkerAttendancePayload, S>

  type WorkerAttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkerAttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkerAttendanceCountAggregateInputType | true
    }

  export interface WorkerAttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkerAttendance'], meta: { name: 'WorkerAttendance' } }
    /**
     * Find zero or one WorkerAttendance that matches the filter.
     * @param {WorkerAttendanceFindUniqueArgs} args - Arguments to find a WorkerAttendance
     * @example
     * // Get one WorkerAttendance
     * const workerAttendance = await prisma.workerAttendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkerAttendanceFindUniqueArgs>(args: SelectSubset<T, WorkerAttendanceFindUniqueArgs<ExtArgs>>): Prisma__WorkerAttendanceClient<$Result.GetResult<Prisma.$WorkerAttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkerAttendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkerAttendanceFindUniqueOrThrowArgs} args - Arguments to find a WorkerAttendance
     * @example
     * // Get one WorkerAttendance
     * const workerAttendance = await prisma.workerAttendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkerAttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkerAttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkerAttendanceClient<$Result.GetResult<Prisma.$WorkerAttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkerAttendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerAttendanceFindFirstArgs} args - Arguments to find a WorkerAttendance
     * @example
     * // Get one WorkerAttendance
     * const workerAttendance = await prisma.workerAttendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkerAttendanceFindFirstArgs>(args?: SelectSubset<T, WorkerAttendanceFindFirstArgs<ExtArgs>>): Prisma__WorkerAttendanceClient<$Result.GetResult<Prisma.$WorkerAttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkerAttendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerAttendanceFindFirstOrThrowArgs} args - Arguments to find a WorkerAttendance
     * @example
     * // Get one WorkerAttendance
     * const workerAttendance = await prisma.workerAttendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkerAttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkerAttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkerAttendanceClient<$Result.GetResult<Prisma.$WorkerAttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkerAttendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerAttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkerAttendances
     * const workerAttendances = await prisma.workerAttendance.findMany()
     * 
     * // Get first 10 WorkerAttendances
     * const workerAttendances = await prisma.workerAttendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workerAttendanceWithIdOnly = await prisma.workerAttendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkerAttendanceFindManyArgs>(args?: SelectSubset<T, WorkerAttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkerAttendance.
     * @param {WorkerAttendanceCreateArgs} args - Arguments to create a WorkerAttendance.
     * @example
     * // Create one WorkerAttendance
     * const WorkerAttendance = await prisma.workerAttendance.create({
     *   data: {
     *     // ... data to create a WorkerAttendance
     *   }
     * })
     * 
     */
    create<T extends WorkerAttendanceCreateArgs>(args: SelectSubset<T, WorkerAttendanceCreateArgs<ExtArgs>>): Prisma__WorkerAttendanceClient<$Result.GetResult<Prisma.$WorkerAttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkerAttendances.
     * @param {WorkerAttendanceCreateManyArgs} args - Arguments to create many WorkerAttendances.
     * @example
     * // Create many WorkerAttendances
     * const workerAttendance = await prisma.workerAttendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkerAttendanceCreateManyArgs>(args?: SelectSubset<T, WorkerAttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkerAttendances and returns the data saved in the database.
     * @param {WorkerAttendanceCreateManyAndReturnArgs} args - Arguments to create many WorkerAttendances.
     * @example
     * // Create many WorkerAttendances
     * const workerAttendance = await prisma.workerAttendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkerAttendances and only return the `id`
     * const workerAttendanceWithIdOnly = await prisma.workerAttendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkerAttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkerAttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerAttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkerAttendance.
     * @param {WorkerAttendanceDeleteArgs} args - Arguments to delete one WorkerAttendance.
     * @example
     * // Delete one WorkerAttendance
     * const WorkerAttendance = await prisma.workerAttendance.delete({
     *   where: {
     *     // ... filter to delete one WorkerAttendance
     *   }
     * })
     * 
     */
    delete<T extends WorkerAttendanceDeleteArgs>(args: SelectSubset<T, WorkerAttendanceDeleteArgs<ExtArgs>>): Prisma__WorkerAttendanceClient<$Result.GetResult<Prisma.$WorkerAttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkerAttendance.
     * @param {WorkerAttendanceUpdateArgs} args - Arguments to update one WorkerAttendance.
     * @example
     * // Update one WorkerAttendance
     * const workerAttendance = await prisma.workerAttendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkerAttendanceUpdateArgs>(args: SelectSubset<T, WorkerAttendanceUpdateArgs<ExtArgs>>): Prisma__WorkerAttendanceClient<$Result.GetResult<Prisma.$WorkerAttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkerAttendances.
     * @param {WorkerAttendanceDeleteManyArgs} args - Arguments to filter WorkerAttendances to delete.
     * @example
     * // Delete a few WorkerAttendances
     * const { count } = await prisma.workerAttendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkerAttendanceDeleteManyArgs>(args?: SelectSubset<T, WorkerAttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkerAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerAttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkerAttendances
     * const workerAttendance = await prisma.workerAttendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkerAttendanceUpdateManyArgs>(args: SelectSubset<T, WorkerAttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkerAttendances and returns the data updated in the database.
     * @param {WorkerAttendanceUpdateManyAndReturnArgs} args - Arguments to update many WorkerAttendances.
     * @example
     * // Update many WorkerAttendances
     * const workerAttendance = await prisma.workerAttendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkerAttendances and only return the `id`
     * const workerAttendanceWithIdOnly = await prisma.workerAttendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkerAttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkerAttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerAttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkerAttendance.
     * @param {WorkerAttendanceUpsertArgs} args - Arguments to update or create a WorkerAttendance.
     * @example
     * // Update or create a WorkerAttendance
     * const workerAttendance = await prisma.workerAttendance.upsert({
     *   create: {
     *     // ... data to create a WorkerAttendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkerAttendance we want to update
     *   }
     * })
     */
    upsert<T extends WorkerAttendanceUpsertArgs>(args: SelectSubset<T, WorkerAttendanceUpsertArgs<ExtArgs>>): Prisma__WorkerAttendanceClient<$Result.GetResult<Prisma.$WorkerAttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkerAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerAttendanceCountArgs} args - Arguments to filter WorkerAttendances to count.
     * @example
     * // Count the number of WorkerAttendances
     * const count = await prisma.workerAttendance.count({
     *   where: {
     *     // ... the filter for the WorkerAttendances we want to count
     *   }
     * })
    **/
    count<T extends WorkerAttendanceCountArgs>(
      args?: Subset<T, WorkerAttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkerAttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkerAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerAttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkerAttendanceAggregateArgs>(args: Subset<T, WorkerAttendanceAggregateArgs>): Prisma.PrismaPromise<GetWorkerAttendanceAggregateType<T>>

    /**
     * Group by WorkerAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerAttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkerAttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkerAttendanceGroupByArgs['orderBy'] }
        : { orderBy?: WorkerAttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkerAttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkerAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkerAttendance model
   */
  readonly fields: WorkerAttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkerAttendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkerAttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    worker<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkerAttendance model
   */
  interface WorkerAttendanceFieldRefs {
    readonly id: FieldRef<"WorkerAttendance", 'String'>
    readonly workerId: FieldRef<"WorkerAttendance", 'String'>
    readonly date: FieldRef<"WorkerAttendance", 'DateTime'>
    readonly status: FieldRef<"WorkerAttendance", 'attendance_status'>
    readonly checkInTime: FieldRef<"WorkerAttendance", 'DateTime'>
    readonly checkOutTime: FieldRef<"WorkerAttendance", 'DateTime'>
    readonly notes: FieldRef<"WorkerAttendance", 'String'>
    readonly createdAt: FieldRef<"WorkerAttendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkerAttendance findUnique
   */
  export type WorkerAttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAttendance
     */
    select?: WorkerAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAttendance
     */
    omit?: WorkerAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which WorkerAttendance to fetch.
     */
    where: WorkerAttendanceWhereUniqueInput
  }

  /**
   * WorkerAttendance findUniqueOrThrow
   */
  export type WorkerAttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAttendance
     */
    select?: WorkerAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAttendance
     */
    omit?: WorkerAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which WorkerAttendance to fetch.
     */
    where: WorkerAttendanceWhereUniqueInput
  }

  /**
   * WorkerAttendance findFirst
   */
  export type WorkerAttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAttendance
     */
    select?: WorkerAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAttendance
     */
    omit?: WorkerAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which WorkerAttendance to fetch.
     */
    where?: WorkerAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerAttendances to fetch.
     */
    orderBy?: WorkerAttendanceOrderByWithRelationInput | WorkerAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkerAttendances.
     */
    cursor?: WorkerAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkerAttendances.
     */
    distinct?: WorkerAttendanceScalarFieldEnum | WorkerAttendanceScalarFieldEnum[]
  }

  /**
   * WorkerAttendance findFirstOrThrow
   */
  export type WorkerAttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAttendance
     */
    select?: WorkerAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAttendance
     */
    omit?: WorkerAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which WorkerAttendance to fetch.
     */
    where?: WorkerAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerAttendances to fetch.
     */
    orderBy?: WorkerAttendanceOrderByWithRelationInput | WorkerAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkerAttendances.
     */
    cursor?: WorkerAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkerAttendances.
     */
    distinct?: WorkerAttendanceScalarFieldEnum | WorkerAttendanceScalarFieldEnum[]
  }

  /**
   * WorkerAttendance findMany
   */
  export type WorkerAttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAttendance
     */
    select?: WorkerAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAttendance
     */
    omit?: WorkerAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which WorkerAttendances to fetch.
     */
    where?: WorkerAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerAttendances to fetch.
     */
    orderBy?: WorkerAttendanceOrderByWithRelationInput | WorkerAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkerAttendances.
     */
    cursor?: WorkerAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerAttendances.
     */
    skip?: number
    distinct?: WorkerAttendanceScalarFieldEnum | WorkerAttendanceScalarFieldEnum[]
  }

  /**
   * WorkerAttendance create
   */
  export type WorkerAttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAttendance
     */
    select?: WorkerAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAttendance
     */
    omit?: WorkerAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkerAttendance.
     */
    data: XOR<WorkerAttendanceCreateInput, WorkerAttendanceUncheckedCreateInput>
  }

  /**
   * WorkerAttendance createMany
   */
  export type WorkerAttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkerAttendances.
     */
    data: WorkerAttendanceCreateManyInput | WorkerAttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkerAttendance createManyAndReturn
   */
  export type WorkerAttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAttendance
     */
    select?: WorkerAttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAttendance
     */
    omit?: WorkerAttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many WorkerAttendances.
     */
    data: WorkerAttendanceCreateManyInput | WorkerAttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkerAttendance update
   */
  export type WorkerAttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAttendance
     */
    select?: WorkerAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAttendance
     */
    omit?: WorkerAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkerAttendance.
     */
    data: XOR<WorkerAttendanceUpdateInput, WorkerAttendanceUncheckedUpdateInput>
    /**
     * Choose, which WorkerAttendance to update.
     */
    where: WorkerAttendanceWhereUniqueInput
  }

  /**
   * WorkerAttendance updateMany
   */
  export type WorkerAttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkerAttendances.
     */
    data: XOR<WorkerAttendanceUpdateManyMutationInput, WorkerAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which WorkerAttendances to update
     */
    where?: WorkerAttendanceWhereInput
    /**
     * Limit how many WorkerAttendances to update.
     */
    limit?: number
  }

  /**
   * WorkerAttendance updateManyAndReturn
   */
  export type WorkerAttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAttendance
     */
    select?: WorkerAttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAttendance
     */
    omit?: WorkerAttendanceOmit<ExtArgs> | null
    /**
     * The data used to update WorkerAttendances.
     */
    data: XOR<WorkerAttendanceUpdateManyMutationInput, WorkerAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which WorkerAttendances to update
     */
    where?: WorkerAttendanceWhereInput
    /**
     * Limit how many WorkerAttendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkerAttendance upsert
   */
  export type WorkerAttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAttendance
     */
    select?: WorkerAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAttendance
     */
    omit?: WorkerAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkerAttendance to update in case it exists.
     */
    where: WorkerAttendanceWhereUniqueInput
    /**
     * In case the WorkerAttendance found by the `where` argument doesn't exist, create a new WorkerAttendance with this data.
     */
    create: XOR<WorkerAttendanceCreateInput, WorkerAttendanceUncheckedCreateInput>
    /**
     * In case the WorkerAttendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkerAttendanceUpdateInput, WorkerAttendanceUncheckedUpdateInput>
  }

  /**
   * WorkerAttendance delete
   */
  export type WorkerAttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAttendance
     */
    select?: WorkerAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAttendance
     */
    omit?: WorkerAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAttendanceInclude<ExtArgs> | null
    /**
     * Filter which WorkerAttendance to delete.
     */
    where: WorkerAttendanceWhereUniqueInput
  }

  /**
   * WorkerAttendance deleteMany
   */
  export type WorkerAttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkerAttendances to delete
     */
    where?: WorkerAttendanceWhereInput
    /**
     * Limit how many WorkerAttendances to delete.
     */
    limit?: number
  }

  /**
   * WorkerAttendance without action
   */
  export type WorkerAttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAttendance
     */
    select?: WorkerAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAttendance
     */
    omit?: WorkerAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAttendanceInclude<ExtArgs> | null
  }


  /**
   * Model InventorySyncLog
   */

  export type AggregateInventorySyncLog = {
    _count: InventorySyncLogCountAggregateOutputType | null
    _avg: InventorySyncLogAvgAggregateOutputType | null
    _sum: InventorySyncLogSumAggregateOutputType | null
    _min: InventorySyncLogMinAggregateOutputType | null
    _max: InventorySyncLogMaxAggregateOutputType | null
  }

  export type InventorySyncLogAvgAggregateOutputType = {
    oldQuantity: number | null
    newQuantity: number | null
  }

  export type InventorySyncLogSumAggregateOutputType = {
    oldQuantity: number | null
    newQuantity: number | null
  }

  export type InventorySyncLogMinAggregateOutputType = {
    id: string | null
    productId: string | null
    oldQuantity: number | null
    newQuantity: number | null
    updatedBy: string | null
    source: $Enums.inventory_source | null
    conflict: boolean | null
    resolved: boolean | null
    resolvedBy: string | null
    resolvedAt: Date | null
    createdAt: Date | null
  }

  export type InventorySyncLogMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    oldQuantity: number | null
    newQuantity: number | null
    updatedBy: string | null
    source: $Enums.inventory_source | null
    conflict: boolean | null
    resolved: boolean | null
    resolvedBy: string | null
    resolvedAt: Date | null
    createdAt: Date | null
  }

  export type InventorySyncLogCountAggregateOutputType = {
    id: number
    productId: number
    oldQuantity: number
    newQuantity: number
    updatedBy: number
    source: number
    conflict: number
    resolved: number
    resolvedBy: number
    resolvedAt: number
    createdAt: number
    _all: number
  }


  export type InventorySyncLogAvgAggregateInputType = {
    oldQuantity?: true
    newQuantity?: true
  }

  export type InventorySyncLogSumAggregateInputType = {
    oldQuantity?: true
    newQuantity?: true
  }

  export type InventorySyncLogMinAggregateInputType = {
    id?: true
    productId?: true
    oldQuantity?: true
    newQuantity?: true
    updatedBy?: true
    source?: true
    conflict?: true
    resolved?: true
    resolvedBy?: true
    resolvedAt?: true
    createdAt?: true
  }

  export type InventorySyncLogMaxAggregateInputType = {
    id?: true
    productId?: true
    oldQuantity?: true
    newQuantity?: true
    updatedBy?: true
    source?: true
    conflict?: true
    resolved?: true
    resolvedBy?: true
    resolvedAt?: true
    createdAt?: true
  }

  export type InventorySyncLogCountAggregateInputType = {
    id?: true
    productId?: true
    oldQuantity?: true
    newQuantity?: true
    updatedBy?: true
    source?: true
    conflict?: true
    resolved?: true
    resolvedBy?: true
    resolvedAt?: true
    createdAt?: true
    _all?: true
  }

  export type InventorySyncLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventorySyncLog to aggregate.
     */
    where?: InventorySyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventorySyncLogs to fetch.
     */
    orderBy?: InventorySyncLogOrderByWithRelationInput | InventorySyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventorySyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventorySyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventorySyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventorySyncLogs
    **/
    _count?: true | InventorySyncLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventorySyncLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySyncLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventorySyncLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventorySyncLogMaxAggregateInputType
  }

  export type GetInventorySyncLogAggregateType<T extends InventorySyncLogAggregateArgs> = {
        [P in keyof T & keyof AggregateInventorySyncLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventorySyncLog[P]>
      : GetScalarType<T[P], AggregateInventorySyncLog[P]>
  }




  export type InventorySyncLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventorySyncLogWhereInput
    orderBy?: InventorySyncLogOrderByWithAggregationInput | InventorySyncLogOrderByWithAggregationInput[]
    by: InventorySyncLogScalarFieldEnum[] | InventorySyncLogScalarFieldEnum
    having?: InventorySyncLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventorySyncLogCountAggregateInputType | true
    _avg?: InventorySyncLogAvgAggregateInputType
    _sum?: InventorySyncLogSumAggregateInputType
    _min?: InventorySyncLogMinAggregateInputType
    _max?: InventorySyncLogMaxAggregateInputType
  }

  export type InventorySyncLogGroupByOutputType = {
    id: string
    productId: string
    oldQuantity: number
    newQuantity: number
    updatedBy: string
    source: $Enums.inventory_source
    conflict: boolean | null
    resolved: boolean | null
    resolvedBy: string | null
    resolvedAt: Date | null
    createdAt: Date | null
    _count: InventorySyncLogCountAggregateOutputType | null
    _avg: InventorySyncLogAvgAggregateOutputType | null
    _sum: InventorySyncLogSumAggregateOutputType | null
    _min: InventorySyncLogMinAggregateOutputType | null
    _max: InventorySyncLogMaxAggregateOutputType | null
  }

  type GetInventorySyncLogGroupByPayload<T extends InventorySyncLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventorySyncLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventorySyncLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventorySyncLogGroupByOutputType[P]>
            : GetScalarType<T[P], InventorySyncLogGroupByOutputType[P]>
        }
      >
    >


  export type InventorySyncLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    oldQuantity?: boolean
    newQuantity?: boolean
    updatedBy?: boolean
    source?: boolean
    conflict?: boolean
    resolved?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    resolvedByUser?: boolean | InventorySyncLog$resolvedByUserArgs<ExtArgs>
    updatedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventorySyncLog"]>

  export type InventorySyncLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    oldQuantity?: boolean
    newQuantity?: boolean
    updatedBy?: boolean
    source?: boolean
    conflict?: boolean
    resolved?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    resolvedByUser?: boolean | InventorySyncLog$resolvedByUserArgs<ExtArgs>
    updatedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventorySyncLog"]>

  export type InventorySyncLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    oldQuantity?: boolean
    newQuantity?: boolean
    updatedBy?: boolean
    source?: boolean
    conflict?: boolean
    resolved?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    resolvedByUser?: boolean | InventorySyncLog$resolvedByUserArgs<ExtArgs>
    updatedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventorySyncLog"]>

  export type InventorySyncLogSelectScalar = {
    id?: boolean
    productId?: boolean
    oldQuantity?: boolean
    newQuantity?: boolean
    updatedBy?: boolean
    source?: boolean
    conflict?: boolean
    resolved?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
  }

  export type InventorySyncLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "oldQuantity" | "newQuantity" | "updatedBy" | "source" | "conflict" | "resolved" | "resolvedBy" | "resolvedAt" | "createdAt", ExtArgs["result"]["inventorySyncLog"]>
  export type InventorySyncLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    resolvedByUser?: boolean | InventorySyncLog$resolvedByUserArgs<ExtArgs>
    updatedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InventorySyncLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    resolvedByUser?: boolean | InventorySyncLog$resolvedByUserArgs<ExtArgs>
    updatedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InventorySyncLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    resolvedByUser?: boolean | InventorySyncLog$resolvedByUserArgs<ExtArgs>
    updatedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InventorySyncLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventorySyncLog"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      resolvedByUser: Prisma.$UserPayload<ExtArgs> | null
      updatedByUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      oldQuantity: number
      newQuantity: number
      updatedBy: string
      source: $Enums.inventory_source
      conflict: boolean | null
      resolved: boolean | null
      resolvedBy: string | null
      resolvedAt: Date | null
      createdAt: Date | null
    }, ExtArgs["result"]["inventorySyncLog"]>
    composites: {}
  }

  type InventorySyncLogGetPayload<S extends boolean | null | undefined | InventorySyncLogDefaultArgs> = $Result.GetResult<Prisma.$InventorySyncLogPayload, S>

  type InventorySyncLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventorySyncLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventorySyncLogCountAggregateInputType | true
    }

  export interface InventorySyncLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventorySyncLog'], meta: { name: 'InventorySyncLog' } }
    /**
     * Find zero or one InventorySyncLog that matches the filter.
     * @param {InventorySyncLogFindUniqueArgs} args - Arguments to find a InventorySyncLog
     * @example
     * // Get one InventorySyncLog
     * const inventorySyncLog = await prisma.inventorySyncLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventorySyncLogFindUniqueArgs>(args: SelectSubset<T, InventorySyncLogFindUniqueArgs<ExtArgs>>): Prisma__InventorySyncLogClient<$Result.GetResult<Prisma.$InventorySyncLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventorySyncLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventorySyncLogFindUniqueOrThrowArgs} args - Arguments to find a InventorySyncLog
     * @example
     * // Get one InventorySyncLog
     * const inventorySyncLog = await prisma.inventorySyncLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventorySyncLogFindUniqueOrThrowArgs>(args: SelectSubset<T, InventorySyncLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventorySyncLogClient<$Result.GetResult<Prisma.$InventorySyncLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventorySyncLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySyncLogFindFirstArgs} args - Arguments to find a InventorySyncLog
     * @example
     * // Get one InventorySyncLog
     * const inventorySyncLog = await prisma.inventorySyncLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventorySyncLogFindFirstArgs>(args?: SelectSubset<T, InventorySyncLogFindFirstArgs<ExtArgs>>): Prisma__InventorySyncLogClient<$Result.GetResult<Prisma.$InventorySyncLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventorySyncLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySyncLogFindFirstOrThrowArgs} args - Arguments to find a InventorySyncLog
     * @example
     * // Get one InventorySyncLog
     * const inventorySyncLog = await prisma.inventorySyncLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventorySyncLogFindFirstOrThrowArgs>(args?: SelectSubset<T, InventorySyncLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventorySyncLogClient<$Result.GetResult<Prisma.$InventorySyncLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventorySyncLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySyncLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventorySyncLogs
     * const inventorySyncLogs = await prisma.inventorySyncLog.findMany()
     * 
     * // Get first 10 InventorySyncLogs
     * const inventorySyncLogs = await prisma.inventorySyncLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventorySyncLogWithIdOnly = await prisma.inventorySyncLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventorySyncLogFindManyArgs>(args?: SelectSubset<T, InventorySyncLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventorySyncLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventorySyncLog.
     * @param {InventorySyncLogCreateArgs} args - Arguments to create a InventorySyncLog.
     * @example
     * // Create one InventorySyncLog
     * const InventorySyncLog = await prisma.inventorySyncLog.create({
     *   data: {
     *     // ... data to create a InventorySyncLog
     *   }
     * })
     * 
     */
    create<T extends InventorySyncLogCreateArgs>(args: SelectSubset<T, InventorySyncLogCreateArgs<ExtArgs>>): Prisma__InventorySyncLogClient<$Result.GetResult<Prisma.$InventorySyncLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventorySyncLogs.
     * @param {InventorySyncLogCreateManyArgs} args - Arguments to create many InventorySyncLogs.
     * @example
     * // Create many InventorySyncLogs
     * const inventorySyncLog = await prisma.inventorySyncLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventorySyncLogCreateManyArgs>(args?: SelectSubset<T, InventorySyncLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventorySyncLogs and returns the data saved in the database.
     * @param {InventorySyncLogCreateManyAndReturnArgs} args - Arguments to create many InventorySyncLogs.
     * @example
     * // Create many InventorySyncLogs
     * const inventorySyncLog = await prisma.inventorySyncLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventorySyncLogs and only return the `id`
     * const inventorySyncLogWithIdOnly = await prisma.inventorySyncLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventorySyncLogCreateManyAndReturnArgs>(args?: SelectSubset<T, InventorySyncLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventorySyncLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventorySyncLog.
     * @param {InventorySyncLogDeleteArgs} args - Arguments to delete one InventorySyncLog.
     * @example
     * // Delete one InventorySyncLog
     * const InventorySyncLog = await prisma.inventorySyncLog.delete({
     *   where: {
     *     // ... filter to delete one InventorySyncLog
     *   }
     * })
     * 
     */
    delete<T extends InventorySyncLogDeleteArgs>(args: SelectSubset<T, InventorySyncLogDeleteArgs<ExtArgs>>): Prisma__InventorySyncLogClient<$Result.GetResult<Prisma.$InventorySyncLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventorySyncLog.
     * @param {InventorySyncLogUpdateArgs} args - Arguments to update one InventorySyncLog.
     * @example
     * // Update one InventorySyncLog
     * const inventorySyncLog = await prisma.inventorySyncLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventorySyncLogUpdateArgs>(args: SelectSubset<T, InventorySyncLogUpdateArgs<ExtArgs>>): Prisma__InventorySyncLogClient<$Result.GetResult<Prisma.$InventorySyncLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventorySyncLogs.
     * @param {InventorySyncLogDeleteManyArgs} args - Arguments to filter InventorySyncLogs to delete.
     * @example
     * // Delete a few InventorySyncLogs
     * const { count } = await prisma.inventorySyncLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventorySyncLogDeleteManyArgs>(args?: SelectSubset<T, InventorySyncLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventorySyncLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySyncLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventorySyncLogs
     * const inventorySyncLog = await prisma.inventorySyncLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventorySyncLogUpdateManyArgs>(args: SelectSubset<T, InventorySyncLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventorySyncLogs and returns the data updated in the database.
     * @param {InventorySyncLogUpdateManyAndReturnArgs} args - Arguments to update many InventorySyncLogs.
     * @example
     * // Update many InventorySyncLogs
     * const inventorySyncLog = await prisma.inventorySyncLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventorySyncLogs and only return the `id`
     * const inventorySyncLogWithIdOnly = await prisma.inventorySyncLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventorySyncLogUpdateManyAndReturnArgs>(args: SelectSubset<T, InventorySyncLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventorySyncLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventorySyncLog.
     * @param {InventorySyncLogUpsertArgs} args - Arguments to update or create a InventorySyncLog.
     * @example
     * // Update or create a InventorySyncLog
     * const inventorySyncLog = await prisma.inventorySyncLog.upsert({
     *   create: {
     *     // ... data to create a InventorySyncLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventorySyncLog we want to update
     *   }
     * })
     */
    upsert<T extends InventorySyncLogUpsertArgs>(args: SelectSubset<T, InventorySyncLogUpsertArgs<ExtArgs>>): Prisma__InventorySyncLogClient<$Result.GetResult<Prisma.$InventorySyncLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventorySyncLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySyncLogCountArgs} args - Arguments to filter InventorySyncLogs to count.
     * @example
     * // Count the number of InventorySyncLogs
     * const count = await prisma.inventorySyncLog.count({
     *   where: {
     *     // ... the filter for the InventorySyncLogs we want to count
     *   }
     * })
    **/
    count<T extends InventorySyncLogCountArgs>(
      args?: Subset<T, InventorySyncLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventorySyncLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventorySyncLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySyncLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventorySyncLogAggregateArgs>(args: Subset<T, InventorySyncLogAggregateArgs>): Prisma.PrismaPromise<GetInventorySyncLogAggregateType<T>>

    /**
     * Group by InventorySyncLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorySyncLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventorySyncLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventorySyncLogGroupByArgs['orderBy'] }
        : { orderBy?: InventorySyncLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventorySyncLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventorySyncLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventorySyncLog model
   */
  readonly fields: InventorySyncLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventorySyncLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventorySyncLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resolvedByUser<T extends InventorySyncLog$resolvedByUserArgs<ExtArgs> = {}>(args?: Subset<T, InventorySyncLog$resolvedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updatedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventorySyncLog model
   */
  interface InventorySyncLogFieldRefs {
    readonly id: FieldRef<"InventorySyncLog", 'String'>
    readonly productId: FieldRef<"InventorySyncLog", 'String'>
    readonly oldQuantity: FieldRef<"InventorySyncLog", 'Int'>
    readonly newQuantity: FieldRef<"InventorySyncLog", 'Int'>
    readonly updatedBy: FieldRef<"InventorySyncLog", 'String'>
    readonly source: FieldRef<"InventorySyncLog", 'inventory_source'>
    readonly conflict: FieldRef<"InventorySyncLog", 'Boolean'>
    readonly resolved: FieldRef<"InventorySyncLog", 'Boolean'>
    readonly resolvedBy: FieldRef<"InventorySyncLog", 'String'>
    readonly resolvedAt: FieldRef<"InventorySyncLog", 'DateTime'>
    readonly createdAt: FieldRef<"InventorySyncLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventorySyncLog findUnique
   */
  export type InventorySyncLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySyncLog
     */
    select?: InventorySyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySyncLog
     */
    omit?: InventorySyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySyncLogInclude<ExtArgs> | null
    /**
     * Filter, which InventorySyncLog to fetch.
     */
    where: InventorySyncLogWhereUniqueInput
  }

  /**
   * InventorySyncLog findUniqueOrThrow
   */
  export type InventorySyncLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySyncLog
     */
    select?: InventorySyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySyncLog
     */
    omit?: InventorySyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySyncLogInclude<ExtArgs> | null
    /**
     * Filter, which InventorySyncLog to fetch.
     */
    where: InventorySyncLogWhereUniqueInput
  }

  /**
   * InventorySyncLog findFirst
   */
  export type InventorySyncLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySyncLog
     */
    select?: InventorySyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySyncLog
     */
    omit?: InventorySyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySyncLogInclude<ExtArgs> | null
    /**
     * Filter, which InventorySyncLog to fetch.
     */
    where?: InventorySyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventorySyncLogs to fetch.
     */
    orderBy?: InventorySyncLogOrderByWithRelationInput | InventorySyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventorySyncLogs.
     */
    cursor?: InventorySyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventorySyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventorySyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventorySyncLogs.
     */
    distinct?: InventorySyncLogScalarFieldEnum | InventorySyncLogScalarFieldEnum[]
  }

  /**
   * InventorySyncLog findFirstOrThrow
   */
  export type InventorySyncLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySyncLog
     */
    select?: InventorySyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySyncLog
     */
    omit?: InventorySyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySyncLogInclude<ExtArgs> | null
    /**
     * Filter, which InventorySyncLog to fetch.
     */
    where?: InventorySyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventorySyncLogs to fetch.
     */
    orderBy?: InventorySyncLogOrderByWithRelationInput | InventorySyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventorySyncLogs.
     */
    cursor?: InventorySyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventorySyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventorySyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventorySyncLogs.
     */
    distinct?: InventorySyncLogScalarFieldEnum | InventorySyncLogScalarFieldEnum[]
  }

  /**
   * InventorySyncLog findMany
   */
  export type InventorySyncLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySyncLog
     */
    select?: InventorySyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySyncLog
     */
    omit?: InventorySyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySyncLogInclude<ExtArgs> | null
    /**
     * Filter, which InventorySyncLogs to fetch.
     */
    where?: InventorySyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventorySyncLogs to fetch.
     */
    orderBy?: InventorySyncLogOrderByWithRelationInput | InventorySyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventorySyncLogs.
     */
    cursor?: InventorySyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventorySyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventorySyncLogs.
     */
    skip?: number
    distinct?: InventorySyncLogScalarFieldEnum | InventorySyncLogScalarFieldEnum[]
  }

  /**
   * InventorySyncLog create
   */
  export type InventorySyncLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySyncLog
     */
    select?: InventorySyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySyncLog
     */
    omit?: InventorySyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySyncLogInclude<ExtArgs> | null
    /**
     * The data needed to create a InventorySyncLog.
     */
    data: XOR<InventorySyncLogCreateInput, InventorySyncLogUncheckedCreateInput>
  }

  /**
   * InventorySyncLog createMany
   */
  export type InventorySyncLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventorySyncLogs.
     */
    data: InventorySyncLogCreateManyInput | InventorySyncLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventorySyncLog createManyAndReturn
   */
  export type InventorySyncLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySyncLog
     */
    select?: InventorySyncLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySyncLog
     */
    omit?: InventorySyncLogOmit<ExtArgs> | null
    /**
     * The data used to create many InventorySyncLogs.
     */
    data: InventorySyncLogCreateManyInput | InventorySyncLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySyncLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventorySyncLog update
   */
  export type InventorySyncLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySyncLog
     */
    select?: InventorySyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySyncLog
     */
    omit?: InventorySyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySyncLogInclude<ExtArgs> | null
    /**
     * The data needed to update a InventorySyncLog.
     */
    data: XOR<InventorySyncLogUpdateInput, InventorySyncLogUncheckedUpdateInput>
    /**
     * Choose, which InventorySyncLog to update.
     */
    where: InventorySyncLogWhereUniqueInput
  }

  /**
   * InventorySyncLog updateMany
   */
  export type InventorySyncLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventorySyncLogs.
     */
    data: XOR<InventorySyncLogUpdateManyMutationInput, InventorySyncLogUncheckedUpdateManyInput>
    /**
     * Filter which InventorySyncLogs to update
     */
    where?: InventorySyncLogWhereInput
    /**
     * Limit how many InventorySyncLogs to update.
     */
    limit?: number
  }

  /**
   * InventorySyncLog updateManyAndReturn
   */
  export type InventorySyncLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySyncLog
     */
    select?: InventorySyncLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySyncLog
     */
    omit?: InventorySyncLogOmit<ExtArgs> | null
    /**
     * The data used to update InventorySyncLogs.
     */
    data: XOR<InventorySyncLogUpdateManyMutationInput, InventorySyncLogUncheckedUpdateManyInput>
    /**
     * Filter which InventorySyncLogs to update
     */
    where?: InventorySyncLogWhereInput
    /**
     * Limit how many InventorySyncLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySyncLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventorySyncLog upsert
   */
  export type InventorySyncLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySyncLog
     */
    select?: InventorySyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySyncLog
     */
    omit?: InventorySyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySyncLogInclude<ExtArgs> | null
    /**
     * The filter to search for the InventorySyncLog to update in case it exists.
     */
    where: InventorySyncLogWhereUniqueInput
    /**
     * In case the InventorySyncLog found by the `where` argument doesn't exist, create a new InventorySyncLog with this data.
     */
    create: XOR<InventorySyncLogCreateInput, InventorySyncLogUncheckedCreateInput>
    /**
     * In case the InventorySyncLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventorySyncLogUpdateInput, InventorySyncLogUncheckedUpdateInput>
  }

  /**
   * InventorySyncLog delete
   */
  export type InventorySyncLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySyncLog
     */
    select?: InventorySyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySyncLog
     */
    omit?: InventorySyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySyncLogInclude<ExtArgs> | null
    /**
     * Filter which InventorySyncLog to delete.
     */
    where: InventorySyncLogWhereUniqueInput
  }

  /**
   * InventorySyncLog deleteMany
   */
  export type InventorySyncLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventorySyncLogs to delete
     */
    where?: InventorySyncLogWhereInput
    /**
     * Limit how many InventorySyncLogs to delete.
     */
    limit?: number
  }

  /**
   * InventorySyncLog.resolvedByUser
   */
  export type InventorySyncLog$resolvedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * InventorySyncLog without action
   */
  export type InventorySyncLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventorySyncLog
     */
    select?: InventorySyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventorySyncLog
     */
    omit?: InventorySyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventorySyncLogInclude<ExtArgs> | null
  }


  /**
   * Model WorkerNotification
   */

  export type AggregateWorkerNotification = {
    _count: WorkerNotificationCountAggregateOutputType | null
    _min: WorkerNotificationMinAggregateOutputType | null
    _max: WorkerNotificationMaxAggregateOutputType | null
  }

  export type WorkerNotificationMinAggregateOutputType = {
    id: string | null
    workerId: string | null
    fromAdminId: string | null
    type: string | null
    title: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type WorkerNotificationMaxAggregateOutputType = {
    id: string | null
    workerId: string | null
    fromAdminId: string | null
    type: string | null
    title: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type WorkerNotificationCountAggregateOutputType = {
    id: number
    workerId: number
    fromAdminId: number
    type: number
    title: number
    message: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type WorkerNotificationMinAggregateInputType = {
    id?: true
    workerId?: true
    fromAdminId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
  }

  export type WorkerNotificationMaxAggregateInputType = {
    id?: true
    workerId?: true
    fromAdminId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
  }

  export type WorkerNotificationCountAggregateInputType = {
    id?: true
    workerId?: true
    fromAdminId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type WorkerNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkerNotification to aggregate.
     */
    where?: WorkerNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerNotifications to fetch.
     */
    orderBy?: WorkerNotificationOrderByWithRelationInput | WorkerNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkerNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkerNotifications
    **/
    _count?: true | WorkerNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkerNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkerNotificationMaxAggregateInputType
  }

  export type GetWorkerNotificationAggregateType<T extends WorkerNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkerNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkerNotification[P]>
      : GetScalarType<T[P], AggregateWorkerNotification[P]>
  }




  export type WorkerNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerNotificationWhereInput
    orderBy?: WorkerNotificationOrderByWithAggregationInput | WorkerNotificationOrderByWithAggregationInput[]
    by: WorkerNotificationScalarFieldEnum[] | WorkerNotificationScalarFieldEnum
    having?: WorkerNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkerNotificationCountAggregateInputType | true
    _min?: WorkerNotificationMinAggregateInputType
    _max?: WorkerNotificationMaxAggregateInputType
  }

  export type WorkerNotificationGroupByOutputType = {
    id: string
    workerId: string
    fromAdminId: string | null
    type: string
    title: string
    message: string
    isRead: boolean | null
    createdAt: Date | null
    _count: WorkerNotificationCountAggregateOutputType | null
    _min: WorkerNotificationMinAggregateOutputType | null
    _max: WorkerNotificationMaxAggregateOutputType | null
  }

  type GetWorkerNotificationGroupByPayload<T extends WorkerNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkerNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkerNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkerNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], WorkerNotificationGroupByOutputType[P]>
        }
      >
    >


  export type WorkerNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workerId?: boolean
    fromAdminId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    fromAdmin?: boolean | WorkerNotification$fromAdminArgs<ExtArgs>
    worker?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workerNotification"]>

  export type WorkerNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workerId?: boolean
    fromAdminId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    fromAdmin?: boolean | WorkerNotification$fromAdminArgs<ExtArgs>
    worker?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workerNotification"]>

  export type WorkerNotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workerId?: boolean
    fromAdminId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    fromAdmin?: boolean | WorkerNotification$fromAdminArgs<ExtArgs>
    worker?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workerNotification"]>

  export type WorkerNotificationSelectScalar = {
    id?: boolean
    workerId?: boolean
    fromAdminId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type WorkerNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workerId" | "fromAdminId" | "type" | "title" | "message" | "isRead" | "createdAt", ExtArgs["result"]["workerNotification"]>
  export type WorkerNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromAdmin?: boolean | WorkerNotification$fromAdminArgs<ExtArgs>
    worker?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WorkerNotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromAdmin?: boolean | WorkerNotification$fromAdminArgs<ExtArgs>
    worker?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WorkerNotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromAdmin?: boolean | WorkerNotification$fromAdminArgs<ExtArgs>
    worker?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WorkerNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkerNotification"
    objects: {
      fromAdmin: Prisma.$UserPayload<ExtArgs> | null
      worker: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workerId: string
      fromAdminId: string | null
      type: string
      title: string
      message: string
      isRead: boolean | null
      createdAt: Date | null
    }, ExtArgs["result"]["workerNotification"]>
    composites: {}
  }

  type WorkerNotificationGetPayload<S extends boolean | null | undefined | WorkerNotificationDefaultArgs> = $Result.GetResult<Prisma.$WorkerNotificationPayload, S>

  type WorkerNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkerNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkerNotificationCountAggregateInputType | true
    }

  export interface WorkerNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkerNotification'], meta: { name: 'WorkerNotification' } }
    /**
     * Find zero or one WorkerNotification that matches the filter.
     * @param {WorkerNotificationFindUniqueArgs} args - Arguments to find a WorkerNotification
     * @example
     * // Get one WorkerNotification
     * const workerNotification = await prisma.workerNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkerNotificationFindUniqueArgs>(args: SelectSubset<T, WorkerNotificationFindUniqueArgs<ExtArgs>>): Prisma__WorkerNotificationClient<$Result.GetResult<Prisma.$WorkerNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkerNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkerNotificationFindUniqueOrThrowArgs} args - Arguments to find a WorkerNotification
     * @example
     * // Get one WorkerNotification
     * const workerNotification = await prisma.workerNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkerNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkerNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkerNotificationClient<$Result.GetResult<Prisma.$WorkerNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkerNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerNotificationFindFirstArgs} args - Arguments to find a WorkerNotification
     * @example
     * // Get one WorkerNotification
     * const workerNotification = await prisma.workerNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkerNotificationFindFirstArgs>(args?: SelectSubset<T, WorkerNotificationFindFirstArgs<ExtArgs>>): Prisma__WorkerNotificationClient<$Result.GetResult<Prisma.$WorkerNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkerNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerNotificationFindFirstOrThrowArgs} args - Arguments to find a WorkerNotification
     * @example
     * // Get one WorkerNotification
     * const workerNotification = await prisma.workerNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkerNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkerNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkerNotificationClient<$Result.GetResult<Prisma.$WorkerNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkerNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkerNotifications
     * const workerNotifications = await prisma.workerNotification.findMany()
     * 
     * // Get first 10 WorkerNotifications
     * const workerNotifications = await prisma.workerNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workerNotificationWithIdOnly = await prisma.workerNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkerNotificationFindManyArgs>(args?: SelectSubset<T, WorkerNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkerNotification.
     * @param {WorkerNotificationCreateArgs} args - Arguments to create a WorkerNotification.
     * @example
     * // Create one WorkerNotification
     * const WorkerNotification = await prisma.workerNotification.create({
     *   data: {
     *     // ... data to create a WorkerNotification
     *   }
     * })
     * 
     */
    create<T extends WorkerNotificationCreateArgs>(args: SelectSubset<T, WorkerNotificationCreateArgs<ExtArgs>>): Prisma__WorkerNotificationClient<$Result.GetResult<Prisma.$WorkerNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkerNotifications.
     * @param {WorkerNotificationCreateManyArgs} args - Arguments to create many WorkerNotifications.
     * @example
     * // Create many WorkerNotifications
     * const workerNotification = await prisma.workerNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkerNotificationCreateManyArgs>(args?: SelectSubset<T, WorkerNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkerNotifications and returns the data saved in the database.
     * @param {WorkerNotificationCreateManyAndReturnArgs} args - Arguments to create many WorkerNotifications.
     * @example
     * // Create many WorkerNotifications
     * const workerNotification = await prisma.workerNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkerNotifications and only return the `id`
     * const workerNotificationWithIdOnly = await prisma.workerNotification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkerNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkerNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerNotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkerNotification.
     * @param {WorkerNotificationDeleteArgs} args - Arguments to delete one WorkerNotification.
     * @example
     * // Delete one WorkerNotification
     * const WorkerNotification = await prisma.workerNotification.delete({
     *   where: {
     *     // ... filter to delete one WorkerNotification
     *   }
     * })
     * 
     */
    delete<T extends WorkerNotificationDeleteArgs>(args: SelectSubset<T, WorkerNotificationDeleteArgs<ExtArgs>>): Prisma__WorkerNotificationClient<$Result.GetResult<Prisma.$WorkerNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkerNotification.
     * @param {WorkerNotificationUpdateArgs} args - Arguments to update one WorkerNotification.
     * @example
     * // Update one WorkerNotification
     * const workerNotification = await prisma.workerNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkerNotificationUpdateArgs>(args: SelectSubset<T, WorkerNotificationUpdateArgs<ExtArgs>>): Prisma__WorkerNotificationClient<$Result.GetResult<Prisma.$WorkerNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkerNotifications.
     * @param {WorkerNotificationDeleteManyArgs} args - Arguments to filter WorkerNotifications to delete.
     * @example
     * // Delete a few WorkerNotifications
     * const { count } = await prisma.workerNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkerNotificationDeleteManyArgs>(args?: SelectSubset<T, WorkerNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkerNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkerNotifications
     * const workerNotification = await prisma.workerNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkerNotificationUpdateManyArgs>(args: SelectSubset<T, WorkerNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkerNotifications and returns the data updated in the database.
     * @param {WorkerNotificationUpdateManyAndReturnArgs} args - Arguments to update many WorkerNotifications.
     * @example
     * // Update many WorkerNotifications
     * const workerNotification = await prisma.workerNotification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkerNotifications and only return the `id`
     * const workerNotificationWithIdOnly = await prisma.workerNotification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkerNotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkerNotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerNotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkerNotification.
     * @param {WorkerNotificationUpsertArgs} args - Arguments to update or create a WorkerNotification.
     * @example
     * // Update or create a WorkerNotification
     * const workerNotification = await prisma.workerNotification.upsert({
     *   create: {
     *     // ... data to create a WorkerNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkerNotification we want to update
     *   }
     * })
     */
    upsert<T extends WorkerNotificationUpsertArgs>(args: SelectSubset<T, WorkerNotificationUpsertArgs<ExtArgs>>): Prisma__WorkerNotificationClient<$Result.GetResult<Prisma.$WorkerNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkerNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerNotificationCountArgs} args - Arguments to filter WorkerNotifications to count.
     * @example
     * // Count the number of WorkerNotifications
     * const count = await prisma.workerNotification.count({
     *   where: {
     *     // ... the filter for the WorkerNotifications we want to count
     *   }
     * })
    **/
    count<T extends WorkerNotificationCountArgs>(
      args?: Subset<T, WorkerNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkerNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkerNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkerNotificationAggregateArgs>(args: Subset<T, WorkerNotificationAggregateArgs>): Prisma.PrismaPromise<GetWorkerNotificationAggregateType<T>>

    /**
     * Group by WorkerNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkerNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkerNotificationGroupByArgs['orderBy'] }
        : { orderBy?: WorkerNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkerNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkerNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkerNotification model
   */
  readonly fields: WorkerNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkerNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkerNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fromAdmin<T extends WorkerNotification$fromAdminArgs<ExtArgs> = {}>(args?: Subset<T, WorkerNotification$fromAdminArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    worker<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkerNotification model
   */
  interface WorkerNotificationFieldRefs {
    readonly id: FieldRef<"WorkerNotification", 'String'>
    readonly workerId: FieldRef<"WorkerNotification", 'String'>
    readonly fromAdminId: FieldRef<"WorkerNotification", 'String'>
    readonly type: FieldRef<"WorkerNotification", 'String'>
    readonly title: FieldRef<"WorkerNotification", 'String'>
    readonly message: FieldRef<"WorkerNotification", 'String'>
    readonly isRead: FieldRef<"WorkerNotification", 'Boolean'>
    readonly createdAt: FieldRef<"WorkerNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkerNotification findUnique
   */
  export type WorkerNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerNotification
     */
    select?: WorkerNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerNotification
     */
    omit?: WorkerNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerNotificationInclude<ExtArgs> | null
    /**
     * Filter, which WorkerNotification to fetch.
     */
    where: WorkerNotificationWhereUniqueInput
  }

  /**
   * WorkerNotification findUniqueOrThrow
   */
  export type WorkerNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerNotification
     */
    select?: WorkerNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerNotification
     */
    omit?: WorkerNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerNotificationInclude<ExtArgs> | null
    /**
     * Filter, which WorkerNotification to fetch.
     */
    where: WorkerNotificationWhereUniqueInput
  }

  /**
   * WorkerNotification findFirst
   */
  export type WorkerNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerNotification
     */
    select?: WorkerNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerNotification
     */
    omit?: WorkerNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerNotificationInclude<ExtArgs> | null
    /**
     * Filter, which WorkerNotification to fetch.
     */
    where?: WorkerNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerNotifications to fetch.
     */
    orderBy?: WorkerNotificationOrderByWithRelationInput | WorkerNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkerNotifications.
     */
    cursor?: WorkerNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkerNotifications.
     */
    distinct?: WorkerNotificationScalarFieldEnum | WorkerNotificationScalarFieldEnum[]
  }

  /**
   * WorkerNotification findFirstOrThrow
   */
  export type WorkerNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerNotification
     */
    select?: WorkerNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerNotification
     */
    omit?: WorkerNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerNotificationInclude<ExtArgs> | null
    /**
     * Filter, which WorkerNotification to fetch.
     */
    where?: WorkerNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerNotifications to fetch.
     */
    orderBy?: WorkerNotificationOrderByWithRelationInput | WorkerNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkerNotifications.
     */
    cursor?: WorkerNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkerNotifications.
     */
    distinct?: WorkerNotificationScalarFieldEnum | WorkerNotificationScalarFieldEnum[]
  }

  /**
   * WorkerNotification findMany
   */
  export type WorkerNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerNotification
     */
    select?: WorkerNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerNotification
     */
    omit?: WorkerNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerNotificationInclude<ExtArgs> | null
    /**
     * Filter, which WorkerNotifications to fetch.
     */
    where?: WorkerNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerNotifications to fetch.
     */
    orderBy?: WorkerNotificationOrderByWithRelationInput | WorkerNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkerNotifications.
     */
    cursor?: WorkerNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerNotifications.
     */
    skip?: number
    distinct?: WorkerNotificationScalarFieldEnum | WorkerNotificationScalarFieldEnum[]
  }

  /**
   * WorkerNotification create
   */
  export type WorkerNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerNotification
     */
    select?: WorkerNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerNotification
     */
    omit?: WorkerNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkerNotification.
     */
    data: XOR<WorkerNotificationCreateInput, WorkerNotificationUncheckedCreateInput>
  }

  /**
   * WorkerNotification createMany
   */
  export type WorkerNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkerNotifications.
     */
    data: WorkerNotificationCreateManyInput | WorkerNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkerNotification createManyAndReturn
   */
  export type WorkerNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerNotification
     */
    select?: WorkerNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerNotification
     */
    omit?: WorkerNotificationOmit<ExtArgs> | null
    /**
     * The data used to create many WorkerNotifications.
     */
    data: WorkerNotificationCreateManyInput | WorkerNotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerNotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkerNotification update
   */
  export type WorkerNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerNotification
     */
    select?: WorkerNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerNotification
     */
    omit?: WorkerNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkerNotification.
     */
    data: XOR<WorkerNotificationUpdateInput, WorkerNotificationUncheckedUpdateInput>
    /**
     * Choose, which WorkerNotification to update.
     */
    where: WorkerNotificationWhereUniqueInput
  }

  /**
   * WorkerNotification updateMany
   */
  export type WorkerNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkerNotifications.
     */
    data: XOR<WorkerNotificationUpdateManyMutationInput, WorkerNotificationUncheckedUpdateManyInput>
    /**
     * Filter which WorkerNotifications to update
     */
    where?: WorkerNotificationWhereInput
    /**
     * Limit how many WorkerNotifications to update.
     */
    limit?: number
  }

  /**
   * WorkerNotification updateManyAndReturn
   */
  export type WorkerNotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerNotification
     */
    select?: WorkerNotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerNotification
     */
    omit?: WorkerNotificationOmit<ExtArgs> | null
    /**
     * The data used to update WorkerNotifications.
     */
    data: XOR<WorkerNotificationUpdateManyMutationInput, WorkerNotificationUncheckedUpdateManyInput>
    /**
     * Filter which WorkerNotifications to update
     */
    where?: WorkerNotificationWhereInput
    /**
     * Limit how many WorkerNotifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerNotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkerNotification upsert
   */
  export type WorkerNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerNotification
     */
    select?: WorkerNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerNotification
     */
    omit?: WorkerNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkerNotification to update in case it exists.
     */
    where: WorkerNotificationWhereUniqueInput
    /**
     * In case the WorkerNotification found by the `where` argument doesn't exist, create a new WorkerNotification with this data.
     */
    create: XOR<WorkerNotificationCreateInput, WorkerNotificationUncheckedCreateInput>
    /**
     * In case the WorkerNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkerNotificationUpdateInput, WorkerNotificationUncheckedUpdateInput>
  }

  /**
   * WorkerNotification delete
   */
  export type WorkerNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerNotification
     */
    select?: WorkerNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerNotification
     */
    omit?: WorkerNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerNotificationInclude<ExtArgs> | null
    /**
     * Filter which WorkerNotification to delete.
     */
    where: WorkerNotificationWhereUniqueInput
  }

  /**
   * WorkerNotification deleteMany
   */
  export type WorkerNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkerNotifications to delete
     */
    where?: WorkerNotificationWhereInput
    /**
     * Limit how many WorkerNotifications to delete.
     */
    limit?: number
  }

  /**
   * WorkerNotification.fromAdmin
   */
  export type WorkerNotification$fromAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * WorkerNotification without action
   */
  export type WorkerNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerNotification
     */
    select?: WorkerNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerNotification
     */
    omit?: WorkerNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerNotificationInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    senderId: number
    receiverId: number
    content: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    isRead?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    isRead?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    senderId: string
    receiverId: string
    content: string
    isRead: boolean
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "senderId" | "receiverId" | "content" | "isRead" | "createdAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      receiver: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      senderId: string
      receiverId: string
      content: string
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receiver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly receiverId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly isRead: FieldRef<"Message", 'Boolean'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model NotificationDismissal
   */

  export type AggregateNotificationDismissal = {
    _count: NotificationDismissalCountAggregateOutputType | null
    _min: NotificationDismissalMinAggregateOutputType | null
    _max: NotificationDismissalMaxAggregateOutputType | null
  }

  export type NotificationDismissalMinAggregateOutputType = {
    id: string | null
    userId: string | null
    entityId: string | null
    entityType: string | null
    createdAt: Date | null
  }

  export type NotificationDismissalMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    entityId: string | null
    entityType: string | null
    createdAt: Date | null
  }

  export type NotificationDismissalCountAggregateOutputType = {
    id: number
    userId: number
    entityId: number
    entityType: number
    createdAt: number
    _all: number
  }


  export type NotificationDismissalMinAggregateInputType = {
    id?: true
    userId?: true
    entityId?: true
    entityType?: true
    createdAt?: true
  }

  export type NotificationDismissalMaxAggregateInputType = {
    id?: true
    userId?: true
    entityId?: true
    entityType?: true
    createdAt?: true
  }

  export type NotificationDismissalCountAggregateInputType = {
    id?: true
    userId?: true
    entityId?: true
    entityType?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationDismissalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationDismissal to aggregate.
     */
    where?: NotificationDismissalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationDismissals to fetch.
     */
    orderBy?: NotificationDismissalOrderByWithRelationInput | NotificationDismissalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationDismissalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationDismissals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationDismissals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationDismissals
    **/
    _count?: true | NotificationDismissalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationDismissalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationDismissalMaxAggregateInputType
  }

  export type GetNotificationDismissalAggregateType<T extends NotificationDismissalAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationDismissal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationDismissal[P]>
      : GetScalarType<T[P], AggregateNotificationDismissal[P]>
  }




  export type NotificationDismissalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationDismissalWhereInput
    orderBy?: NotificationDismissalOrderByWithAggregationInput | NotificationDismissalOrderByWithAggregationInput[]
    by: NotificationDismissalScalarFieldEnum[] | NotificationDismissalScalarFieldEnum
    having?: NotificationDismissalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationDismissalCountAggregateInputType | true
    _min?: NotificationDismissalMinAggregateInputType
    _max?: NotificationDismissalMaxAggregateInputType
  }

  export type NotificationDismissalGroupByOutputType = {
    id: string
    userId: string
    entityId: string
    entityType: string
    createdAt: Date
    _count: NotificationDismissalCountAggregateOutputType | null
    _min: NotificationDismissalMinAggregateOutputType | null
    _max: NotificationDismissalMaxAggregateOutputType | null
  }

  type GetNotificationDismissalGroupByPayload<T extends NotificationDismissalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationDismissalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationDismissalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationDismissalGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationDismissalGroupByOutputType[P]>
        }
      >
    >


  export type NotificationDismissalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    entityId?: boolean
    entityType?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationDismissal"]>

  export type NotificationDismissalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    entityId?: boolean
    entityType?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationDismissal"]>

  export type NotificationDismissalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    entityId?: boolean
    entityType?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationDismissal"]>

  export type NotificationDismissalSelectScalar = {
    id?: boolean
    userId?: boolean
    entityId?: boolean
    entityType?: boolean
    createdAt?: boolean
  }

  export type NotificationDismissalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "entityId" | "entityType" | "createdAt", ExtArgs["result"]["notificationDismissal"]>
  export type NotificationDismissalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationDismissalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationDismissalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationDismissalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationDismissal"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      entityId: string
      entityType: string
      createdAt: Date
    }, ExtArgs["result"]["notificationDismissal"]>
    composites: {}
  }

  type NotificationDismissalGetPayload<S extends boolean | null | undefined | NotificationDismissalDefaultArgs> = $Result.GetResult<Prisma.$NotificationDismissalPayload, S>

  type NotificationDismissalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationDismissalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationDismissalCountAggregateInputType | true
    }

  export interface NotificationDismissalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationDismissal'], meta: { name: 'NotificationDismissal' } }
    /**
     * Find zero or one NotificationDismissal that matches the filter.
     * @param {NotificationDismissalFindUniqueArgs} args - Arguments to find a NotificationDismissal
     * @example
     * // Get one NotificationDismissal
     * const notificationDismissal = await prisma.notificationDismissal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationDismissalFindUniqueArgs>(args: SelectSubset<T, NotificationDismissalFindUniqueArgs<ExtArgs>>): Prisma__NotificationDismissalClient<$Result.GetResult<Prisma.$NotificationDismissalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationDismissal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationDismissalFindUniqueOrThrowArgs} args - Arguments to find a NotificationDismissal
     * @example
     * // Get one NotificationDismissal
     * const notificationDismissal = await prisma.notificationDismissal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationDismissalFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationDismissalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationDismissalClient<$Result.GetResult<Prisma.$NotificationDismissalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationDismissal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationDismissalFindFirstArgs} args - Arguments to find a NotificationDismissal
     * @example
     * // Get one NotificationDismissal
     * const notificationDismissal = await prisma.notificationDismissal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationDismissalFindFirstArgs>(args?: SelectSubset<T, NotificationDismissalFindFirstArgs<ExtArgs>>): Prisma__NotificationDismissalClient<$Result.GetResult<Prisma.$NotificationDismissalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationDismissal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationDismissalFindFirstOrThrowArgs} args - Arguments to find a NotificationDismissal
     * @example
     * // Get one NotificationDismissal
     * const notificationDismissal = await prisma.notificationDismissal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationDismissalFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationDismissalFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationDismissalClient<$Result.GetResult<Prisma.$NotificationDismissalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationDismissals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationDismissalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationDismissals
     * const notificationDismissals = await prisma.notificationDismissal.findMany()
     * 
     * // Get first 10 NotificationDismissals
     * const notificationDismissals = await prisma.notificationDismissal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationDismissalWithIdOnly = await prisma.notificationDismissal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationDismissalFindManyArgs>(args?: SelectSubset<T, NotificationDismissalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationDismissalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationDismissal.
     * @param {NotificationDismissalCreateArgs} args - Arguments to create a NotificationDismissal.
     * @example
     * // Create one NotificationDismissal
     * const NotificationDismissal = await prisma.notificationDismissal.create({
     *   data: {
     *     // ... data to create a NotificationDismissal
     *   }
     * })
     * 
     */
    create<T extends NotificationDismissalCreateArgs>(args: SelectSubset<T, NotificationDismissalCreateArgs<ExtArgs>>): Prisma__NotificationDismissalClient<$Result.GetResult<Prisma.$NotificationDismissalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationDismissals.
     * @param {NotificationDismissalCreateManyArgs} args - Arguments to create many NotificationDismissals.
     * @example
     * // Create many NotificationDismissals
     * const notificationDismissal = await prisma.notificationDismissal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationDismissalCreateManyArgs>(args?: SelectSubset<T, NotificationDismissalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationDismissals and returns the data saved in the database.
     * @param {NotificationDismissalCreateManyAndReturnArgs} args - Arguments to create many NotificationDismissals.
     * @example
     * // Create many NotificationDismissals
     * const notificationDismissal = await prisma.notificationDismissal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationDismissals and only return the `id`
     * const notificationDismissalWithIdOnly = await prisma.notificationDismissal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationDismissalCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationDismissalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationDismissalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationDismissal.
     * @param {NotificationDismissalDeleteArgs} args - Arguments to delete one NotificationDismissal.
     * @example
     * // Delete one NotificationDismissal
     * const NotificationDismissal = await prisma.notificationDismissal.delete({
     *   where: {
     *     // ... filter to delete one NotificationDismissal
     *   }
     * })
     * 
     */
    delete<T extends NotificationDismissalDeleteArgs>(args: SelectSubset<T, NotificationDismissalDeleteArgs<ExtArgs>>): Prisma__NotificationDismissalClient<$Result.GetResult<Prisma.$NotificationDismissalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationDismissal.
     * @param {NotificationDismissalUpdateArgs} args - Arguments to update one NotificationDismissal.
     * @example
     * // Update one NotificationDismissal
     * const notificationDismissal = await prisma.notificationDismissal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationDismissalUpdateArgs>(args: SelectSubset<T, NotificationDismissalUpdateArgs<ExtArgs>>): Prisma__NotificationDismissalClient<$Result.GetResult<Prisma.$NotificationDismissalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationDismissals.
     * @param {NotificationDismissalDeleteManyArgs} args - Arguments to filter NotificationDismissals to delete.
     * @example
     * // Delete a few NotificationDismissals
     * const { count } = await prisma.notificationDismissal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDismissalDeleteManyArgs>(args?: SelectSubset<T, NotificationDismissalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationDismissals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationDismissalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationDismissals
     * const notificationDismissal = await prisma.notificationDismissal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationDismissalUpdateManyArgs>(args: SelectSubset<T, NotificationDismissalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationDismissals and returns the data updated in the database.
     * @param {NotificationDismissalUpdateManyAndReturnArgs} args - Arguments to update many NotificationDismissals.
     * @example
     * // Update many NotificationDismissals
     * const notificationDismissal = await prisma.notificationDismissal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationDismissals and only return the `id`
     * const notificationDismissalWithIdOnly = await prisma.notificationDismissal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationDismissalUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationDismissalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationDismissalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationDismissal.
     * @param {NotificationDismissalUpsertArgs} args - Arguments to update or create a NotificationDismissal.
     * @example
     * // Update or create a NotificationDismissal
     * const notificationDismissal = await prisma.notificationDismissal.upsert({
     *   create: {
     *     // ... data to create a NotificationDismissal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationDismissal we want to update
     *   }
     * })
     */
    upsert<T extends NotificationDismissalUpsertArgs>(args: SelectSubset<T, NotificationDismissalUpsertArgs<ExtArgs>>): Prisma__NotificationDismissalClient<$Result.GetResult<Prisma.$NotificationDismissalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationDismissals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationDismissalCountArgs} args - Arguments to filter NotificationDismissals to count.
     * @example
     * // Count the number of NotificationDismissals
     * const count = await prisma.notificationDismissal.count({
     *   where: {
     *     // ... the filter for the NotificationDismissals we want to count
     *   }
     * })
    **/
    count<T extends NotificationDismissalCountArgs>(
      args?: Subset<T, NotificationDismissalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationDismissalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationDismissal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationDismissalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationDismissalAggregateArgs>(args: Subset<T, NotificationDismissalAggregateArgs>): Prisma.PrismaPromise<GetNotificationDismissalAggregateType<T>>

    /**
     * Group by NotificationDismissal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationDismissalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationDismissalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationDismissalGroupByArgs['orderBy'] }
        : { orderBy?: NotificationDismissalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationDismissalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationDismissalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationDismissal model
   */
  readonly fields: NotificationDismissalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationDismissal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationDismissalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationDismissal model
   */
  interface NotificationDismissalFieldRefs {
    readonly id: FieldRef<"NotificationDismissal", 'String'>
    readonly userId: FieldRef<"NotificationDismissal", 'String'>
    readonly entityId: FieldRef<"NotificationDismissal", 'String'>
    readonly entityType: FieldRef<"NotificationDismissal", 'String'>
    readonly createdAt: FieldRef<"NotificationDismissal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationDismissal findUnique
   */
  export type NotificationDismissalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDismissal
     */
    select?: NotificationDismissalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDismissal
     */
    omit?: NotificationDismissalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDismissalInclude<ExtArgs> | null
    /**
     * Filter, which NotificationDismissal to fetch.
     */
    where: NotificationDismissalWhereUniqueInput
  }

  /**
   * NotificationDismissal findUniqueOrThrow
   */
  export type NotificationDismissalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDismissal
     */
    select?: NotificationDismissalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDismissal
     */
    omit?: NotificationDismissalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDismissalInclude<ExtArgs> | null
    /**
     * Filter, which NotificationDismissal to fetch.
     */
    where: NotificationDismissalWhereUniqueInput
  }

  /**
   * NotificationDismissal findFirst
   */
  export type NotificationDismissalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDismissal
     */
    select?: NotificationDismissalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDismissal
     */
    omit?: NotificationDismissalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDismissalInclude<ExtArgs> | null
    /**
     * Filter, which NotificationDismissal to fetch.
     */
    where?: NotificationDismissalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationDismissals to fetch.
     */
    orderBy?: NotificationDismissalOrderByWithRelationInput | NotificationDismissalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationDismissals.
     */
    cursor?: NotificationDismissalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationDismissals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationDismissals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationDismissals.
     */
    distinct?: NotificationDismissalScalarFieldEnum | NotificationDismissalScalarFieldEnum[]
  }

  /**
   * NotificationDismissal findFirstOrThrow
   */
  export type NotificationDismissalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDismissal
     */
    select?: NotificationDismissalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDismissal
     */
    omit?: NotificationDismissalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDismissalInclude<ExtArgs> | null
    /**
     * Filter, which NotificationDismissal to fetch.
     */
    where?: NotificationDismissalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationDismissals to fetch.
     */
    orderBy?: NotificationDismissalOrderByWithRelationInput | NotificationDismissalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationDismissals.
     */
    cursor?: NotificationDismissalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationDismissals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationDismissals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationDismissals.
     */
    distinct?: NotificationDismissalScalarFieldEnum | NotificationDismissalScalarFieldEnum[]
  }

  /**
   * NotificationDismissal findMany
   */
  export type NotificationDismissalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDismissal
     */
    select?: NotificationDismissalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDismissal
     */
    omit?: NotificationDismissalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDismissalInclude<ExtArgs> | null
    /**
     * Filter, which NotificationDismissals to fetch.
     */
    where?: NotificationDismissalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationDismissals to fetch.
     */
    orderBy?: NotificationDismissalOrderByWithRelationInput | NotificationDismissalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationDismissals.
     */
    cursor?: NotificationDismissalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationDismissals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationDismissals.
     */
    skip?: number
    distinct?: NotificationDismissalScalarFieldEnum | NotificationDismissalScalarFieldEnum[]
  }

  /**
   * NotificationDismissal create
   */
  export type NotificationDismissalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDismissal
     */
    select?: NotificationDismissalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDismissal
     */
    omit?: NotificationDismissalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDismissalInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationDismissal.
     */
    data: XOR<NotificationDismissalCreateInput, NotificationDismissalUncheckedCreateInput>
  }

  /**
   * NotificationDismissal createMany
   */
  export type NotificationDismissalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationDismissals.
     */
    data: NotificationDismissalCreateManyInput | NotificationDismissalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationDismissal createManyAndReturn
   */
  export type NotificationDismissalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDismissal
     */
    select?: NotificationDismissalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDismissal
     */
    omit?: NotificationDismissalOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationDismissals.
     */
    data: NotificationDismissalCreateManyInput | NotificationDismissalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDismissalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationDismissal update
   */
  export type NotificationDismissalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDismissal
     */
    select?: NotificationDismissalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDismissal
     */
    omit?: NotificationDismissalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDismissalInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationDismissal.
     */
    data: XOR<NotificationDismissalUpdateInput, NotificationDismissalUncheckedUpdateInput>
    /**
     * Choose, which NotificationDismissal to update.
     */
    where: NotificationDismissalWhereUniqueInput
  }

  /**
   * NotificationDismissal updateMany
   */
  export type NotificationDismissalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationDismissals.
     */
    data: XOR<NotificationDismissalUpdateManyMutationInput, NotificationDismissalUncheckedUpdateManyInput>
    /**
     * Filter which NotificationDismissals to update
     */
    where?: NotificationDismissalWhereInput
    /**
     * Limit how many NotificationDismissals to update.
     */
    limit?: number
  }

  /**
   * NotificationDismissal updateManyAndReturn
   */
  export type NotificationDismissalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDismissal
     */
    select?: NotificationDismissalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDismissal
     */
    omit?: NotificationDismissalOmit<ExtArgs> | null
    /**
     * The data used to update NotificationDismissals.
     */
    data: XOR<NotificationDismissalUpdateManyMutationInput, NotificationDismissalUncheckedUpdateManyInput>
    /**
     * Filter which NotificationDismissals to update
     */
    where?: NotificationDismissalWhereInput
    /**
     * Limit how many NotificationDismissals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDismissalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationDismissal upsert
   */
  export type NotificationDismissalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDismissal
     */
    select?: NotificationDismissalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDismissal
     */
    omit?: NotificationDismissalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDismissalInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationDismissal to update in case it exists.
     */
    where: NotificationDismissalWhereUniqueInput
    /**
     * In case the NotificationDismissal found by the `where` argument doesn't exist, create a new NotificationDismissal with this data.
     */
    create: XOR<NotificationDismissalCreateInput, NotificationDismissalUncheckedCreateInput>
    /**
     * In case the NotificationDismissal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationDismissalUpdateInput, NotificationDismissalUncheckedUpdateInput>
  }

  /**
   * NotificationDismissal delete
   */
  export type NotificationDismissalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDismissal
     */
    select?: NotificationDismissalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDismissal
     */
    omit?: NotificationDismissalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDismissalInclude<ExtArgs> | null
    /**
     * Filter which NotificationDismissal to delete.
     */
    where: NotificationDismissalWhereUniqueInput
  }

  /**
   * NotificationDismissal deleteMany
   */
  export type NotificationDismissalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationDismissals to delete
     */
    where?: NotificationDismissalWhereInput
    /**
     * Limit how many NotificationDismissals to delete.
     */
    limit?: number
  }

  /**
   * NotificationDismissal without action
   */
  export type NotificationDismissalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationDismissal
     */
    select?: NotificationDismissalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationDismissal
     */
    omit?: NotificationDismissalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationDismissalInclude<ExtArgs> | null
  }


  /**
   * Model SystemJobLog
   */

  export type AggregateSystemJobLog = {
    _count: SystemJobLogCountAggregateOutputType | null
    _min: SystemJobLogMinAggregateOutputType | null
    _max: SystemJobLogMaxAggregateOutputType | null
  }

  export type SystemJobLogMinAggregateOutputType = {
    id: string | null
    jobName: string | null
    status: string | null
    message: string | null
    createdAt: Date | null
  }

  export type SystemJobLogMaxAggregateOutputType = {
    id: string | null
    jobName: string | null
    status: string | null
    message: string | null
    createdAt: Date | null
  }

  export type SystemJobLogCountAggregateOutputType = {
    id: number
    jobName: number
    status: number
    message: number
    createdAt: number
    _all: number
  }


  export type SystemJobLogMinAggregateInputType = {
    id?: true
    jobName?: true
    status?: true
    message?: true
    createdAt?: true
  }

  export type SystemJobLogMaxAggregateInputType = {
    id?: true
    jobName?: true
    status?: true
    message?: true
    createdAt?: true
  }

  export type SystemJobLogCountAggregateInputType = {
    id?: true
    jobName?: true
    status?: true
    message?: true
    createdAt?: true
    _all?: true
  }

  export type SystemJobLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemJobLog to aggregate.
     */
    where?: SystemJobLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemJobLogs to fetch.
     */
    orderBy?: SystemJobLogOrderByWithRelationInput | SystemJobLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemJobLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemJobLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemJobLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemJobLogs
    **/
    _count?: true | SystemJobLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemJobLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemJobLogMaxAggregateInputType
  }

  export type GetSystemJobLogAggregateType<T extends SystemJobLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemJobLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemJobLog[P]>
      : GetScalarType<T[P], AggregateSystemJobLog[P]>
  }




  export type SystemJobLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemJobLogWhereInput
    orderBy?: SystemJobLogOrderByWithAggregationInput | SystemJobLogOrderByWithAggregationInput[]
    by: SystemJobLogScalarFieldEnum[] | SystemJobLogScalarFieldEnum
    having?: SystemJobLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemJobLogCountAggregateInputType | true
    _min?: SystemJobLogMinAggregateInputType
    _max?: SystemJobLogMaxAggregateInputType
  }

  export type SystemJobLogGroupByOutputType = {
    id: string
    jobName: string
    status: string
    message: string | null
    createdAt: Date
    _count: SystemJobLogCountAggregateOutputType | null
    _min: SystemJobLogMinAggregateOutputType | null
    _max: SystemJobLogMaxAggregateOutputType | null
  }

  type GetSystemJobLogGroupByPayload<T extends SystemJobLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemJobLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemJobLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemJobLogGroupByOutputType[P]>
            : GetScalarType<T[P], SystemJobLogGroupByOutputType[P]>
        }
      >
    >


  export type SystemJobLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobName?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["systemJobLog"]>

  export type SystemJobLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobName?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["systemJobLog"]>

  export type SystemJobLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobName?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["systemJobLog"]>

  export type SystemJobLogSelectScalar = {
    id?: boolean
    jobName?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
  }

  export type SystemJobLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobName" | "status" | "message" | "createdAt", ExtArgs["result"]["systemJobLog"]>

  export type $SystemJobLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemJobLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobName: string
      status: string
      message: string | null
      createdAt: Date
    }, ExtArgs["result"]["systemJobLog"]>
    composites: {}
  }

  type SystemJobLogGetPayload<S extends boolean | null | undefined | SystemJobLogDefaultArgs> = $Result.GetResult<Prisma.$SystemJobLogPayload, S>

  type SystemJobLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemJobLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemJobLogCountAggregateInputType | true
    }

  export interface SystemJobLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemJobLog'], meta: { name: 'SystemJobLog' } }
    /**
     * Find zero or one SystemJobLog that matches the filter.
     * @param {SystemJobLogFindUniqueArgs} args - Arguments to find a SystemJobLog
     * @example
     * // Get one SystemJobLog
     * const systemJobLog = await prisma.systemJobLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemJobLogFindUniqueArgs>(args: SelectSubset<T, SystemJobLogFindUniqueArgs<ExtArgs>>): Prisma__SystemJobLogClient<$Result.GetResult<Prisma.$SystemJobLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemJobLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemJobLogFindUniqueOrThrowArgs} args - Arguments to find a SystemJobLog
     * @example
     * // Get one SystemJobLog
     * const systemJobLog = await prisma.systemJobLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemJobLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemJobLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemJobLogClient<$Result.GetResult<Prisma.$SystemJobLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemJobLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemJobLogFindFirstArgs} args - Arguments to find a SystemJobLog
     * @example
     * // Get one SystemJobLog
     * const systemJobLog = await prisma.systemJobLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemJobLogFindFirstArgs>(args?: SelectSubset<T, SystemJobLogFindFirstArgs<ExtArgs>>): Prisma__SystemJobLogClient<$Result.GetResult<Prisma.$SystemJobLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemJobLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemJobLogFindFirstOrThrowArgs} args - Arguments to find a SystemJobLog
     * @example
     * // Get one SystemJobLog
     * const systemJobLog = await prisma.systemJobLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemJobLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemJobLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemJobLogClient<$Result.GetResult<Prisma.$SystemJobLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemJobLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemJobLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemJobLogs
     * const systemJobLogs = await prisma.systemJobLog.findMany()
     * 
     * // Get first 10 SystemJobLogs
     * const systemJobLogs = await prisma.systemJobLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemJobLogWithIdOnly = await prisma.systemJobLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemJobLogFindManyArgs>(args?: SelectSubset<T, SystemJobLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemJobLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemJobLog.
     * @param {SystemJobLogCreateArgs} args - Arguments to create a SystemJobLog.
     * @example
     * // Create one SystemJobLog
     * const SystemJobLog = await prisma.systemJobLog.create({
     *   data: {
     *     // ... data to create a SystemJobLog
     *   }
     * })
     * 
     */
    create<T extends SystemJobLogCreateArgs>(args: SelectSubset<T, SystemJobLogCreateArgs<ExtArgs>>): Prisma__SystemJobLogClient<$Result.GetResult<Prisma.$SystemJobLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemJobLogs.
     * @param {SystemJobLogCreateManyArgs} args - Arguments to create many SystemJobLogs.
     * @example
     * // Create many SystemJobLogs
     * const systemJobLog = await prisma.systemJobLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemJobLogCreateManyArgs>(args?: SelectSubset<T, SystemJobLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemJobLogs and returns the data saved in the database.
     * @param {SystemJobLogCreateManyAndReturnArgs} args - Arguments to create many SystemJobLogs.
     * @example
     * // Create many SystemJobLogs
     * const systemJobLog = await prisma.systemJobLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemJobLogs and only return the `id`
     * const systemJobLogWithIdOnly = await prisma.systemJobLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemJobLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemJobLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemJobLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemJobLog.
     * @param {SystemJobLogDeleteArgs} args - Arguments to delete one SystemJobLog.
     * @example
     * // Delete one SystemJobLog
     * const SystemJobLog = await prisma.systemJobLog.delete({
     *   where: {
     *     // ... filter to delete one SystemJobLog
     *   }
     * })
     * 
     */
    delete<T extends SystemJobLogDeleteArgs>(args: SelectSubset<T, SystemJobLogDeleteArgs<ExtArgs>>): Prisma__SystemJobLogClient<$Result.GetResult<Prisma.$SystemJobLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemJobLog.
     * @param {SystemJobLogUpdateArgs} args - Arguments to update one SystemJobLog.
     * @example
     * // Update one SystemJobLog
     * const systemJobLog = await prisma.systemJobLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemJobLogUpdateArgs>(args: SelectSubset<T, SystemJobLogUpdateArgs<ExtArgs>>): Prisma__SystemJobLogClient<$Result.GetResult<Prisma.$SystemJobLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemJobLogs.
     * @param {SystemJobLogDeleteManyArgs} args - Arguments to filter SystemJobLogs to delete.
     * @example
     * // Delete a few SystemJobLogs
     * const { count } = await prisma.systemJobLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemJobLogDeleteManyArgs>(args?: SelectSubset<T, SystemJobLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemJobLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemJobLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemJobLogs
     * const systemJobLog = await prisma.systemJobLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemJobLogUpdateManyArgs>(args: SelectSubset<T, SystemJobLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemJobLogs and returns the data updated in the database.
     * @param {SystemJobLogUpdateManyAndReturnArgs} args - Arguments to update many SystemJobLogs.
     * @example
     * // Update many SystemJobLogs
     * const systemJobLog = await prisma.systemJobLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemJobLogs and only return the `id`
     * const systemJobLogWithIdOnly = await prisma.systemJobLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemJobLogUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemJobLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemJobLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemJobLog.
     * @param {SystemJobLogUpsertArgs} args - Arguments to update or create a SystemJobLog.
     * @example
     * // Update or create a SystemJobLog
     * const systemJobLog = await prisma.systemJobLog.upsert({
     *   create: {
     *     // ... data to create a SystemJobLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemJobLog we want to update
     *   }
     * })
     */
    upsert<T extends SystemJobLogUpsertArgs>(args: SelectSubset<T, SystemJobLogUpsertArgs<ExtArgs>>): Prisma__SystemJobLogClient<$Result.GetResult<Prisma.$SystemJobLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemJobLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemJobLogCountArgs} args - Arguments to filter SystemJobLogs to count.
     * @example
     * // Count the number of SystemJobLogs
     * const count = await prisma.systemJobLog.count({
     *   where: {
     *     // ... the filter for the SystemJobLogs we want to count
     *   }
     * })
    **/
    count<T extends SystemJobLogCountArgs>(
      args?: Subset<T, SystemJobLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemJobLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemJobLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemJobLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemJobLogAggregateArgs>(args: Subset<T, SystemJobLogAggregateArgs>): Prisma.PrismaPromise<GetSystemJobLogAggregateType<T>>

    /**
     * Group by SystemJobLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemJobLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemJobLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemJobLogGroupByArgs['orderBy'] }
        : { orderBy?: SystemJobLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemJobLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemJobLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemJobLog model
   */
  readonly fields: SystemJobLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemJobLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemJobLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemJobLog model
   */
  interface SystemJobLogFieldRefs {
    readonly id: FieldRef<"SystemJobLog", 'String'>
    readonly jobName: FieldRef<"SystemJobLog", 'String'>
    readonly status: FieldRef<"SystemJobLog", 'String'>
    readonly message: FieldRef<"SystemJobLog", 'String'>
    readonly createdAt: FieldRef<"SystemJobLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemJobLog findUnique
   */
  export type SystemJobLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemJobLog
     */
    select?: SystemJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemJobLog
     */
    omit?: SystemJobLogOmit<ExtArgs> | null
    /**
     * Filter, which SystemJobLog to fetch.
     */
    where: SystemJobLogWhereUniqueInput
  }

  /**
   * SystemJobLog findUniqueOrThrow
   */
  export type SystemJobLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemJobLog
     */
    select?: SystemJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemJobLog
     */
    omit?: SystemJobLogOmit<ExtArgs> | null
    /**
     * Filter, which SystemJobLog to fetch.
     */
    where: SystemJobLogWhereUniqueInput
  }

  /**
   * SystemJobLog findFirst
   */
  export type SystemJobLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemJobLog
     */
    select?: SystemJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemJobLog
     */
    omit?: SystemJobLogOmit<ExtArgs> | null
    /**
     * Filter, which SystemJobLog to fetch.
     */
    where?: SystemJobLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemJobLogs to fetch.
     */
    orderBy?: SystemJobLogOrderByWithRelationInput | SystemJobLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemJobLogs.
     */
    cursor?: SystemJobLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemJobLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemJobLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemJobLogs.
     */
    distinct?: SystemJobLogScalarFieldEnum | SystemJobLogScalarFieldEnum[]
  }

  /**
   * SystemJobLog findFirstOrThrow
   */
  export type SystemJobLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemJobLog
     */
    select?: SystemJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemJobLog
     */
    omit?: SystemJobLogOmit<ExtArgs> | null
    /**
     * Filter, which SystemJobLog to fetch.
     */
    where?: SystemJobLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemJobLogs to fetch.
     */
    orderBy?: SystemJobLogOrderByWithRelationInput | SystemJobLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemJobLogs.
     */
    cursor?: SystemJobLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemJobLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemJobLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemJobLogs.
     */
    distinct?: SystemJobLogScalarFieldEnum | SystemJobLogScalarFieldEnum[]
  }

  /**
   * SystemJobLog findMany
   */
  export type SystemJobLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemJobLog
     */
    select?: SystemJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemJobLog
     */
    omit?: SystemJobLogOmit<ExtArgs> | null
    /**
     * Filter, which SystemJobLogs to fetch.
     */
    where?: SystemJobLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemJobLogs to fetch.
     */
    orderBy?: SystemJobLogOrderByWithRelationInput | SystemJobLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemJobLogs.
     */
    cursor?: SystemJobLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemJobLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemJobLogs.
     */
    skip?: number
    distinct?: SystemJobLogScalarFieldEnum | SystemJobLogScalarFieldEnum[]
  }

  /**
   * SystemJobLog create
   */
  export type SystemJobLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemJobLog
     */
    select?: SystemJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemJobLog
     */
    omit?: SystemJobLogOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemJobLog.
     */
    data: XOR<SystemJobLogCreateInput, SystemJobLogUncheckedCreateInput>
  }

  /**
   * SystemJobLog createMany
   */
  export type SystemJobLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemJobLogs.
     */
    data: SystemJobLogCreateManyInput | SystemJobLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemJobLog createManyAndReturn
   */
  export type SystemJobLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemJobLog
     */
    select?: SystemJobLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemJobLog
     */
    omit?: SystemJobLogOmit<ExtArgs> | null
    /**
     * The data used to create many SystemJobLogs.
     */
    data: SystemJobLogCreateManyInput | SystemJobLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemJobLog update
   */
  export type SystemJobLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemJobLog
     */
    select?: SystemJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemJobLog
     */
    omit?: SystemJobLogOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemJobLog.
     */
    data: XOR<SystemJobLogUpdateInput, SystemJobLogUncheckedUpdateInput>
    /**
     * Choose, which SystemJobLog to update.
     */
    where: SystemJobLogWhereUniqueInput
  }

  /**
   * SystemJobLog updateMany
   */
  export type SystemJobLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemJobLogs.
     */
    data: XOR<SystemJobLogUpdateManyMutationInput, SystemJobLogUncheckedUpdateManyInput>
    /**
     * Filter which SystemJobLogs to update
     */
    where?: SystemJobLogWhereInput
    /**
     * Limit how many SystemJobLogs to update.
     */
    limit?: number
  }

  /**
   * SystemJobLog updateManyAndReturn
   */
  export type SystemJobLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemJobLog
     */
    select?: SystemJobLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemJobLog
     */
    omit?: SystemJobLogOmit<ExtArgs> | null
    /**
     * The data used to update SystemJobLogs.
     */
    data: XOR<SystemJobLogUpdateManyMutationInput, SystemJobLogUncheckedUpdateManyInput>
    /**
     * Filter which SystemJobLogs to update
     */
    where?: SystemJobLogWhereInput
    /**
     * Limit how many SystemJobLogs to update.
     */
    limit?: number
  }

  /**
   * SystemJobLog upsert
   */
  export type SystemJobLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemJobLog
     */
    select?: SystemJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemJobLog
     */
    omit?: SystemJobLogOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemJobLog to update in case it exists.
     */
    where: SystemJobLogWhereUniqueInput
    /**
     * In case the SystemJobLog found by the `where` argument doesn't exist, create a new SystemJobLog with this data.
     */
    create: XOR<SystemJobLogCreateInput, SystemJobLogUncheckedCreateInput>
    /**
     * In case the SystemJobLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemJobLogUpdateInput, SystemJobLogUncheckedUpdateInput>
  }

  /**
   * SystemJobLog delete
   */
  export type SystemJobLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemJobLog
     */
    select?: SystemJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemJobLog
     */
    omit?: SystemJobLogOmit<ExtArgs> | null
    /**
     * Filter which SystemJobLog to delete.
     */
    where: SystemJobLogWhereUniqueInput
  }

  /**
   * SystemJobLog deleteMany
   */
  export type SystemJobLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemJobLogs to delete
     */
    where?: SystemJobLogWhereInput
    /**
     * Limit how many SystemJobLogs to delete.
     */
    limit?: number
  }

  /**
   * SystemJobLog without action
   */
  export type SystemJobLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemJobLog
     */
    select?: SystemJobLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemJobLog
     */
    omit?: SystemJobLogOmit<ExtArgs> | null
  }


  /**
   * Model IdempotencyKey
   */

  export type AggregateIdempotencyKey = {
    _count: IdempotencyKeyCountAggregateOutputType | null
    _min: IdempotencyKeyMinAggregateOutputType | null
    _max: IdempotencyKeyMaxAggregateOutputType | null
  }

  export type IdempotencyKeyMinAggregateOutputType = {
    id: string | null
    key: string | null
    createdAt: Date | null
  }

  export type IdempotencyKeyMaxAggregateOutputType = {
    id: string | null
    key: string | null
    createdAt: Date | null
  }

  export type IdempotencyKeyCountAggregateOutputType = {
    id: number
    key: number
    createdAt: number
    response: number
    _all: number
  }


  export type IdempotencyKeyMinAggregateInputType = {
    id?: true
    key?: true
    createdAt?: true
  }

  export type IdempotencyKeyMaxAggregateInputType = {
    id?: true
    key?: true
    createdAt?: true
  }

  export type IdempotencyKeyCountAggregateInputType = {
    id?: true
    key?: true
    createdAt?: true
    response?: true
    _all?: true
  }

  export type IdempotencyKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IdempotencyKey to aggregate.
     */
    where?: IdempotencyKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdempotencyKeys to fetch.
     */
    orderBy?: IdempotencyKeyOrderByWithRelationInput | IdempotencyKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IdempotencyKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdempotencyKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdempotencyKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IdempotencyKeys
    **/
    _count?: true | IdempotencyKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IdempotencyKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IdempotencyKeyMaxAggregateInputType
  }

  export type GetIdempotencyKeyAggregateType<T extends IdempotencyKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateIdempotencyKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIdempotencyKey[P]>
      : GetScalarType<T[P], AggregateIdempotencyKey[P]>
  }




  export type IdempotencyKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdempotencyKeyWhereInput
    orderBy?: IdempotencyKeyOrderByWithAggregationInput | IdempotencyKeyOrderByWithAggregationInput[]
    by: IdempotencyKeyScalarFieldEnum[] | IdempotencyKeyScalarFieldEnum
    having?: IdempotencyKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IdempotencyKeyCountAggregateInputType | true
    _min?: IdempotencyKeyMinAggregateInputType
    _max?: IdempotencyKeyMaxAggregateInputType
  }

  export type IdempotencyKeyGroupByOutputType = {
    id: string
    key: string
    createdAt: Date
    response: JsonValue | null
    _count: IdempotencyKeyCountAggregateOutputType | null
    _min: IdempotencyKeyMinAggregateOutputType | null
    _max: IdempotencyKeyMaxAggregateOutputType | null
  }

  type GetIdempotencyKeyGroupByPayload<T extends IdempotencyKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IdempotencyKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IdempotencyKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IdempotencyKeyGroupByOutputType[P]>
            : GetScalarType<T[P], IdempotencyKeyGroupByOutputType[P]>
        }
      >
    >


  export type IdempotencyKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    createdAt?: boolean
    response?: boolean
  }, ExtArgs["result"]["idempotencyKey"]>

  export type IdempotencyKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    createdAt?: boolean
    response?: boolean
  }, ExtArgs["result"]["idempotencyKey"]>

  export type IdempotencyKeySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    createdAt?: boolean
    response?: boolean
  }, ExtArgs["result"]["idempotencyKey"]>

  export type IdempotencyKeySelectScalar = {
    id?: boolean
    key?: boolean
    createdAt?: boolean
    response?: boolean
  }

  export type IdempotencyKeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "createdAt" | "response", ExtArgs["result"]["idempotencyKey"]>

  export type $IdempotencyKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IdempotencyKey"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      createdAt: Date
      response: Prisma.JsonValue | null
    }, ExtArgs["result"]["idempotencyKey"]>
    composites: {}
  }

  type IdempotencyKeyGetPayload<S extends boolean | null | undefined | IdempotencyKeyDefaultArgs> = $Result.GetResult<Prisma.$IdempotencyKeyPayload, S>

  type IdempotencyKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IdempotencyKeyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IdempotencyKeyCountAggregateInputType | true
    }

  export interface IdempotencyKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IdempotencyKey'], meta: { name: 'IdempotencyKey' } }
    /**
     * Find zero or one IdempotencyKey that matches the filter.
     * @param {IdempotencyKeyFindUniqueArgs} args - Arguments to find a IdempotencyKey
     * @example
     * // Get one IdempotencyKey
     * const idempotencyKey = await prisma.idempotencyKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IdempotencyKeyFindUniqueArgs>(args: SelectSubset<T, IdempotencyKeyFindUniqueArgs<ExtArgs>>): Prisma__IdempotencyKeyClient<$Result.GetResult<Prisma.$IdempotencyKeyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IdempotencyKey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IdempotencyKeyFindUniqueOrThrowArgs} args - Arguments to find a IdempotencyKey
     * @example
     * // Get one IdempotencyKey
     * const idempotencyKey = await prisma.idempotencyKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IdempotencyKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, IdempotencyKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IdempotencyKeyClient<$Result.GetResult<Prisma.$IdempotencyKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IdempotencyKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdempotencyKeyFindFirstArgs} args - Arguments to find a IdempotencyKey
     * @example
     * // Get one IdempotencyKey
     * const idempotencyKey = await prisma.idempotencyKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IdempotencyKeyFindFirstArgs>(args?: SelectSubset<T, IdempotencyKeyFindFirstArgs<ExtArgs>>): Prisma__IdempotencyKeyClient<$Result.GetResult<Prisma.$IdempotencyKeyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IdempotencyKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdempotencyKeyFindFirstOrThrowArgs} args - Arguments to find a IdempotencyKey
     * @example
     * // Get one IdempotencyKey
     * const idempotencyKey = await prisma.idempotencyKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IdempotencyKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, IdempotencyKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__IdempotencyKeyClient<$Result.GetResult<Prisma.$IdempotencyKeyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IdempotencyKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdempotencyKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IdempotencyKeys
     * const idempotencyKeys = await prisma.idempotencyKey.findMany()
     * 
     * // Get first 10 IdempotencyKeys
     * const idempotencyKeys = await prisma.idempotencyKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const idempotencyKeyWithIdOnly = await prisma.idempotencyKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IdempotencyKeyFindManyArgs>(args?: SelectSubset<T, IdempotencyKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdempotencyKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IdempotencyKey.
     * @param {IdempotencyKeyCreateArgs} args - Arguments to create a IdempotencyKey.
     * @example
     * // Create one IdempotencyKey
     * const IdempotencyKey = await prisma.idempotencyKey.create({
     *   data: {
     *     // ... data to create a IdempotencyKey
     *   }
     * })
     * 
     */
    create<T extends IdempotencyKeyCreateArgs>(args: SelectSubset<T, IdempotencyKeyCreateArgs<ExtArgs>>): Prisma__IdempotencyKeyClient<$Result.GetResult<Prisma.$IdempotencyKeyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IdempotencyKeys.
     * @param {IdempotencyKeyCreateManyArgs} args - Arguments to create many IdempotencyKeys.
     * @example
     * // Create many IdempotencyKeys
     * const idempotencyKey = await prisma.idempotencyKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IdempotencyKeyCreateManyArgs>(args?: SelectSubset<T, IdempotencyKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IdempotencyKeys and returns the data saved in the database.
     * @param {IdempotencyKeyCreateManyAndReturnArgs} args - Arguments to create many IdempotencyKeys.
     * @example
     * // Create many IdempotencyKeys
     * const idempotencyKey = await prisma.idempotencyKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IdempotencyKeys and only return the `id`
     * const idempotencyKeyWithIdOnly = await prisma.idempotencyKey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IdempotencyKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, IdempotencyKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdempotencyKeyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IdempotencyKey.
     * @param {IdempotencyKeyDeleteArgs} args - Arguments to delete one IdempotencyKey.
     * @example
     * // Delete one IdempotencyKey
     * const IdempotencyKey = await prisma.idempotencyKey.delete({
     *   where: {
     *     // ... filter to delete one IdempotencyKey
     *   }
     * })
     * 
     */
    delete<T extends IdempotencyKeyDeleteArgs>(args: SelectSubset<T, IdempotencyKeyDeleteArgs<ExtArgs>>): Prisma__IdempotencyKeyClient<$Result.GetResult<Prisma.$IdempotencyKeyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IdempotencyKey.
     * @param {IdempotencyKeyUpdateArgs} args - Arguments to update one IdempotencyKey.
     * @example
     * // Update one IdempotencyKey
     * const idempotencyKey = await prisma.idempotencyKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IdempotencyKeyUpdateArgs>(args: SelectSubset<T, IdempotencyKeyUpdateArgs<ExtArgs>>): Prisma__IdempotencyKeyClient<$Result.GetResult<Prisma.$IdempotencyKeyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IdempotencyKeys.
     * @param {IdempotencyKeyDeleteManyArgs} args - Arguments to filter IdempotencyKeys to delete.
     * @example
     * // Delete a few IdempotencyKeys
     * const { count } = await prisma.idempotencyKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IdempotencyKeyDeleteManyArgs>(args?: SelectSubset<T, IdempotencyKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IdempotencyKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdempotencyKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IdempotencyKeys
     * const idempotencyKey = await prisma.idempotencyKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IdempotencyKeyUpdateManyArgs>(args: SelectSubset<T, IdempotencyKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IdempotencyKeys and returns the data updated in the database.
     * @param {IdempotencyKeyUpdateManyAndReturnArgs} args - Arguments to update many IdempotencyKeys.
     * @example
     * // Update many IdempotencyKeys
     * const idempotencyKey = await prisma.idempotencyKey.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IdempotencyKeys and only return the `id`
     * const idempotencyKeyWithIdOnly = await prisma.idempotencyKey.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IdempotencyKeyUpdateManyAndReturnArgs>(args: SelectSubset<T, IdempotencyKeyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdempotencyKeyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IdempotencyKey.
     * @param {IdempotencyKeyUpsertArgs} args - Arguments to update or create a IdempotencyKey.
     * @example
     * // Update or create a IdempotencyKey
     * const idempotencyKey = await prisma.idempotencyKey.upsert({
     *   create: {
     *     // ... data to create a IdempotencyKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IdempotencyKey we want to update
     *   }
     * })
     */
    upsert<T extends IdempotencyKeyUpsertArgs>(args: SelectSubset<T, IdempotencyKeyUpsertArgs<ExtArgs>>): Prisma__IdempotencyKeyClient<$Result.GetResult<Prisma.$IdempotencyKeyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IdempotencyKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdempotencyKeyCountArgs} args - Arguments to filter IdempotencyKeys to count.
     * @example
     * // Count the number of IdempotencyKeys
     * const count = await prisma.idempotencyKey.count({
     *   where: {
     *     // ... the filter for the IdempotencyKeys we want to count
     *   }
     * })
    **/
    count<T extends IdempotencyKeyCountArgs>(
      args?: Subset<T, IdempotencyKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IdempotencyKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IdempotencyKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdempotencyKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IdempotencyKeyAggregateArgs>(args: Subset<T, IdempotencyKeyAggregateArgs>): Prisma.PrismaPromise<GetIdempotencyKeyAggregateType<T>>

    /**
     * Group by IdempotencyKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdempotencyKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IdempotencyKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IdempotencyKeyGroupByArgs['orderBy'] }
        : { orderBy?: IdempotencyKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IdempotencyKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIdempotencyKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IdempotencyKey model
   */
  readonly fields: IdempotencyKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IdempotencyKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IdempotencyKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IdempotencyKey model
   */
  interface IdempotencyKeyFieldRefs {
    readonly id: FieldRef<"IdempotencyKey", 'String'>
    readonly key: FieldRef<"IdempotencyKey", 'String'>
    readonly createdAt: FieldRef<"IdempotencyKey", 'DateTime'>
    readonly response: FieldRef<"IdempotencyKey", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * IdempotencyKey findUnique
   */
  export type IdempotencyKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdempotencyKey
     */
    select?: IdempotencyKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdempotencyKey
     */
    omit?: IdempotencyKeyOmit<ExtArgs> | null
    /**
     * Filter, which IdempotencyKey to fetch.
     */
    where: IdempotencyKeyWhereUniqueInput
  }

  /**
   * IdempotencyKey findUniqueOrThrow
   */
  export type IdempotencyKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdempotencyKey
     */
    select?: IdempotencyKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdempotencyKey
     */
    omit?: IdempotencyKeyOmit<ExtArgs> | null
    /**
     * Filter, which IdempotencyKey to fetch.
     */
    where: IdempotencyKeyWhereUniqueInput
  }

  /**
   * IdempotencyKey findFirst
   */
  export type IdempotencyKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdempotencyKey
     */
    select?: IdempotencyKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdempotencyKey
     */
    omit?: IdempotencyKeyOmit<ExtArgs> | null
    /**
     * Filter, which IdempotencyKey to fetch.
     */
    where?: IdempotencyKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdempotencyKeys to fetch.
     */
    orderBy?: IdempotencyKeyOrderByWithRelationInput | IdempotencyKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IdempotencyKeys.
     */
    cursor?: IdempotencyKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdempotencyKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdempotencyKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IdempotencyKeys.
     */
    distinct?: IdempotencyKeyScalarFieldEnum | IdempotencyKeyScalarFieldEnum[]
  }

  /**
   * IdempotencyKey findFirstOrThrow
   */
  export type IdempotencyKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdempotencyKey
     */
    select?: IdempotencyKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdempotencyKey
     */
    omit?: IdempotencyKeyOmit<ExtArgs> | null
    /**
     * Filter, which IdempotencyKey to fetch.
     */
    where?: IdempotencyKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdempotencyKeys to fetch.
     */
    orderBy?: IdempotencyKeyOrderByWithRelationInput | IdempotencyKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IdempotencyKeys.
     */
    cursor?: IdempotencyKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdempotencyKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdempotencyKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IdempotencyKeys.
     */
    distinct?: IdempotencyKeyScalarFieldEnum | IdempotencyKeyScalarFieldEnum[]
  }

  /**
   * IdempotencyKey findMany
   */
  export type IdempotencyKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdempotencyKey
     */
    select?: IdempotencyKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdempotencyKey
     */
    omit?: IdempotencyKeyOmit<ExtArgs> | null
    /**
     * Filter, which IdempotencyKeys to fetch.
     */
    where?: IdempotencyKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdempotencyKeys to fetch.
     */
    orderBy?: IdempotencyKeyOrderByWithRelationInput | IdempotencyKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IdempotencyKeys.
     */
    cursor?: IdempotencyKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdempotencyKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdempotencyKeys.
     */
    skip?: number
    distinct?: IdempotencyKeyScalarFieldEnum | IdempotencyKeyScalarFieldEnum[]
  }

  /**
   * IdempotencyKey create
   */
  export type IdempotencyKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdempotencyKey
     */
    select?: IdempotencyKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdempotencyKey
     */
    omit?: IdempotencyKeyOmit<ExtArgs> | null
    /**
     * The data needed to create a IdempotencyKey.
     */
    data: XOR<IdempotencyKeyCreateInput, IdempotencyKeyUncheckedCreateInput>
  }

  /**
   * IdempotencyKey createMany
   */
  export type IdempotencyKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IdempotencyKeys.
     */
    data: IdempotencyKeyCreateManyInput | IdempotencyKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IdempotencyKey createManyAndReturn
   */
  export type IdempotencyKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdempotencyKey
     */
    select?: IdempotencyKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IdempotencyKey
     */
    omit?: IdempotencyKeyOmit<ExtArgs> | null
    /**
     * The data used to create many IdempotencyKeys.
     */
    data: IdempotencyKeyCreateManyInput | IdempotencyKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IdempotencyKey update
   */
  export type IdempotencyKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdempotencyKey
     */
    select?: IdempotencyKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdempotencyKey
     */
    omit?: IdempotencyKeyOmit<ExtArgs> | null
    /**
     * The data needed to update a IdempotencyKey.
     */
    data: XOR<IdempotencyKeyUpdateInput, IdempotencyKeyUncheckedUpdateInput>
    /**
     * Choose, which IdempotencyKey to update.
     */
    where: IdempotencyKeyWhereUniqueInput
  }

  /**
   * IdempotencyKey updateMany
   */
  export type IdempotencyKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IdempotencyKeys.
     */
    data: XOR<IdempotencyKeyUpdateManyMutationInput, IdempotencyKeyUncheckedUpdateManyInput>
    /**
     * Filter which IdempotencyKeys to update
     */
    where?: IdempotencyKeyWhereInput
    /**
     * Limit how many IdempotencyKeys to update.
     */
    limit?: number
  }

  /**
   * IdempotencyKey updateManyAndReturn
   */
  export type IdempotencyKeyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdempotencyKey
     */
    select?: IdempotencyKeySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IdempotencyKey
     */
    omit?: IdempotencyKeyOmit<ExtArgs> | null
    /**
     * The data used to update IdempotencyKeys.
     */
    data: XOR<IdempotencyKeyUpdateManyMutationInput, IdempotencyKeyUncheckedUpdateManyInput>
    /**
     * Filter which IdempotencyKeys to update
     */
    where?: IdempotencyKeyWhereInput
    /**
     * Limit how many IdempotencyKeys to update.
     */
    limit?: number
  }

  /**
   * IdempotencyKey upsert
   */
  export type IdempotencyKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdempotencyKey
     */
    select?: IdempotencyKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdempotencyKey
     */
    omit?: IdempotencyKeyOmit<ExtArgs> | null
    /**
     * The filter to search for the IdempotencyKey to update in case it exists.
     */
    where: IdempotencyKeyWhereUniqueInput
    /**
     * In case the IdempotencyKey found by the `where` argument doesn't exist, create a new IdempotencyKey with this data.
     */
    create: XOR<IdempotencyKeyCreateInput, IdempotencyKeyUncheckedCreateInput>
    /**
     * In case the IdempotencyKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IdempotencyKeyUpdateInput, IdempotencyKeyUncheckedUpdateInput>
  }

  /**
   * IdempotencyKey delete
   */
  export type IdempotencyKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdempotencyKey
     */
    select?: IdempotencyKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdempotencyKey
     */
    omit?: IdempotencyKeyOmit<ExtArgs> | null
    /**
     * Filter which IdempotencyKey to delete.
     */
    where: IdempotencyKeyWhereUniqueInput
  }

  /**
   * IdempotencyKey deleteMany
   */
  export type IdempotencyKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IdempotencyKeys to delete
     */
    where?: IdempotencyKeyWhereInput
    /**
     * Limit how many IdempotencyKeys to delete.
     */
    limit?: number
  }

  /**
   * IdempotencyKey without action
   */
  export type IdempotencyKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdempotencyKey
     */
    select?: IdempotencyKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdempotencyKey
     */
    omit?: IdempotencyKeyOmit<ExtArgs> | null
  }


  /**
   * Model JobQueue
   */

  export type AggregateJobQueue = {
    _count: JobQueueCountAggregateOutputType | null
    _avg: JobQueueAvgAggregateOutputType | null
    _sum: JobQueueSumAggregateOutputType | null
    _min: JobQueueMinAggregateOutputType | null
    _max: JobQueueMaxAggregateOutputType | null
  }

  export type JobQueueAvgAggregateOutputType = {
    retryCount: number | null
  }

  export type JobQueueSumAggregateOutputType = {
    retryCount: number | null
  }

  export type JobQueueMinAggregateOutputType = {
    id: string | null
    type: string | null
    status: string | null
    retryCount: number | null
    runAt: Date | null
    createdAt: Date | null
    processedAt: Date | null
    error: string | null
  }

  export type JobQueueMaxAggregateOutputType = {
    id: string | null
    type: string | null
    status: string | null
    retryCount: number | null
    runAt: Date | null
    createdAt: Date | null
    processedAt: Date | null
    error: string | null
  }

  export type JobQueueCountAggregateOutputType = {
    id: number
    type: number
    payload: number
    status: number
    retryCount: number
    runAt: number
    createdAt: number
    processedAt: number
    error: number
    _all: number
  }


  export type JobQueueAvgAggregateInputType = {
    retryCount?: true
  }

  export type JobQueueSumAggregateInputType = {
    retryCount?: true
  }

  export type JobQueueMinAggregateInputType = {
    id?: true
    type?: true
    status?: true
    retryCount?: true
    runAt?: true
    createdAt?: true
    processedAt?: true
    error?: true
  }

  export type JobQueueMaxAggregateInputType = {
    id?: true
    type?: true
    status?: true
    retryCount?: true
    runAt?: true
    createdAt?: true
    processedAt?: true
    error?: true
  }

  export type JobQueueCountAggregateInputType = {
    id?: true
    type?: true
    payload?: true
    status?: true
    retryCount?: true
    runAt?: true
    createdAt?: true
    processedAt?: true
    error?: true
    _all?: true
  }

  export type JobQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobQueue to aggregate.
     */
    where?: JobQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobQueues to fetch.
     */
    orderBy?: JobQueueOrderByWithRelationInput | JobQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobQueues
    **/
    _count?: true | JobQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobQueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobQueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobQueueMaxAggregateInputType
  }

  export type GetJobQueueAggregateType<T extends JobQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateJobQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobQueue[P]>
      : GetScalarType<T[P], AggregateJobQueue[P]>
  }




  export type JobQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobQueueWhereInput
    orderBy?: JobQueueOrderByWithAggregationInput | JobQueueOrderByWithAggregationInput[]
    by: JobQueueScalarFieldEnum[] | JobQueueScalarFieldEnum
    having?: JobQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobQueueCountAggregateInputType | true
    _avg?: JobQueueAvgAggregateInputType
    _sum?: JobQueueSumAggregateInputType
    _min?: JobQueueMinAggregateInputType
    _max?: JobQueueMaxAggregateInputType
  }

  export type JobQueueGroupByOutputType = {
    id: string
    type: string
    payload: JsonValue
    status: string
    retryCount: number
    runAt: Date | null
    createdAt: Date
    processedAt: Date | null
    error: string | null
    _count: JobQueueCountAggregateOutputType | null
    _avg: JobQueueAvgAggregateOutputType | null
    _sum: JobQueueSumAggregateOutputType | null
    _min: JobQueueMinAggregateOutputType | null
    _max: JobQueueMaxAggregateOutputType | null
  }

  type GetJobQueueGroupByPayload<T extends JobQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobQueueGroupByOutputType[P]>
            : GetScalarType<T[P], JobQueueGroupByOutputType[P]>
        }
      >
    >


  export type JobQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    payload?: boolean
    status?: boolean
    retryCount?: boolean
    runAt?: boolean
    createdAt?: boolean
    processedAt?: boolean
    error?: boolean
  }, ExtArgs["result"]["jobQueue"]>

  export type JobQueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    payload?: boolean
    status?: boolean
    retryCount?: boolean
    runAt?: boolean
    createdAt?: boolean
    processedAt?: boolean
    error?: boolean
  }, ExtArgs["result"]["jobQueue"]>

  export type JobQueueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    payload?: boolean
    status?: boolean
    retryCount?: boolean
    runAt?: boolean
    createdAt?: boolean
    processedAt?: boolean
    error?: boolean
  }, ExtArgs["result"]["jobQueue"]>

  export type JobQueueSelectScalar = {
    id?: boolean
    type?: boolean
    payload?: boolean
    status?: boolean
    retryCount?: boolean
    runAt?: boolean
    createdAt?: boolean
    processedAt?: boolean
    error?: boolean
  }

  export type JobQueueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "payload" | "status" | "retryCount" | "runAt" | "createdAt" | "processedAt" | "error", ExtArgs["result"]["jobQueue"]>

  export type $JobQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobQueue"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      payload: Prisma.JsonValue
      status: string
      retryCount: number
      runAt: Date | null
      createdAt: Date
      processedAt: Date | null
      error: string | null
    }, ExtArgs["result"]["jobQueue"]>
    composites: {}
  }

  type JobQueueGetPayload<S extends boolean | null | undefined | JobQueueDefaultArgs> = $Result.GetResult<Prisma.$JobQueuePayload, S>

  type JobQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobQueueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobQueueCountAggregateInputType | true
    }

  export interface JobQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobQueue'], meta: { name: 'JobQueue' } }
    /**
     * Find zero or one JobQueue that matches the filter.
     * @param {JobQueueFindUniqueArgs} args - Arguments to find a JobQueue
     * @example
     * // Get one JobQueue
     * const jobQueue = await prisma.jobQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobQueueFindUniqueArgs>(args: SelectSubset<T, JobQueueFindUniqueArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobQueue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobQueueFindUniqueOrThrowArgs} args - Arguments to find a JobQueue
     * @example
     * // Get one JobQueue
     * const jobQueue = await prisma.jobQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, JobQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueFindFirstArgs} args - Arguments to find a JobQueue
     * @example
     * // Get one JobQueue
     * const jobQueue = await prisma.jobQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobQueueFindFirstArgs>(args?: SelectSubset<T, JobQueueFindFirstArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueFindFirstOrThrowArgs} args - Arguments to find a JobQueue
     * @example
     * // Get one JobQueue
     * const jobQueue = await prisma.jobQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, JobQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobQueues
     * const jobQueues = await prisma.jobQueue.findMany()
     * 
     * // Get first 10 JobQueues
     * const jobQueues = await prisma.jobQueue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobQueueWithIdOnly = await prisma.jobQueue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobQueueFindManyArgs>(args?: SelectSubset<T, JobQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobQueue.
     * @param {JobQueueCreateArgs} args - Arguments to create a JobQueue.
     * @example
     * // Create one JobQueue
     * const JobQueue = await prisma.jobQueue.create({
     *   data: {
     *     // ... data to create a JobQueue
     *   }
     * })
     * 
     */
    create<T extends JobQueueCreateArgs>(args: SelectSubset<T, JobQueueCreateArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobQueues.
     * @param {JobQueueCreateManyArgs} args - Arguments to create many JobQueues.
     * @example
     * // Create many JobQueues
     * const jobQueue = await prisma.jobQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobQueueCreateManyArgs>(args?: SelectSubset<T, JobQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobQueues and returns the data saved in the database.
     * @param {JobQueueCreateManyAndReturnArgs} args - Arguments to create many JobQueues.
     * @example
     * // Create many JobQueues
     * const jobQueue = await prisma.jobQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobQueues and only return the `id`
     * const jobQueueWithIdOnly = await prisma.jobQueue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobQueueCreateManyAndReturnArgs>(args?: SelectSubset<T, JobQueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobQueue.
     * @param {JobQueueDeleteArgs} args - Arguments to delete one JobQueue.
     * @example
     * // Delete one JobQueue
     * const JobQueue = await prisma.jobQueue.delete({
     *   where: {
     *     // ... filter to delete one JobQueue
     *   }
     * })
     * 
     */
    delete<T extends JobQueueDeleteArgs>(args: SelectSubset<T, JobQueueDeleteArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobQueue.
     * @param {JobQueueUpdateArgs} args - Arguments to update one JobQueue.
     * @example
     * // Update one JobQueue
     * const jobQueue = await prisma.jobQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobQueueUpdateArgs>(args: SelectSubset<T, JobQueueUpdateArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobQueues.
     * @param {JobQueueDeleteManyArgs} args - Arguments to filter JobQueues to delete.
     * @example
     * // Delete a few JobQueues
     * const { count } = await prisma.jobQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobQueueDeleteManyArgs>(args?: SelectSubset<T, JobQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobQueues
     * const jobQueue = await prisma.jobQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobQueueUpdateManyArgs>(args: SelectSubset<T, JobQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobQueues and returns the data updated in the database.
     * @param {JobQueueUpdateManyAndReturnArgs} args - Arguments to update many JobQueues.
     * @example
     * // Update many JobQueues
     * const jobQueue = await prisma.jobQueue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobQueues and only return the `id`
     * const jobQueueWithIdOnly = await prisma.jobQueue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobQueueUpdateManyAndReturnArgs>(args: SelectSubset<T, JobQueueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobQueue.
     * @param {JobQueueUpsertArgs} args - Arguments to update or create a JobQueue.
     * @example
     * // Update or create a JobQueue
     * const jobQueue = await prisma.jobQueue.upsert({
     *   create: {
     *     // ... data to create a JobQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobQueue we want to update
     *   }
     * })
     */
    upsert<T extends JobQueueUpsertArgs>(args: SelectSubset<T, JobQueueUpsertArgs<ExtArgs>>): Prisma__JobQueueClient<$Result.GetResult<Prisma.$JobQueuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueCountArgs} args - Arguments to filter JobQueues to count.
     * @example
     * // Count the number of JobQueues
     * const count = await prisma.jobQueue.count({
     *   where: {
     *     // ... the filter for the JobQueues we want to count
     *   }
     * })
    **/
    count<T extends JobQueueCountArgs>(
      args?: Subset<T, JobQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobQueueAggregateArgs>(args: Subset<T, JobQueueAggregateArgs>): Prisma.PrismaPromise<GetJobQueueAggregateType<T>>

    /**
     * Group by JobQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobQueueGroupByArgs['orderBy'] }
        : { orderBy?: JobQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobQueue model
   */
  readonly fields: JobQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobQueue model
   */
  interface JobQueueFieldRefs {
    readonly id: FieldRef<"JobQueue", 'String'>
    readonly type: FieldRef<"JobQueue", 'String'>
    readonly payload: FieldRef<"JobQueue", 'Json'>
    readonly status: FieldRef<"JobQueue", 'String'>
    readonly retryCount: FieldRef<"JobQueue", 'Int'>
    readonly runAt: FieldRef<"JobQueue", 'DateTime'>
    readonly createdAt: FieldRef<"JobQueue", 'DateTime'>
    readonly processedAt: FieldRef<"JobQueue", 'DateTime'>
    readonly error: FieldRef<"JobQueue", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JobQueue findUnique
   */
  export type JobQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobQueue
     */
    omit?: JobQueueOmit<ExtArgs> | null
    /**
     * Filter, which JobQueue to fetch.
     */
    where: JobQueueWhereUniqueInput
  }

  /**
   * JobQueue findUniqueOrThrow
   */
  export type JobQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobQueue
     */
    omit?: JobQueueOmit<ExtArgs> | null
    /**
     * Filter, which JobQueue to fetch.
     */
    where: JobQueueWhereUniqueInput
  }

  /**
   * JobQueue findFirst
   */
  export type JobQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobQueue
     */
    omit?: JobQueueOmit<ExtArgs> | null
    /**
     * Filter, which JobQueue to fetch.
     */
    where?: JobQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobQueues to fetch.
     */
    orderBy?: JobQueueOrderByWithRelationInput | JobQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobQueues.
     */
    cursor?: JobQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobQueues.
     */
    distinct?: JobQueueScalarFieldEnum | JobQueueScalarFieldEnum[]
  }

  /**
   * JobQueue findFirstOrThrow
   */
  export type JobQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobQueue
     */
    omit?: JobQueueOmit<ExtArgs> | null
    /**
     * Filter, which JobQueue to fetch.
     */
    where?: JobQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobQueues to fetch.
     */
    orderBy?: JobQueueOrderByWithRelationInput | JobQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobQueues.
     */
    cursor?: JobQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobQueues.
     */
    distinct?: JobQueueScalarFieldEnum | JobQueueScalarFieldEnum[]
  }

  /**
   * JobQueue findMany
   */
  export type JobQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobQueue
     */
    omit?: JobQueueOmit<ExtArgs> | null
    /**
     * Filter, which JobQueues to fetch.
     */
    where?: JobQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobQueues to fetch.
     */
    orderBy?: JobQueueOrderByWithRelationInput | JobQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobQueues.
     */
    cursor?: JobQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobQueues.
     */
    skip?: number
    distinct?: JobQueueScalarFieldEnum | JobQueueScalarFieldEnum[]
  }

  /**
   * JobQueue create
   */
  export type JobQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobQueue
     */
    omit?: JobQueueOmit<ExtArgs> | null
    /**
     * The data needed to create a JobQueue.
     */
    data: XOR<JobQueueCreateInput, JobQueueUncheckedCreateInput>
  }

  /**
   * JobQueue createMany
   */
  export type JobQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobQueues.
     */
    data: JobQueueCreateManyInput | JobQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobQueue createManyAndReturn
   */
  export type JobQueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobQueue
     */
    omit?: JobQueueOmit<ExtArgs> | null
    /**
     * The data used to create many JobQueues.
     */
    data: JobQueueCreateManyInput | JobQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobQueue update
   */
  export type JobQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobQueue
     */
    omit?: JobQueueOmit<ExtArgs> | null
    /**
     * The data needed to update a JobQueue.
     */
    data: XOR<JobQueueUpdateInput, JobQueueUncheckedUpdateInput>
    /**
     * Choose, which JobQueue to update.
     */
    where: JobQueueWhereUniqueInput
  }

  /**
   * JobQueue updateMany
   */
  export type JobQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobQueues.
     */
    data: XOR<JobQueueUpdateManyMutationInput, JobQueueUncheckedUpdateManyInput>
    /**
     * Filter which JobQueues to update
     */
    where?: JobQueueWhereInput
    /**
     * Limit how many JobQueues to update.
     */
    limit?: number
  }

  /**
   * JobQueue updateManyAndReturn
   */
  export type JobQueueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobQueue
     */
    omit?: JobQueueOmit<ExtArgs> | null
    /**
     * The data used to update JobQueues.
     */
    data: XOR<JobQueueUpdateManyMutationInput, JobQueueUncheckedUpdateManyInput>
    /**
     * Filter which JobQueues to update
     */
    where?: JobQueueWhereInput
    /**
     * Limit how many JobQueues to update.
     */
    limit?: number
  }

  /**
   * JobQueue upsert
   */
  export type JobQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobQueue
     */
    omit?: JobQueueOmit<ExtArgs> | null
    /**
     * The filter to search for the JobQueue to update in case it exists.
     */
    where: JobQueueWhereUniqueInput
    /**
     * In case the JobQueue found by the `where` argument doesn't exist, create a new JobQueue with this data.
     */
    create: XOR<JobQueueCreateInput, JobQueueUncheckedCreateInput>
    /**
     * In case the JobQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobQueueUpdateInput, JobQueueUncheckedUpdateInput>
  }

  /**
   * JobQueue delete
   */
  export type JobQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobQueue
     */
    omit?: JobQueueOmit<ExtArgs> | null
    /**
     * Filter which JobQueue to delete.
     */
    where: JobQueueWhereUniqueInput
  }

  /**
   * JobQueue deleteMany
   */
  export type JobQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobQueues to delete
     */
    where?: JobQueueWhereInput
    /**
     * Limit how many JobQueues to delete.
     */
    limit?: number
  }

  /**
   * JobQueue without action
   */
  export type JobQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobQueue
     */
    select?: JobQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobQueue
     */
    omit?: JobQueueOmit<ExtArgs> | null
  }


  /**
   * Model CronLock
   */

  export type AggregateCronLock = {
    _count: CronLockCountAggregateOutputType | null
    _min: CronLockMinAggregateOutputType | null
    _max: CronLockMaxAggregateOutputType | null
  }

  export type CronLockMinAggregateOutputType = {
    id: string | null
    lockedAt: Date | null
    lockedBy: string | null
  }

  export type CronLockMaxAggregateOutputType = {
    id: string | null
    lockedAt: Date | null
    lockedBy: string | null
  }

  export type CronLockCountAggregateOutputType = {
    id: number
    lockedAt: number
    lockedBy: number
    _all: number
  }


  export type CronLockMinAggregateInputType = {
    id?: true
    lockedAt?: true
    lockedBy?: true
  }

  export type CronLockMaxAggregateInputType = {
    id?: true
    lockedAt?: true
    lockedBy?: true
  }

  export type CronLockCountAggregateInputType = {
    id?: true
    lockedAt?: true
    lockedBy?: true
    _all?: true
  }

  export type CronLockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CronLock to aggregate.
     */
    where?: CronLockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CronLocks to fetch.
     */
    orderBy?: CronLockOrderByWithRelationInput | CronLockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CronLockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CronLocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CronLocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CronLocks
    **/
    _count?: true | CronLockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CronLockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CronLockMaxAggregateInputType
  }

  export type GetCronLockAggregateType<T extends CronLockAggregateArgs> = {
        [P in keyof T & keyof AggregateCronLock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCronLock[P]>
      : GetScalarType<T[P], AggregateCronLock[P]>
  }




  export type CronLockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CronLockWhereInput
    orderBy?: CronLockOrderByWithAggregationInput | CronLockOrderByWithAggregationInput[]
    by: CronLockScalarFieldEnum[] | CronLockScalarFieldEnum
    having?: CronLockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CronLockCountAggregateInputType | true
    _min?: CronLockMinAggregateInputType
    _max?: CronLockMaxAggregateInputType
  }

  export type CronLockGroupByOutputType = {
    id: string
    lockedAt: Date
    lockedBy: string | null
    _count: CronLockCountAggregateOutputType | null
    _min: CronLockMinAggregateOutputType | null
    _max: CronLockMaxAggregateOutputType | null
  }

  type GetCronLockGroupByPayload<T extends CronLockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CronLockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CronLockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CronLockGroupByOutputType[P]>
            : GetScalarType<T[P], CronLockGroupByOutputType[P]>
        }
      >
    >


  export type CronLockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lockedAt?: boolean
    lockedBy?: boolean
  }, ExtArgs["result"]["cronLock"]>

  export type CronLockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lockedAt?: boolean
    lockedBy?: boolean
  }, ExtArgs["result"]["cronLock"]>

  export type CronLockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lockedAt?: boolean
    lockedBy?: boolean
  }, ExtArgs["result"]["cronLock"]>

  export type CronLockSelectScalar = {
    id?: boolean
    lockedAt?: boolean
    lockedBy?: boolean
  }

  export type CronLockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lockedAt" | "lockedBy", ExtArgs["result"]["cronLock"]>

  export type $CronLockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CronLock"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lockedAt: Date
      lockedBy: string | null
    }, ExtArgs["result"]["cronLock"]>
    composites: {}
  }

  type CronLockGetPayload<S extends boolean | null | undefined | CronLockDefaultArgs> = $Result.GetResult<Prisma.$CronLockPayload, S>

  type CronLockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CronLockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CronLockCountAggregateInputType | true
    }

  export interface CronLockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CronLock'], meta: { name: 'CronLock' } }
    /**
     * Find zero or one CronLock that matches the filter.
     * @param {CronLockFindUniqueArgs} args - Arguments to find a CronLock
     * @example
     * // Get one CronLock
     * const cronLock = await prisma.cronLock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CronLockFindUniqueArgs>(args: SelectSubset<T, CronLockFindUniqueArgs<ExtArgs>>): Prisma__CronLockClient<$Result.GetResult<Prisma.$CronLockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CronLock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CronLockFindUniqueOrThrowArgs} args - Arguments to find a CronLock
     * @example
     * // Get one CronLock
     * const cronLock = await prisma.cronLock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CronLockFindUniqueOrThrowArgs>(args: SelectSubset<T, CronLockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CronLockClient<$Result.GetResult<Prisma.$CronLockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CronLock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronLockFindFirstArgs} args - Arguments to find a CronLock
     * @example
     * // Get one CronLock
     * const cronLock = await prisma.cronLock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CronLockFindFirstArgs>(args?: SelectSubset<T, CronLockFindFirstArgs<ExtArgs>>): Prisma__CronLockClient<$Result.GetResult<Prisma.$CronLockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CronLock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronLockFindFirstOrThrowArgs} args - Arguments to find a CronLock
     * @example
     * // Get one CronLock
     * const cronLock = await prisma.cronLock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CronLockFindFirstOrThrowArgs>(args?: SelectSubset<T, CronLockFindFirstOrThrowArgs<ExtArgs>>): Prisma__CronLockClient<$Result.GetResult<Prisma.$CronLockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CronLocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronLockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CronLocks
     * const cronLocks = await prisma.cronLock.findMany()
     * 
     * // Get first 10 CronLocks
     * const cronLocks = await prisma.cronLock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cronLockWithIdOnly = await prisma.cronLock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CronLockFindManyArgs>(args?: SelectSubset<T, CronLockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CronLockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CronLock.
     * @param {CronLockCreateArgs} args - Arguments to create a CronLock.
     * @example
     * // Create one CronLock
     * const CronLock = await prisma.cronLock.create({
     *   data: {
     *     // ... data to create a CronLock
     *   }
     * })
     * 
     */
    create<T extends CronLockCreateArgs>(args: SelectSubset<T, CronLockCreateArgs<ExtArgs>>): Prisma__CronLockClient<$Result.GetResult<Prisma.$CronLockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CronLocks.
     * @param {CronLockCreateManyArgs} args - Arguments to create many CronLocks.
     * @example
     * // Create many CronLocks
     * const cronLock = await prisma.cronLock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CronLockCreateManyArgs>(args?: SelectSubset<T, CronLockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CronLocks and returns the data saved in the database.
     * @param {CronLockCreateManyAndReturnArgs} args - Arguments to create many CronLocks.
     * @example
     * // Create many CronLocks
     * const cronLock = await prisma.cronLock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CronLocks and only return the `id`
     * const cronLockWithIdOnly = await prisma.cronLock.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CronLockCreateManyAndReturnArgs>(args?: SelectSubset<T, CronLockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CronLockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CronLock.
     * @param {CronLockDeleteArgs} args - Arguments to delete one CronLock.
     * @example
     * // Delete one CronLock
     * const CronLock = await prisma.cronLock.delete({
     *   where: {
     *     // ... filter to delete one CronLock
     *   }
     * })
     * 
     */
    delete<T extends CronLockDeleteArgs>(args: SelectSubset<T, CronLockDeleteArgs<ExtArgs>>): Prisma__CronLockClient<$Result.GetResult<Prisma.$CronLockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CronLock.
     * @param {CronLockUpdateArgs} args - Arguments to update one CronLock.
     * @example
     * // Update one CronLock
     * const cronLock = await prisma.cronLock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CronLockUpdateArgs>(args: SelectSubset<T, CronLockUpdateArgs<ExtArgs>>): Prisma__CronLockClient<$Result.GetResult<Prisma.$CronLockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CronLocks.
     * @param {CronLockDeleteManyArgs} args - Arguments to filter CronLocks to delete.
     * @example
     * // Delete a few CronLocks
     * const { count } = await prisma.cronLock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CronLockDeleteManyArgs>(args?: SelectSubset<T, CronLockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CronLocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronLockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CronLocks
     * const cronLock = await prisma.cronLock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CronLockUpdateManyArgs>(args: SelectSubset<T, CronLockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CronLocks and returns the data updated in the database.
     * @param {CronLockUpdateManyAndReturnArgs} args - Arguments to update many CronLocks.
     * @example
     * // Update many CronLocks
     * const cronLock = await prisma.cronLock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CronLocks and only return the `id`
     * const cronLockWithIdOnly = await prisma.cronLock.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CronLockUpdateManyAndReturnArgs>(args: SelectSubset<T, CronLockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CronLockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CronLock.
     * @param {CronLockUpsertArgs} args - Arguments to update or create a CronLock.
     * @example
     * // Update or create a CronLock
     * const cronLock = await prisma.cronLock.upsert({
     *   create: {
     *     // ... data to create a CronLock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CronLock we want to update
     *   }
     * })
     */
    upsert<T extends CronLockUpsertArgs>(args: SelectSubset<T, CronLockUpsertArgs<ExtArgs>>): Prisma__CronLockClient<$Result.GetResult<Prisma.$CronLockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CronLocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronLockCountArgs} args - Arguments to filter CronLocks to count.
     * @example
     * // Count the number of CronLocks
     * const count = await prisma.cronLock.count({
     *   where: {
     *     // ... the filter for the CronLocks we want to count
     *   }
     * })
    **/
    count<T extends CronLockCountArgs>(
      args?: Subset<T, CronLockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CronLockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CronLock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronLockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CronLockAggregateArgs>(args: Subset<T, CronLockAggregateArgs>): Prisma.PrismaPromise<GetCronLockAggregateType<T>>

    /**
     * Group by CronLock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronLockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CronLockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CronLockGroupByArgs['orderBy'] }
        : { orderBy?: CronLockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CronLockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCronLockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CronLock model
   */
  readonly fields: CronLockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CronLock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CronLockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CronLock model
   */
  interface CronLockFieldRefs {
    readonly id: FieldRef<"CronLock", 'String'>
    readonly lockedAt: FieldRef<"CronLock", 'DateTime'>
    readonly lockedBy: FieldRef<"CronLock", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CronLock findUnique
   */
  export type CronLockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronLock
     */
    select?: CronLockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CronLock
     */
    omit?: CronLockOmit<ExtArgs> | null
    /**
     * Filter, which CronLock to fetch.
     */
    where: CronLockWhereUniqueInput
  }

  /**
   * CronLock findUniqueOrThrow
   */
  export type CronLockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronLock
     */
    select?: CronLockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CronLock
     */
    omit?: CronLockOmit<ExtArgs> | null
    /**
     * Filter, which CronLock to fetch.
     */
    where: CronLockWhereUniqueInput
  }

  /**
   * CronLock findFirst
   */
  export type CronLockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronLock
     */
    select?: CronLockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CronLock
     */
    omit?: CronLockOmit<ExtArgs> | null
    /**
     * Filter, which CronLock to fetch.
     */
    where?: CronLockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CronLocks to fetch.
     */
    orderBy?: CronLockOrderByWithRelationInput | CronLockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CronLocks.
     */
    cursor?: CronLockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CronLocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CronLocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CronLocks.
     */
    distinct?: CronLockScalarFieldEnum | CronLockScalarFieldEnum[]
  }

  /**
   * CronLock findFirstOrThrow
   */
  export type CronLockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronLock
     */
    select?: CronLockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CronLock
     */
    omit?: CronLockOmit<ExtArgs> | null
    /**
     * Filter, which CronLock to fetch.
     */
    where?: CronLockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CronLocks to fetch.
     */
    orderBy?: CronLockOrderByWithRelationInput | CronLockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CronLocks.
     */
    cursor?: CronLockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CronLocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CronLocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CronLocks.
     */
    distinct?: CronLockScalarFieldEnum | CronLockScalarFieldEnum[]
  }

  /**
   * CronLock findMany
   */
  export type CronLockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronLock
     */
    select?: CronLockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CronLock
     */
    omit?: CronLockOmit<ExtArgs> | null
    /**
     * Filter, which CronLocks to fetch.
     */
    where?: CronLockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CronLocks to fetch.
     */
    orderBy?: CronLockOrderByWithRelationInput | CronLockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CronLocks.
     */
    cursor?: CronLockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CronLocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CronLocks.
     */
    skip?: number
    distinct?: CronLockScalarFieldEnum | CronLockScalarFieldEnum[]
  }

  /**
   * CronLock create
   */
  export type CronLockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronLock
     */
    select?: CronLockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CronLock
     */
    omit?: CronLockOmit<ExtArgs> | null
    /**
     * The data needed to create a CronLock.
     */
    data?: XOR<CronLockCreateInput, CronLockUncheckedCreateInput>
  }

  /**
   * CronLock createMany
   */
  export type CronLockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CronLocks.
     */
    data: CronLockCreateManyInput | CronLockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CronLock createManyAndReturn
   */
  export type CronLockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronLock
     */
    select?: CronLockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CronLock
     */
    omit?: CronLockOmit<ExtArgs> | null
    /**
     * The data used to create many CronLocks.
     */
    data: CronLockCreateManyInput | CronLockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CronLock update
   */
  export type CronLockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronLock
     */
    select?: CronLockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CronLock
     */
    omit?: CronLockOmit<ExtArgs> | null
    /**
     * The data needed to update a CronLock.
     */
    data: XOR<CronLockUpdateInput, CronLockUncheckedUpdateInput>
    /**
     * Choose, which CronLock to update.
     */
    where: CronLockWhereUniqueInput
  }

  /**
   * CronLock updateMany
   */
  export type CronLockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CronLocks.
     */
    data: XOR<CronLockUpdateManyMutationInput, CronLockUncheckedUpdateManyInput>
    /**
     * Filter which CronLocks to update
     */
    where?: CronLockWhereInput
    /**
     * Limit how many CronLocks to update.
     */
    limit?: number
  }

  /**
   * CronLock updateManyAndReturn
   */
  export type CronLockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronLock
     */
    select?: CronLockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CronLock
     */
    omit?: CronLockOmit<ExtArgs> | null
    /**
     * The data used to update CronLocks.
     */
    data: XOR<CronLockUpdateManyMutationInput, CronLockUncheckedUpdateManyInput>
    /**
     * Filter which CronLocks to update
     */
    where?: CronLockWhereInput
    /**
     * Limit how many CronLocks to update.
     */
    limit?: number
  }

  /**
   * CronLock upsert
   */
  export type CronLockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronLock
     */
    select?: CronLockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CronLock
     */
    omit?: CronLockOmit<ExtArgs> | null
    /**
     * The filter to search for the CronLock to update in case it exists.
     */
    where: CronLockWhereUniqueInput
    /**
     * In case the CronLock found by the `where` argument doesn't exist, create a new CronLock with this data.
     */
    create: XOR<CronLockCreateInput, CronLockUncheckedCreateInput>
    /**
     * In case the CronLock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CronLockUpdateInput, CronLockUncheckedUpdateInput>
  }

  /**
   * CronLock delete
   */
  export type CronLockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronLock
     */
    select?: CronLockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CronLock
     */
    omit?: CronLockOmit<ExtArgs> | null
    /**
     * Filter which CronLock to delete.
     */
    where: CronLockWhereUniqueInput
  }

  /**
   * CronLock deleteMany
   */
  export type CronLockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CronLocks to delete
     */
    where?: CronLockWhereInput
    /**
     * Limit how many CronLocks to delete.
     */
    limit?: number
  }

  /**
   * CronLock without action
   */
  export type CronLockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronLock
     */
    select?: CronLockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CronLock
     */
    omit?: CronLockOmit<ExtArgs> | null
  }


  /**
   * Model AiAgent
   */

  export type AggregateAiAgent = {
    _count: AiAgentCountAggregateOutputType | null
    _min: AiAgentMinAggregateOutputType | null
    _max: AiAgentMaxAggregateOutputType | null
  }

  export type AiAgentMinAggregateOutputType = {
    id: string | null
    systemName: $Enums.AiAgentSystemName | null
    displayName: string | null
    isActive: boolean | null
    canMutateData: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiAgentMaxAggregateOutputType = {
    id: string | null
    systemName: $Enums.AiAgentSystemName | null
    displayName: string | null
    isActive: boolean | null
    canMutateData: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiAgentCountAggregateOutputType = {
    id: number
    systemName: number
    displayName: number
    isActive: number
    canMutateData: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AiAgentMinAggregateInputType = {
    id?: true
    systemName?: true
    displayName?: true
    isActive?: true
    canMutateData?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiAgentMaxAggregateInputType = {
    id?: true
    systemName?: true
    displayName?: true
    isActive?: true
    canMutateData?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiAgentCountAggregateInputType = {
    id?: true
    systemName?: true
    displayName?: true
    isActive?: true
    canMutateData?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AiAgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiAgent to aggregate.
     */
    where?: AiAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiAgents to fetch.
     */
    orderBy?: AiAgentOrderByWithRelationInput | AiAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiAgents
    **/
    _count?: true | AiAgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiAgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiAgentMaxAggregateInputType
  }

  export type GetAiAgentAggregateType<T extends AiAgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAiAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiAgent[P]>
      : GetScalarType<T[P], AggregateAiAgent[P]>
  }




  export type AiAgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiAgentWhereInput
    orderBy?: AiAgentOrderByWithAggregationInput | AiAgentOrderByWithAggregationInput[]
    by: AiAgentScalarFieldEnum[] | AiAgentScalarFieldEnum
    having?: AiAgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiAgentCountAggregateInputType | true
    _min?: AiAgentMinAggregateInputType
    _max?: AiAgentMaxAggregateInputType
  }

  export type AiAgentGroupByOutputType = {
    id: string
    systemName: $Enums.AiAgentSystemName
    displayName: string
    isActive: boolean
    canMutateData: boolean
    createdAt: Date
    updatedAt: Date
    _count: AiAgentCountAggregateOutputType | null
    _min: AiAgentMinAggregateOutputType | null
    _max: AiAgentMaxAggregateOutputType | null
  }

  type GetAiAgentGroupByPayload<T extends AiAgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiAgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiAgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiAgentGroupByOutputType[P]>
            : GetScalarType<T[P], AiAgentGroupByOutputType[P]>
        }
      >
    >


  export type AiAgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    systemName?: boolean
    displayName?: boolean
    isActive?: boolean
    canMutateData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permissions?: boolean | AiAgent$permissionsArgs<ExtArgs>
    actions?: boolean | AiAgent$actionsArgs<ExtArgs>
    trainingData?: boolean | AiAgent$trainingDataArgs<ExtArgs>
    _count?: boolean | AiAgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiAgent"]>

  export type AiAgentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    systemName?: boolean
    displayName?: boolean
    isActive?: boolean
    canMutateData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aiAgent"]>

  export type AiAgentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    systemName?: boolean
    displayName?: boolean
    isActive?: boolean
    canMutateData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aiAgent"]>

  export type AiAgentSelectScalar = {
    id?: boolean
    systemName?: boolean
    displayName?: boolean
    isActive?: boolean
    canMutateData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AiAgentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "systemName" | "displayName" | "isActive" | "canMutateData" | "createdAt" | "updatedAt", ExtArgs["result"]["aiAgent"]>
  export type AiAgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | AiAgent$permissionsArgs<ExtArgs>
    actions?: boolean | AiAgent$actionsArgs<ExtArgs>
    trainingData?: boolean | AiAgent$trainingDataArgs<ExtArgs>
    _count?: boolean | AiAgentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AiAgentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AiAgentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AiAgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiAgent"
    objects: {
      permissions: Prisma.$AiPermissionPayload<ExtArgs> | null
      actions: Prisma.$AiActionPayload<ExtArgs>[]
      trainingData: Prisma.$AiTrainingDataPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      systemName: $Enums.AiAgentSystemName
      displayName: string
      isActive: boolean
      canMutateData: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aiAgent"]>
    composites: {}
  }

  type AiAgentGetPayload<S extends boolean | null | undefined | AiAgentDefaultArgs> = $Result.GetResult<Prisma.$AiAgentPayload, S>

  type AiAgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiAgentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiAgentCountAggregateInputType | true
    }

  export interface AiAgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiAgent'], meta: { name: 'AiAgent' } }
    /**
     * Find zero or one AiAgent that matches the filter.
     * @param {AiAgentFindUniqueArgs} args - Arguments to find a AiAgent
     * @example
     * // Get one AiAgent
     * const aiAgent = await prisma.aiAgent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiAgentFindUniqueArgs>(args: SelectSubset<T, AiAgentFindUniqueArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiAgent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiAgentFindUniqueOrThrowArgs} args - Arguments to find a AiAgent
     * @example
     * // Get one AiAgent
     * const aiAgent = await prisma.aiAgent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiAgentFindUniqueOrThrowArgs>(args: SelectSubset<T, AiAgentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiAgent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAgentFindFirstArgs} args - Arguments to find a AiAgent
     * @example
     * // Get one AiAgent
     * const aiAgent = await prisma.aiAgent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiAgentFindFirstArgs>(args?: SelectSubset<T, AiAgentFindFirstArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiAgent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAgentFindFirstOrThrowArgs} args - Arguments to find a AiAgent
     * @example
     * // Get one AiAgent
     * const aiAgent = await prisma.aiAgent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiAgentFindFirstOrThrowArgs>(args?: SelectSubset<T, AiAgentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiAgents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiAgents
     * const aiAgents = await prisma.aiAgent.findMany()
     * 
     * // Get first 10 AiAgents
     * const aiAgents = await prisma.aiAgent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiAgentWithIdOnly = await prisma.aiAgent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiAgentFindManyArgs>(args?: SelectSubset<T, AiAgentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiAgent.
     * @param {AiAgentCreateArgs} args - Arguments to create a AiAgent.
     * @example
     * // Create one AiAgent
     * const AiAgent = await prisma.aiAgent.create({
     *   data: {
     *     // ... data to create a AiAgent
     *   }
     * })
     * 
     */
    create<T extends AiAgentCreateArgs>(args: SelectSubset<T, AiAgentCreateArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiAgents.
     * @param {AiAgentCreateManyArgs} args - Arguments to create many AiAgents.
     * @example
     * // Create many AiAgents
     * const aiAgent = await prisma.aiAgent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiAgentCreateManyArgs>(args?: SelectSubset<T, AiAgentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiAgents and returns the data saved in the database.
     * @param {AiAgentCreateManyAndReturnArgs} args - Arguments to create many AiAgents.
     * @example
     * // Create many AiAgents
     * const aiAgent = await prisma.aiAgent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiAgents and only return the `id`
     * const aiAgentWithIdOnly = await prisma.aiAgent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiAgentCreateManyAndReturnArgs>(args?: SelectSubset<T, AiAgentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiAgent.
     * @param {AiAgentDeleteArgs} args - Arguments to delete one AiAgent.
     * @example
     * // Delete one AiAgent
     * const AiAgent = await prisma.aiAgent.delete({
     *   where: {
     *     // ... filter to delete one AiAgent
     *   }
     * })
     * 
     */
    delete<T extends AiAgentDeleteArgs>(args: SelectSubset<T, AiAgentDeleteArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiAgent.
     * @param {AiAgentUpdateArgs} args - Arguments to update one AiAgent.
     * @example
     * // Update one AiAgent
     * const aiAgent = await prisma.aiAgent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiAgentUpdateArgs>(args: SelectSubset<T, AiAgentUpdateArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiAgents.
     * @param {AiAgentDeleteManyArgs} args - Arguments to filter AiAgents to delete.
     * @example
     * // Delete a few AiAgents
     * const { count } = await prisma.aiAgent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiAgentDeleteManyArgs>(args?: SelectSubset<T, AiAgentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiAgents
     * const aiAgent = await prisma.aiAgent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiAgentUpdateManyArgs>(args: SelectSubset<T, AiAgentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiAgents and returns the data updated in the database.
     * @param {AiAgentUpdateManyAndReturnArgs} args - Arguments to update many AiAgents.
     * @example
     * // Update many AiAgents
     * const aiAgent = await prisma.aiAgent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiAgents and only return the `id`
     * const aiAgentWithIdOnly = await prisma.aiAgent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiAgentUpdateManyAndReturnArgs>(args: SelectSubset<T, AiAgentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiAgent.
     * @param {AiAgentUpsertArgs} args - Arguments to update or create a AiAgent.
     * @example
     * // Update or create a AiAgent
     * const aiAgent = await prisma.aiAgent.upsert({
     *   create: {
     *     // ... data to create a AiAgent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiAgent we want to update
     *   }
     * })
     */
    upsert<T extends AiAgentUpsertArgs>(args: SelectSubset<T, AiAgentUpsertArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAgentCountArgs} args - Arguments to filter AiAgents to count.
     * @example
     * // Count the number of AiAgents
     * const count = await prisma.aiAgent.count({
     *   where: {
     *     // ... the filter for the AiAgents we want to count
     *   }
     * })
    **/
    count<T extends AiAgentCountArgs>(
      args?: Subset<T, AiAgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiAgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiAgentAggregateArgs>(args: Subset<T, AiAgentAggregateArgs>): Prisma.PrismaPromise<GetAiAgentAggregateType<T>>

    /**
     * Group by AiAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiAgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiAgentGroupByArgs['orderBy'] }
        : { orderBy?: AiAgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiAgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiAgent model
   */
  readonly fields: AiAgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiAgent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiAgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissions<T extends AiAgent$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, AiAgent$permissionsArgs<ExtArgs>>): Prisma__AiPermissionClient<$Result.GetResult<Prisma.$AiPermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    actions<T extends AiAgent$actionsArgs<ExtArgs> = {}>(args?: Subset<T, AiAgent$actionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trainingData<T extends AiAgent$trainingDataArgs<ExtArgs> = {}>(args?: Subset<T, AiAgent$trainingDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiTrainingDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiAgent model
   */
  interface AiAgentFieldRefs {
    readonly id: FieldRef<"AiAgent", 'String'>
    readonly systemName: FieldRef<"AiAgent", 'AiAgentSystemName'>
    readonly displayName: FieldRef<"AiAgent", 'String'>
    readonly isActive: FieldRef<"AiAgent", 'Boolean'>
    readonly canMutateData: FieldRef<"AiAgent", 'Boolean'>
    readonly createdAt: FieldRef<"AiAgent", 'DateTime'>
    readonly updatedAt: FieldRef<"AiAgent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiAgent findUnique
   */
  export type AiAgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * Filter, which AiAgent to fetch.
     */
    where: AiAgentWhereUniqueInput
  }

  /**
   * AiAgent findUniqueOrThrow
   */
  export type AiAgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * Filter, which AiAgent to fetch.
     */
    where: AiAgentWhereUniqueInput
  }

  /**
   * AiAgent findFirst
   */
  export type AiAgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * Filter, which AiAgent to fetch.
     */
    where?: AiAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiAgents to fetch.
     */
    orderBy?: AiAgentOrderByWithRelationInput | AiAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiAgents.
     */
    cursor?: AiAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiAgents.
     */
    distinct?: AiAgentScalarFieldEnum | AiAgentScalarFieldEnum[]
  }

  /**
   * AiAgent findFirstOrThrow
   */
  export type AiAgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * Filter, which AiAgent to fetch.
     */
    where?: AiAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiAgents to fetch.
     */
    orderBy?: AiAgentOrderByWithRelationInput | AiAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiAgents.
     */
    cursor?: AiAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiAgents.
     */
    distinct?: AiAgentScalarFieldEnum | AiAgentScalarFieldEnum[]
  }

  /**
   * AiAgent findMany
   */
  export type AiAgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * Filter, which AiAgents to fetch.
     */
    where?: AiAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiAgents to fetch.
     */
    orderBy?: AiAgentOrderByWithRelationInput | AiAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiAgents.
     */
    cursor?: AiAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiAgents.
     */
    skip?: number
    distinct?: AiAgentScalarFieldEnum | AiAgentScalarFieldEnum[]
  }

  /**
   * AiAgent create
   */
  export type AiAgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * The data needed to create a AiAgent.
     */
    data: XOR<AiAgentCreateInput, AiAgentUncheckedCreateInput>
  }

  /**
   * AiAgent createMany
   */
  export type AiAgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiAgents.
     */
    data: AiAgentCreateManyInput | AiAgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiAgent createManyAndReturn
   */
  export type AiAgentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * The data used to create many AiAgents.
     */
    data: AiAgentCreateManyInput | AiAgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiAgent update
   */
  export type AiAgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * The data needed to update a AiAgent.
     */
    data: XOR<AiAgentUpdateInput, AiAgentUncheckedUpdateInput>
    /**
     * Choose, which AiAgent to update.
     */
    where: AiAgentWhereUniqueInput
  }

  /**
   * AiAgent updateMany
   */
  export type AiAgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiAgents.
     */
    data: XOR<AiAgentUpdateManyMutationInput, AiAgentUncheckedUpdateManyInput>
    /**
     * Filter which AiAgents to update
     */
    where?: AiAgentWhereInput
    /**
     * Limit how many AiAgents to update.
     */
    limit?: number
  }

  /**
   * AiAgent updateManyAndReturn
   */
  export type AiAgentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * The data used to update AiAgents.
     */
    data: XOR<AiAgentUpdateManyMutationInput, AiAgentUncheckedUpdateManyInput>
    /**
     * Filter which AiAgents to update
     */
    where?: AiAgentWhereInput
    /**
     * Limit how many AiAgents to update.
     */
    limit?: number
  }

  /**
   * AiAgent upsert
   */
  export type AiAgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * The filter to search for the AiAgent to update in case it exists.
     */
    where: AiAgentWhereUniqueInput
    /**
     * In case the AiAgent found by the `where` argument doesn't exist, create a new AiAgent with this data.
     */
    create: XOR<AiAgentCreateInput, AiAgentUncheckedCreateInput>
    /**
     * In case the AiAgent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiAgentUpdateInput, AiAgentUncheckedUpdateInput>
  }

  /**
   * AiAgent delete
   */
  export type AiAgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * Filter which AiAgent to delete.
     */
    where: AiAgentWhereUniqueInput
  }

  /**
   * AiAgent deleteMany
   */
  export type AiAgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiAgents to delete
     */
    where?: AiAgentWhereInput
    /**
     * Limit how many AiAgents to delete.
     */
    limit?: number
  }

  /**
   * AiAgent.permissions
   */
  export type AiAgent$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPermission
     */
    select?: AiPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPermission
     */
    omit?: AiPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPermissionInclude<ExtArgs> | null
    where?: AiPermissionWhereInput
  }

  /**
   * AiAgent.actions
   */
  export type AiAgent$actionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAction
     */
    select?: AiActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAction
     */
    omit?: AiActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiActionInclude<ExtArgs> | null
    where?: AiActionWhereInput
    orderBy?: AiActionOrderByWithRelationInput | AiActionOrderByWithRelationInput[]
    cursor?: AiActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiActionScalarFieldEnum | AiActionScalarFieldEnum[]
  }

  /**
   * AiAgent.trainingData
   */
  export type AiAgent$trainingDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTrainingData
     */
    select?: AiTrainingDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiTrainingData
     */
    omit?: AiTrainingDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTrainingDataInclude<ExtArgs> | null
    where?: AiTrainingDataWhereInput
    orderBy?: AiTrainingDataOrderByWithRelationInput | AiTrainingDataOrderByWithRelationInput[]
    cursor?: AiTrainingDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiTrainingDataScalarFieldEnum | AiTrainingDataScalarFieldEnum[]
  }

  /**
   * AiAgent without action
   */
  export type AiAgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
  }


  /**
   * Model AiPermission
   */

  export type AggregateAiPermission = {
    _count: AiPermissionCountAggregateOutputType | null
    _min: AiPermissionMinAggregateOutputType | null
    _max: AiPermissionMaxAggregateOutputType | null
  }

  export type AiPermissionMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    canModifyProducts: boolean | null
    canModifyPackages: boolean | null
    canModifyOrders: boolean | null
    requiresAdminConfirmation: boolean | null
  }

  export type AiPermissionMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    canModifyProducts: boolean | null
    canModifyPackages: boolean | null
    canModifyOrders: boolean | null
    requiresAdminConfirmation: boolean | null
  }

  export type AiPermissionCountAggregateOutputType = {
    id: number
    agentId: number
    canModifyProducts: number
    canModifyPackages: number
    canModifyOrders: number
    requiresAdminConfirmation: number
    _all: number
  }


  export type AiPermissionMinAggregateInputType = {
    id?: true
    agentId?: true
    canModifyProducts?: true
    canModifyPackages?: true
    canModifyOrders?: true
    requiresAdminConfirmation?: true
  }

  export type AiPermissionMaxAggregateInputType = {
    id?: true
    agentId?: true
    canModifyProducts?: true
    canModifyPackages?: true
    canModifyOrders?: true
    requiresAdminConfirmation?: true
  }

  export type AiPermissionCountAggregateInputType = {
    id?: true
    agentId?: true
    canModifyProducts?: true
    canModifyPackages?: true
    canModifyOrders?: true
    requiresAdminConfirmation?: true
    _all?: true
  }

  export type AiPermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiPermission to aggregate.
     */
    where?: AiPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiPermissions to fetch.
     */
    orderBy?: AiPermissionOrderByWithRelationInput | AiPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiPermissions
    **/
    _count?: true | AiPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiPermissionMaxAggregateInputType
  }

  export type GetAiPermissionAggregateType<T extends AiPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateAiPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiPermission[P]>
      : GetScalarType<T[P], AggregateAiPermission[P]>
  }




  export type AiPermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiPermissionWhereInput
    orderBy?: AiPermissionOrderByWithAggregationInput | AiPermissionOrderByWithAggregationInput[]
    by: AiPermissionScalarFieldEnum[] | AiPermissionScalarFieldEnum
    having?: AiPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiPermissionCountAggregateInputType | true
    _min?: AiPermissionMinAggregateInputType
    _max?: AiPermissionMaxAggregateInputType
  }

  export type AiPermissionGroupByOutputType = {
    id: string
    agentId: string
    canModifyProducts: boolean
    canModifyPackages: boolean
    canModifyOrders: boolean
    requiresAdminConfirmation: boolean
    _count: AiPermissionCountAggregateOutputType | null
    _min: AiPermissionMinAggregateOutputType | null
    _max: AiPermissionMaxAggregateOutputType | null
  }

  type GetAiPermissionGroupByPayload<T extends AiPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], AiPermissionGroupByOutputType[P]>
        }
      >
    >


  export type AiPermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    canModifyProducts?: boolean
    canModifyPackages?: boolean
    canModifyOrders?: boolean
    requiresAdminConfirmation?: boolean
    agent?: boolean | AiAgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiPermission"]>

  export type AiPermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    canModifyProducts?: boolean
    canModifyPackages?: boolean
    canModifyOrders?: boolean
    requiresAdminConfirmation?: boolean
    agent?: boolean | AiAgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiPermission"]>

  export type AiPermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    canModifyProducts?: boolean
    canModifyPackages?: boolean
    canModifyOrders?: boolean
    requiresAdminConfirmation?: boolean
    agent?: boolean | AiAgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiPermission"]>

  export type AiPermissionSelectScalar = {
    id?: boolean
    agentId?: boolean
    canModifyProducts?: boolean
    canModifyPackages?: boolean
    canModifyOrders?: boolean
    requiresAdminConfirmation?: boolean
  }

  export type AiPermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "canModifyProducts" | "canModifyPackages" | "canModifyOrders" | "requiresAdminConfirmation", ExtArgs["result"]["aiPermission"]>
  export type AiPermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AiAgentDefaultArgs<ExtArgs>
  }
  export type AiPermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AiAgentDefaultArgs<ExtArgs>
  }
  export type AiPermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AiAgentDefaultArgs<ExtArgs>
  }

  export type $AiPermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiPermission"
    objects: {
      agent: Prisma.$AiAgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      canModifyProducts: boolean
      canModifyPackages: boolean
      canModifyOrders: boolean
      requiresAdminConfirmation: boolean
    }, ExtArgs["result"]["aiPermission"]>
    composites: {}
  }

  type AiPermissionGetPayload<S extends boolean | null | undefined | AiPermissionDefaultArgs> = $Result.GetResult<Prisma.$AiPermissionPayload, S>

  type AiPermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiPermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiPermissionCountAggregateInputType | true
    }

  export interface AiPermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiPermission'], meta: { name: 'AiPermission' } }
    /**
     * Find zero or one AiPermission that matches the filter.
     * @param {AiPermissionFindUniqueArgs} args - Arguments to find a AiPermission
     * @example
     * // Get one AiPermission
     * const aiPermission = await prisma.aiPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiPermissionFindUniqueArgs>(args: SelectSubset<T, AiPermissionFindUniqueArgs<ExtArgs>>): Prisma__AiPermissionClient<$Result.GetResult<Prisma.$AiPermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiPermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiPermissionFindUniqueOrThrowArgs} args - Arguments to find a AiPermission
     * @example
     * // Get one AiPermission
     * const aiPermission = await prisma.aiPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiPermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, AiPermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiPermissionClient<$Result.GetResult<Prisma.$AiPermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiPermissionFindFirstArgs} args - Arguments to find a AiPermission
     * @example
     * // Get one AiPermission
     * const aiPermission = await prisma.aiPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiPermissionFindFirstArgs>(args?: SelectSubset<T, AiPermissionFindFirstArgs<ExtArgs>>): Prisma__AiPermissionClient<$Result.GetResult<Prisma.$AiPermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiPermissionFindFirstOrThrowArgs} args - Arguments to find a AiPermission
     * @example
     * // Get one AiPermission
     * const aiPermission = await prisma.aiPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiPermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, AiPermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiPermissionClient<$Result.GetResult<Prisma.$AiPermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiPermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiPermissions
     * const aiPermissions = await prisma.aiPermission.findMany()
     * 
     * // Get first 10 AiPermissions
     * const aiPermissions = await prisma.aiPermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiPermissionWithIdOnly = await prisma.aiPermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiPermissionFindManyArgs>(args?: SelectSubset<T, AiPermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiPermission.
     * @param {AiPermissionCreateArgs} args - Arguments to create a AiPermission.
     * @example
     * // Create one AiPermission
     * const AiPermission = await prisma.aiPermission.create({
     *   data: {
     *     // ... data to create a AiPermission
     *   }
     * })
     * 
     */
    create<T extends AiPermissionCreateArgs>(args: SelectSubset<T, AiPermissionCreateArgs<ExtArgs>>): Prisma__AiPermissionClient<$Result.GetResult<Prisma.$AiPermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiPermissions.
     * @param {AiPermissionCreateManyArgs} args - Arguments to create many AiPermissions.
     * @example
     * // Create many AiPermissions
     * const aiPermission = await prisma.aiPermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiPermissionCreateManyArgs>(args?: SelectSubset<T, AiPermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiPermissions and returns the data saved in the database.
     * @param {AiPermissionCreateManyAndReturnArgs} args - Arguments to create many AiPermissions.
     * @example
     * // Create many AiPermissions
     * const aiPermission = await prisma.aiPermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiPermissions and only return the `id`
     * const aiPermissionWithIdOnly = await prisma.aiPermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiPermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, AiPermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiPermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiPermission.
     * @param {AiPermissionDeleteArgs} args - Arguments to delete one AiPermission.
     * @example
     * // Delete one AiPermission
     * const AiPermission = await prisma.aiPermission.delete({
     *   where: {
     *     // ... filter to delete one AiPermission
     *   }
     * })
     * 
     */
    delete<T extends AiPermissionDeleteArgs>(args: SelectSubset<T, AiPermissionDeleteArgs<ExtArgs>>): Prisma__AiPermissionClient<$Result.GetResult<Prisma.$AiPermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiPermission.
     * @param {AiPermissionUpdateArgs} args - Arguments to update one AiPermission.
     * @example
     * // Update one AiPermission
     * const aiPermission = await prisma.aiPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiPermissionUpdateArgs>(args: SelectSubset<T, AiPermissionUpdateArgs<ExtArgs>>): Prisma__AiPermissionClient<$Result.GetResult<Prisma.$AiPermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiPermissions.
     * @param {AiPermissionDeleteManyArgs} args - Arguments to filter AiPermissions to delete.
     * @example
     * // Delete a few AiPermissions
     * const { count } = await prisma.aiPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiPermissionDeleteManyArgs>(args?: SelectSubset<T, AiPermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiPermissions
     * const aiPermission = await prisma.aiPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiPermissionUpdateManyArgs>(args: SelectSubset<T, AiPermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiPermissions and returns the data updated in the database.
     * @param {AiPermissionUpdateManyAndReturnArgs} args - Arguments to update many AiPermissions.
     * @example
     * // Update many AiPermissions
     * const aiPermission = await prisma.aiPermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiPermissions and only return the `id`
     * const aiPermissionWithIdOnly = await prisma.aiPermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiPermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, AiPermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiPermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiPermission.
     * @param {AiPermissionUpsertArgs} args - Arguments to update or create a AiPermission.
     * @example
     * // Update or create a AiPermission
     * const aiPermission = await prisma.aiPermission.upsert({
     *   create: {
     *     // ... data to create a AiPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiPermission we want to update
     *   }
     * })
     */
    upsert<T extends AiPermissionUpsertArgs>(args: SelectSubset<T, AiPermissionUpsertArgs<ExtArgs>>): Prisma__AiPermissionClient<$Result.GetResult<Prisma.$AiPermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiPermissionCountArgs} args - Arguments to filter AiPermissions to count.
     * @example
     * // Count the number of AiPermissions
     * const count = await prisma.aiPermission.count({
     *   where: {
     *     // ... the filter for the AiPermissions we want to count
     *   }
     * })
    **/
    count<T extends AiPermissionCountArgs>(
      args?: Subset<T, AiPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiPermissionAggregateArgs>(args: Subset<T, AiPermissionAggregateArgs>): Prisma.PrismaPromise<GetAiPermissionAggregateType<T>>

    /**
     * Group by AiPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiPermissionGroupByArgs['orderBy'] }
        : { orderBy?: AiPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiPermission model
   */
  readonly fields: AiPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiPermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AiAgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiAgentDefaultArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiPermission model
   */
  interface AiPermissionFieldRefs {
    readonly id: FieldRef<"AiPermission", 'String'>
    readonly agentId: FieldRef<"AiPermission", 'String'>
    readonly canModifyProducts: FieldRef<"AiPermission", 'Boolean'>
    readonly canModifyPackages: FieldRef<"AiPermission", 'Boolean'>
    readonly canModifyOrders: FieldRef<"AiPermission", 'Boolean'>
    readonly requiresAdminConfirmation: FieldRef<"AiPermission", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AiPermission findUnique
   */
  export type AiPermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPermission
     */
    select?: AiPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPermission
     */
    omit?: AiPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPermissionInclude<ExtArgs> | null
    /**
     * Filter, which AiPermission to fetch.
     */
    where: AiPermissionWhereUniqueInput
  }

  /**
   * AiPermission findUniqueOrThrow
   */
  export type AiPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPermission
     */
    select?: AiPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPermission
     */
    omit?: AiPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPermissionInclude<ExtArgs> | null
    /**
     * Filter, which AiPermission to fetch.
     */
    where: AiPermissionWhereUniqueInput
  }

  /**
   * AiPermission findFirst
   */
  export type AiPermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPermission
     */
    select?: AiPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPermission
     */
    omit?: AiPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPermissionInclude<ExtArgs> | null
    /**
     * Filter, which AiPermission to fetch.
     */
    where?: AiPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiPermissions to fetch.
     */
    orderBy?: AiPermissionOrderByWithRelationInput | AiPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiPermissions.
     */
    cursor?: AiPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiPermissions.
     */
    distinct?: AiPermissionScalarFieldEnum | AiPermissionScalarFieldEnum[]
  }

  /**
   * AiPermission findFirstOrThrow
   */
  export type AiPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPermission
     */
    select?: AiPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPermission
     */
    omit?: AiPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPermissionInclude<ExtArgs> | null
    /**
     * Filter, which AiPermission to fetch.
     */
    where?: AiPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiPermissions to fetch.
     */
    orderBy?: AiPermissionOrderByWithRelationInput | AiPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiPermissions.
     */
    cursor?: AiPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiPermissions.
     */
    distinct?: AiPermissionScalarFieldEnum | AiPermissionScalarFieldEnum[]
  }

  /**
   * AiPermission findMany
   */
  export type AiPermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPermission
     */
    select?: AiPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPermission
     */
    omit?: AiPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPermissionInclude<ExtArgs> | null
    /**
     * Filter, which AiPermissions to fetch.
     */
    where?: AiPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiPermissions to fetch.
     */
    orderBy?: AiPermissionOrderByWithRelationInput | AiPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiPermissions.
     */
    cursor?: AiPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiPermissions.
     */
    skip?: number
    distinct?: AiPermissionScalarFieldEnum | AiPermissionScalarFieldEnum[]
  }

  /**
   * AiPermission create
   */
  export type AiPermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPermission
     */
    select?: AiPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPermission
     */
    omit?: AiPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a AiPermission.
     */
    data: XOR<AiPermissionCreateInput, AiPermissionUncheckedCreateInput>
  }

  /**
   * AiPermission createMany
   */
  export type AiPermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiPermissions.
     */
    data: AiPermissionCreateManyInput | AiPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiPermission createManyAndReturn
   */
  export type AiPermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPermission
     */
    select?: AiPermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiPermission
     */
    omit?: AiPermissionOmit<ExtArgs> | null
    /**
     * The data used to create many AiPermissions.
     */
    data: AiPermissionCreateManyInput | AiPermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiPermission update
   */
  export type AiPermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPermission
     */
    select?: AiPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPermission
     */
    omit?: AiPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a AiPermission.
     */
    data: XOR<AiPermissionUpdateInput, AiPermissionUncheckedUpdateInput>
    /**
     * Choose, which AiPermission to update.
     */
    where: AiPermissionWhereUniqueInput
  }

  /**
   * AiPermission updateMany
   */
  export type AiPermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiPermissions.
     */
    data: XOR<AiPermissionUpdateManyMutationInput, AiPermissionUncheckedUpdateManyInput>
    /**
     * Filter which AiPermissions to update
     */
    where?: AiPermissionWhereInput
    /**
     * Limit how many AiPermissions to update.
     */
    limit?: number
  }

  /**
   * AiPermission updateManyAndReturn
   */
  export type AiPermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPermission
     */
    select?: AiPermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiPermission
     */
    omit?: AiPermissionOmit<ExtArgs> | null
    /**
     * The data used to update AiPermissions.
     */
    data: XOR<AiPermissionUpdateManyMutationInput, AiPermissionUncheckedUpdateManyInput>
    /**
     * Filter which AiPermissions to update
     */
    where?: AiPermissionWhereInput
    /**
     * Limit how many AiPermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiPermission upsert
   */
  export type AiPermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPermission
     */
    select?: AiPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPermission
     */
    omit?: AiPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the AiPermission to update in case it exists.
     */
    where: AiPermissionWhereUniqueInput
    /**
     * In case the AiPermission found by the `where` argument doesn't exist, create a new AiPermission with this data.
     */
    create: XOR<AiPermissionCreateInput, AiPermissionUncheckedCreateInput>
    /**
     * In case the AiPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiPermissionUpdateInput, AiPermissionUncheckedUpdateInput>
  }

  /**
   * AiPermission delete
   */
  export type AiPermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPermission
     */
    select?: AiPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPermission
     */
    omit?: AiPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPermissionInclude<ExtArgs> | null
    /**
     * Filter which AiPermission to delete.
     */
    where: AiPermissionWhereUniqueInput
  }

  /**
   * AiPermission deleteMany
   */
  export type AiPermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiPermissions to delete
     */
    where?: AiPermissionWhereInput
    /**
     * Limit how many AiPermissions to delete.
     */
    limit?: number
  }

  /**
   * AiPermission without action
   */
  export type AiPermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPermission
     */
    select?: AiPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPermission
     */
    omit?: AiPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPermissionInclude<ExtArgs> | null
  }


  /**
   * Model AiAction
   */

  export type AggregateAiAction = {
    _count: AiActionCountAggregateOutputType | null
    _min: AiActionMinAggregateOutputType | null
    _max: AiActionMaxAggregateOutputType | null
  }

  export type AiActionMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    actionType: string | null
    status: $Enums.AiActionStatus | null
    approvedBy: string | null
    createdAt: Date | null
    executedAt: Date | null
  }

  export type AiActionMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    actionType: string | null
    status: $Enums.AiActionStatus | null
    approvedBy: string | null
    createdAt: Date | null
    executedAt: Date | null
  }

  export type AiActionCountAggregateOutputType = {
    id: number
    agentId: number
    actionType: number
    payloadBefore: number
    payloadAfter: number
    status: number
    approvedBy: number
    createdAt: number
    executedAt: number
    _all: number
  }


  export type AiActionMinAggregateInputType = {
    id?: true
    agentId?: true
    actionType?: true
    status?: true
    approvedBy?: true
    createdAt?: true
    executedAt?: true
  }

  export type AiActionMaxAggregateInputType = {
    id?: true
    agentId?: true
    actionType?: true
    status?: true
    approvedBy?: true
    createdAt?: true
    executedAt?: true
  }

  export type AiActionCountAggregateInputType = {
    id?: true
    agentId?: true
    actionType?: true
    payloadBefore?: true
    payloadAfter?: true
    status?: true
    approvedBy?: true
    createdAt?: true
    executedAt?: true
    _all?: true
  }

  export type AiActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiAction to aggregate.
     */
    where?: AiActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiActions to fetch.
     */
    orderBy?: AiActionOrderByWithRelationInput | AiActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiActions
    **/
    _count?: true | AiActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiActionMaxAggregateInputType
  }

  export type GetAiActionAggregateType<T extends AiActionAggregateArgs> = {
        [P in keyof T & keyof AggregateAiAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiAction[P]>
      : GetScalarType<T[P], AggregateAiAction[P]>
  }




  export type AiActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiActionWhereInput
    orderBy?: AiActionOrderByWithAggregationInput | AiActionOrderByWithAggregationInput[]
    by: AiActionScalarFieldEnum[] | AiActionScalarFieldEnum
    having?: AiActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiActionCountAggregateInputType | true
    _min?: AiActionMinAggregateInputType
    _max?: AiActionMaxAggregateInputType
  }

  export type AiActionGroupByOutputType = {
    id: string
    agentId: string
    actionType: string
    payloadBefore: JsonValue | null
    payloadAfter: JsonValue
    status: $Enums.AiActionStatus
    approvedBy: string | null
    createdAt: Date
    executedAt: Date | null
    _count: AiActionCountAggregateOutputType | null
    _min: AiActionMinAggregateOutputType | null
    _max: AiActionMaxAggregateOutputType | null
  }

  type GetAiActionGroupByPayload<T extends AiActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiActionGroupByOutputType[P]>
            : GetScalarType<T[P], AiActionGroupByOutputType[P]>
        }
      >
    >


  export type AiActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    actionType?: boolean
    payloadBefore?: boolean
    payloadAfter?: boolean
    status?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    executedAt?: boolean
    agent?: boolean | AiAgentDefaultArgs<ExtArgs>
    approver?: boolean | AiAction$approverArgs<ExtArgs>
  }, ExtArgs["result"]["aiAction"]>

  export type AiActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    actionType?: boolean
    payloadBefore?: boolean
    payloadAfter?: boolean
    status?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    executedAt?: boolean
    agent?: boolean | AiAgentDefaultArgs<ExtArgs>
    approver?: boolean | AiAction$approverArgs<ExtArgs>
  }, ExtArgs["result"]["aiAction"]>

  export type AiActionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    actionType?: boolean
    payloadBefore?: boolean
    payloadAfter?: boolean
    status?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    executedAt?: boolean
    agent?: boolean | AiAgentDefaultArgs<ExtArgs>
    approver?: boolean | AiAction$approverArgs<ExtArgs>
  }, ExtArgs["result"]["aiAction"]>

  export type AiActionSelectScalar = {
    id?: boolean
    agentId?: boolean
    actionType?: boolean
    payloadBefore?: boolean
    payloadAfter?: boolean
    status?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    executedAt?: boolean
  }

  export type AiActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "actionType" | "payloadBefore" | "payloadAfter" | "status" | "approvedBy" | "createdAt" | "executedAt", ExtArgs["result"]["aiAction"]>
  export type AiActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AiAgentDefaultArgs<ExtArgs>
    approver?: boolean | AiAction$approverArgs<ExtArgs>
  }
  export type AiActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AiAgentDefaultArgs<ExtArgs>
    approver?: boolean | AiAction$approverArgs<ExtArgs>
  }
  export type AiActionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AiAgentDefaultArgs<ExtArgs>
    approver?: boolean | AiAction$approverArgs<ExtArgs>
  }

  export type $AiActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiAction"
    objects: {
      agent: Prisma.$AiAgentPayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      actionType: string
      payloadBefore: Prisma.JsonValue | null
      payloadAfter: Prisma.JsonValue
      status: $Enums.AiActionStatus
      approvedBy: string | null
      createdAt: Date
      executedAt: Date | null
    }, ExtArgs["result"]["aiAction"]>
    composites: {}
  }

  type AiActionGetPayload<S extends boolean | null | undefined | AiActionDefaultArgs> = $Result.GetResult<Prisma.$AiActionPayload, S>

  type AiActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiActionCountAggregateInputType | true
    }

  export interface AiActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiAction'], meta: { name: 'AiAction' } }
    /**
     * Find zero or one AiAction that matches the filter.
     * @param {AiActionFindUniqueArgs} args - Arguments to find a AiAction
     * @example
     * // Get one AiAction
     * const aiAction = await prisma.aiAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiActionFindUniqueArgs>(args: SelectSubset<T, AiActionFindUniqueArgs<ExtArgs>>): Prisma__AiActionClient<$Result.GetResult<Prisma.$AiActionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiAction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiActionFindUniqueOrThrowArgs} args - Arguments to find a AiAction
     * @example
     * // Get one AiAction
     * const aiAction = await prisma.aiAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiActionFindUniqueOrThrowArgs>(args: SelectSubset<T, AiActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiActionClient<$Result.GetResult<Prisma.$AiActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiActionFindFirstArgs} args - Arguments to find a AiAction
     * @example
     * // Get one AiAction
     * const aiAction = await prisma.aiAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiActionFindFirstArgs>(args?: SelectSubset<T, AiActionFindFirstArgs<ExtArgs>>): Prisma__AiActionClient<$Result.GetResult<Prisma.$AiActionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiActionFindFirstOrThrowArgs} args - Arguments to find a AiAction
     * @example
     * // Get one AiAction
     * const aiAction = await prisma.aiAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiActionFindFirstOrThrowArgs>(args?: SelectSubset<T, AiActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiActionClient<$Result.GetResult<Prisma.$AiActionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiActions
     * const aiActions = await prisma.aiAction.findMany()
     * 
     * // Get first 10 AiActions
     * const aiActions = await prisma.aiAction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiActionWithIdOnly = await prisma.aiAction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiActionFindManyArgs>(args?: SelectSubset<T, AiActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiAction.
     * @param {AiActionCreateArgs} args - Arguments to create a AiAction.
     * @example
     * // Create one AiAction
     * const AiAction = await prisma.aiAction.create({
     *   data: {
     *     // ... data to create a AiAction
     *   }
     * })
     * 
     */
    create<T extends AiActionCreateArgs>(args: SelectSubset<T, AiActionCreateArgs<ExtArgs>>): Prisma__AiActionClient<$Result.GetResult<Prisma.$AiActionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiActions.
     * @param {AiActionCreateManyArgs} args - Arguments to create many AiActions.
     * @example
     * // Create many AiActions
     * const aiAction = await prisma.aiAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiActionCreateManyArgs>(args?: SelectSubset<T, AiActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiActions and returns the data saved in the database.
     * @param {AiActionCreateManyAndReturnArgs} args - Arguments to create many AiActions.
     * @example
     * // Create many AiActions
     * const aiAction = await prisma.aiAction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiActions and only return the `id`
     * const aiActionWithIdOnly = await prisma.aiAction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiActionCreateManyAndReturnArgs>(args?: SelectSubset<T, AiActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiActionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiAction.
     * @param {AiActionDeleteArgs} args - Arguments to delete one AiAction.
     * @example
     * // Delete one AiAction
     * const AiAction = await prisma.aiAction.delete({
     *   where: {
     *     // ... filter to delete one AiAction
     *   }
     * })
     * 
     */
    delete<T extends AiActionDeleteArgs>(args: SelectSubset<T, AiActionDeleteArgs<ExtArgs>>): Prisma__AiActionClient<$Result.GetResult<Prisma.$AiActionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiAction.
     * @param {AiActionUpdateArgs} args - Arguments to update one AiAction.
     * @example
     * // Update one AiAction
     * const aiAction = await prisma.aiAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiActionUpdateArgs>(args: SelectSubset<T, AiActionUpdateArgs<ExtArgs>>): Prisma__AiActionClient<$Result.GetResult<Prisma.$AiActionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiActions.
     * @param {AiActionDeleteManyArgs} args - Arguments to filter AiActions to delete.
     * @example
     * // Delete a few AiActions
     * const { count } = await prisma.aiAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiActionDeleteManyArgs>(args?: SelectSubset<T, AiActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiActions
     * const aiAction = await prisma.aiAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiActionUpdateManyArgs>(args: SelectSubset<T, AiActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiActions and returns the data updated in the database.
     * @param {AiActionUpdateManyAndReturnArgs} args - Arguments to update many AiActions.
     * @example
     * // Update many AiActions
     * const aiAction = await prisma.aiAction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiActions and only return the `id`
     * const aiActionWithIdOnly = await prisma.aiAction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiActionUpdateManyAndReturnArgs>(args: SelectSubset<T, AiActionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiActionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiAction.
     * @param {AiActionUpsertArgs} args - Arguments to update or create a AiAction.
     * @example
     * // Update or create a AiAction
     * const aiAction = await prisma.aiAction.upsert({
     *   create: {
     *     // ... data to create a AiAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiAction we want to update
     *   }
     * })
     */
    upsert<T extends AiActionUpsertArgs>(args: SelectSubset<T, AiActionUpsertArgs<ExtArgs>>): Prisma__AiActionClient<$Result.GetResult<Prisma.$AiActionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiActionCountArgs} args - Arguments to filter AiActions to count.
     * @example
     * // Count the number of AiActions
     * const count = await prisma.aiAction.count({
     *   where: {
     *     // ... the filter for the AiActions we want to count
     *   }
     * })
    **/
    count<T extends AiActionCountArgs>(
      args?: Subset<T, AiActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiActionAggregateArgs>(args: Subset<T, AiActionAggregateArgs>): Prisma.PrismaPromise<GetAiActionAggregateType<T>>

    /**
     * Group by AiAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiActionGroupByArgs['orderBy'] }
        : { orderBy?: AiActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiAction model
   */
  readonly fields: AiActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AiAgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiAgentDefaultArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approver<T extends AiAction$approverArgs<ExtArgs> = {}>(args?: Subset<T, AiAction$approverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiAction model
   */
  interface AiActionFieldRefs {
    readonly id: FieldRef<"AiAction", 'String'>
    readonly agentId: FieldRef<"AiAction", 'String'>
    readonly actionType: FieldRef<"AiAction", 'String'>
    readonly payloadBefore: FieldRef<"AiAction", 'Json'>
    readonly payloadAfter: FieldRef<"AiAction", 'Json'>
    readonly status: FieldRef<"AiAction", 'AiActionStatus'>
    readonly approvedBy: FieldRef<"AiAction", 'String'>
    readonly createdAt: FieldRef<"AiAction", 'DateTime'>
    readonly executedAt: FieldRef<"AiAction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiAction findUnique
   */
  export type AiActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAction
     */
    select?: AiActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAction
     */
    omit?: AiActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiActionInclude<ExtArgs> | null
    /**
     * Filter, which AiAction to fetch.
     */
    where: AiActionWhereUniqueInput
  }

  /**
   * AiAction findUniqueOrThrow
   */
  export type AiActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAction
     */
    select?: AiActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAction
     */
    omit?: AiActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiActionInclude<ExtArgs> | null
    /**
     * Filter, which AiAction to fetch.
     */
    where: AiActionWhereUniqueInput
  }

  /**
   * AiAction findFirst
   */
  export type AiActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAction
     */
    select?: AiActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAction
     */
    omit?: AiActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiActionInclude<ExtArgs> | null
    /**
     * Filter, which AiAction to fetch.
     */
    where?: AiActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiActions to fetch.
     */
    orderBy?: AiActionOrderByWithRelationInput | AiActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiActions.
     */
    cursor?: AiActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiActions.
     */
    distinct?: AiActionScalarFieldEnum | AiActionScalarFieldEnum[]
  }

  /**
   * AiAction findFirstOrThrow
   */
  export type AiActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAction
     */
    select?: AiActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAction
     */
    omit?: AiActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiActionInclude<ExtArgs> | null
    /**
     * Filter, which AiAction to fetch.
     */
    where?: AiActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiActions to fetch.
     */
    orderBy?: AiActionOrderByWithRelationInput | AiActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiActions.
     */
    cursor?: AiActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiActions.
     */
    distinct?: AiActionScalarFieldEnum | AiActionScalarFieldEnum[]
  }

  /**
   * AiAction findMany
   */
  export type AiActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAction
     */
    select?: AiActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAction
     */
    omit?: AiActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiActionInclude<ExtArgs> | null
    /**
     * Filter, which AiActions to fetch.
     */
    where?: AiActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiActions to fetch.
     */
    orderBy?: AiActionOrderByWithRelationInput | AiActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiActions.
     */
    cursor?: AiActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiActions.
     */
    skip?: number
    distinct?: AiActionScalarFieldEnum | AiActionScalarFieldEnum[]
  }

  /**
   * AiAction create
   */
  export type AiActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAction
     */
    select?: AiActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAction
     */
    omit?: AiActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiActionInclude<ExtArgs> | null
    /**
     * The data needed to create a AiAction.
     */
    data: XOR<AiActionCreateInput, AiActionUncheckedCreateInput>
  }

  /**
   * AiAction createMany
   */
  export type AiActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiActions.
     */
    data: AiActionCreateManyInput | AiActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiAction createManyAndReturn
   */
  export type AiActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAction
     */
    select?: AiActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiAction
     */
    omit?: AiActionOmit<ExtArgs> | null
    /**
     * The data used to create many AiActions.
     */
    data: AiActionCreateManyInput | AiActionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiActionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiAction update
   */
  export type AiActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAction
     */
    select?: AiActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAction
     */
    omit?: AiActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiActionInclude<ExtArgs> | null
    /**
     * The data needed to update a AiAction.
     */
    data: XOR<AiActionUpdateInput, AiActionUncheckedUpdateInput>
    /**
     * Choose, which AiAction to update.
     */
    where: AiActionWhereUniqueInput
  }

  /**
   * AiAction updateMany
   */
  export type AiActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiActions.
     */
    data: XOR<AiActionUpdateManyMutationInput, AiActionUncheckedUpdateManyInput>
    /**
     * Filter which AiActions to update
     */
    where?: AiActionWhereInput
    /**
     * Limit how many AiActions to update.
     */
    limit?: number
  }

  /**
   * AiAction updateManyAndReturn
   */
  export type AiActionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAction
     */
    select?: AiActionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiAction
     */
    omit?: AiActionOmit<ExtArgs> | null
    /**
     * The data used to update AiActions.
     */
    data: XOR<AiActionUpdateManyMutationInput, AiActionUncheckedUpdateManyInput>
    /**
     * Filter which AiActions to update
     */
    where?: AiActionWhereInput
    /**
     * Limit how many AiActions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiActionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiAction upsert
   */
  export type AiActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAction
     */
    select?: AiActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAction
     */
    omit?: AiActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiActionInclude<ExtArgs> | null
    /**
     * The filter to search for the AiAction to update in case it exists.
     */
    where: AiActionWhereUniqueInput
    /**
     * In case the AiAction found by the `where` argument doesn't exist, create a new AiAction with this data.
     */
    create: XOR<AiActionCreateInput, AiActionUncheckedCreateInput>
    /**
     * In case the AiAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiActionUpdateInput, AiActionUncheckedUpdateInput>
  }

  /**
   * AiAction delete
   */
  export type AiActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAction
     */
    select?: AiActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAction
     */
    omit?: AiActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiActionInclude<ExtArgs> | null
    /**
     * Filter which AiAction to delete.
     */
    where: AiActionWhereUniqueInput
  }

  /**
   * AiAction deleteMany
   */
  export type AiActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiActions to delete
     */
    where?: AiActionWhereInput
    /**
     * Limit how many AiActions to delete.
     */
    limit?: number
  }

  /**
   * AiAction.approver
   */
  export type AiAction$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AiAction without action
   */
  export type AiActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAction
     */
    select?: AiActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAction
     */
    omit?: AiActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiActionInclude<ExtArgs> | null
  }


  /**
   * Model AiTrainingData
   */

  export type AggregateAiTrainingData = {
    _count: AiTrainingDataCountAggregateOutputType | null
    _avg: AiTrainingDataAvgAggregateOutputType | null
    _sum: AiTrainingDataSumAggregateOutputType | null
    _min: AiTrainingDataMinAggregateOutputType | null
    _max: AiTrainingDataMaxAggregateOutputType | null
  }

  export type AiTrainingDataAvgAggregateOutputType = {
    feedbackScore: number | null
  }

  export type AiTrainingDataSumAggregateOutputType = {
    feedbackScore: number | null
  }

  export type AiTrainingDataMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    suggestion: string | null
    adminDecision: string | null
    feedbackScore: number | null
    createdAt: Date | null
  }

  export type AiTrainingDataMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    suggestion: string | null
    adminDecision: string | null
    feedbackScore: number | null
    createdAt: Date | null
  }

  export type AiTrainingDataCountAggregateOutputType = {
    id: number
    agentId: number
    suggestion: number
    adminDecision: number
    feedbackScore: number
    createdAt: number
    _all: number
  }


  export type AiTrainingDataAvgAggregateInputType = {
    feedbackScore?: true
  }

  export type AiTrainingDataSumAggregateInputType = {
    feedbackScore?: true
  }

  export type AiTrainingDataMinAggregateInputType = {
    id?: true
    agentId?: true
    suggestion?: true
    adminDecision?: true
    feedbackScore?: true
    createdAt?: true
  }

  export type AiTrainingDataMaxAggregateInputType = {
    id?: true
    agentId?: true
    suggestion?: true
    adminDecision?: true
    feedbackScore?: true
    createdAt?: true
  }

  export type AiTrainingDataCountAggregateInputType = {
    id?: true
    agentId?: true
    suggestion?: true
    adminDecision?: true
    feedbackScore?: true
    createdAt?: true
    _all?: true
  }

  export type AiTrainingDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiTrainingData to aggregate.
     */
    where?: AiTrainingDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiTrainingData to fetch.
     */
    orderBy?: AiTrainingDataOrderByWithRelationInput | AiTrainingDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiTrainingDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiTrainingData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiTrainingData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiTrainingData
    **/
    _count?: true | AiTrainingDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiTrainingDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiTrainingDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiTrainingDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiTrainingDataMaxAggregateInputType
  }

  export type GetAiTrainingDataAggregateType<T extends AiTrainingDataAggregateArgs> = {
        [P in keyof T & keyof AggregateAiTrainingData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiTrainingData[P]>
      : GetScalarType<T[P], AggregateAiTrainingData[P]>
  }




  export type AiTrainingDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiTrainingDataWhereInput
    orderBy?: AiTrainingDataOrderByWithAggregationInput | AiTrainingDataOrderByWithAggregationInput[]
    by: AiTrainingDataScalarFieldEnum[] | AiTrainingDataScalarFieldEnum
    having?: AiTrainingDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiTrainingDataCountAggregateInputType | true
    _avg?: AiTrainingDataAvgAggregateInputType
    _sum?: AiTrainingDataSumAggregateInputType
    _min?: AiTrainingDataMinAggregateInputType
    _max?: AiTrainingDataMaxAggregateInputType
  }

  export type AiTrainingDataGroupByOutputType = {
    id: string
    agentId: string
    suggestion: string
    adminDecision: string
    feedbackScore: number | null
    createdAt: Date
    _count: AiTrainingDataCountAggregateOutputType | null
    _avg: AiTrainingDataAvgAggregateOutputType | null
    _sum: AiTrainingDataSumAggregateOutputType | null
    _min: AiTrainingDataMinAggregateOutputType | null
    _max: AiTrainingDataMaxAggregateOutputType | null
  }

  type GetAiTrainingDataGroupByPayload<T extends AiTrainingDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiTrainingDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiTrainingDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiTrainingDataGroupByOutputType[P]>
            : GetScalarType<T[P], AiTrainingDataGroupByOutputType[P]>
        }
      >
    >


  export type AiTrainingDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    suggestion?: boolean
    adminDecision?: boolean
    feedbackScore?: boolean
    createdAt?: boolean
    agent?: boolean | AiAgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiTrainingData"]>

  export type AiTrainingDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    suggestion?: boolean
    adminDecision?: boolean
    feedbackScore?: boolean
    createdAt?: boolean
    agent?: boolean | AiAgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiTrainingData"]>

  export type AiTrainingDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    suggestion?: boolean
    adminDecision?: boolean
    feedbackScore?: boolean
    createdAt?: boolean
    agent?: boolean | AiAgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiTrainingData"]>

  export type AiTrainingDataSelectScalar = {
    id?: boolean
    agentId?: boolean
    suggestion?: boolean
    adminDecision?: boolean
    feedbackScore?: boolean
    createdAt?: boolean
  }

  export type AiTrainingDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "suggestion" | "adminDecision" | "feedbackScore" | "createdAt", ExtArgs["result"]["aiTrainingData"]>
  export type AiTrainingDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AiAgentDefaultArgs<ExtArgs>
  }
  export type AiTrainingDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AiAgentDefaultArgs<ExtArgs>
  }
  export type AiTrainingDataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AiAgentDefaultArgs<ExtArgs>
  }

  export type $AiTrainingDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiTrainingData"
    objects: {
      agent: Prisma.$AiAgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      suggestion: string
      adminDecision: string
      feedbackScore: number | null
      createdAt: Date
    }, ExtArgs["result"]["aiTrainingData"]>
    composites: {}
  }

  type AiTrainingDataGetPayload<S extends boolean | null | undefined | AiTrainingDataDefaultArgs> = $Result.GetResult<Prisma.$AiTrainingDataPayload, S>

  type AiTrainingDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiTrainingDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiTrainingDataCountAggregateInputType | true
    }

  export interface AiTrainingDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiTrainingData'], meta: { name: 'AiTrainingData' } }
    /**
     * Find zero or one AiTrainingData that matches the filter.
     * @param {AiTrainingDataFindUniqueArgs} args - Arguments to find a AiTrainingData
     * @example
     * // Get one AiTrainingData
     * const aiTrainingData = await prisma.aiTrainingData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiTrainingDataFindUniqueArgs>(args: SelectSubset<T, AiTrainingDataFindUniqueArgs<ExtArgs>>): Prisma__AiTrainingDataClient<$Result.GetResult<Prisma.$AiTrainingDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiTrainingData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiTrainingDataFindUniqueOrThrowArgs} args - Arguments to find a AiTrainingData
     * @example
     * // Get one AiTrainingData
     * const aiTrainingData = await prisma.aiTrainingData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiTrainingDataFindUniqueOrThrowArgs>(args: SelectSubset<T, AiTrainingDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiTrainingDataClient<$Result.GetResult<Prisma.$AiTrainingDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiTrainingData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiTrainingDataFindFirstArgs} args - Arguments to find a AiTrainingData
     * @example
     * // Get one AiTrainingData
     * const aiTrainingData = await prisma.aiTrainingData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiTrainingDataFindFirstArgs>(args?: SelectSubset<T, AiTrainingDataFindFirstArgs<ExtArgs>>): Prisma__AiTrainingDataClient<$Result.GetResult<Prisma.$AiTrainingDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiTrainingData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiTrainingDataFindFirstOrThrowArgs} args - Arguments to find a AiTrainingData
     * @example
     * // Get one AiTrainingData
     * const aiTrainingData = await prisma.aiTrainingData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiTrainingDataFindFirstOrThrowArgs>(args?: SelectSubset<T, AiTrainingDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiTrainingDataClient<$Result.GetResult<Prisma.$AiTrainingDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiTrainingData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiTrainingDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiTrainingData
     * const aiTrainingData = await prisma.aiTrainingData.findMany()
     * 
     * // Get first 10 AiTrainingData
     * const aiTrainingData = await prisma.aiTrainingData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiTrainingDataWithIdOnly = await prisma.aiTrainingData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiTrainingDataFindManyArgs>(args?: SelectSubset<T, AiTrainingDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiTrainingDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiTrainingData.
     * @param {AiTrainingDataCreateArgs} args - Arguments to create a AiTrainingData.
     * @example
     * // Create one AiTrainingData
     * const AiTrainingData = await prisma.aiTrainingData.create({
     *   data: {
     *     // ... data to create a AiTrainingData
     *   }
     * })
     * 
     */
    create<T extends AiTrainingDataCreateArgs>(args: SelectSubset<T, AiTrainingDataCreateArgs<ExtArgs>>): Prisma__AiTrainingDataClient<$Result.GetResult<Prisma.$AiTrainingDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiTrainingData.
     * @param {AiTrainingDataCreateManyArgs} args - Arguments to create many AiTrainingData.
     * @example
     * // Create many AiTrainingData
     * const aiTrainingData = await prisma.aiTrainingData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiTrainingDataCreateManyArgs>(args?: SelectSubset<T, AiTrainingDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiTrainingData and returns the data saved in the database.
     * @param {AiTrainingDataCreateManyAndReturnArgs} args - Arguments to create many AiTrainingData.
     * @example
     * // Create many AiTrainingData
     * const aiTrainingData = await prisma.aiTrainingData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiTrainingData and only return the `id`
     * const aiTrainingDataWithIdOnly = await prisma.aiTrainingData.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiTrainingDataCreateManyAndReturnArgs>(args?: SelectSubset<T, AiTrainingDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiTrainingDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiTrainingData.
     * @param {AiTrainingDataDeleteArgs} args - Arguments to delete one AiTrainingData.
     * @example
     * // Delete one AiTrainingData
     * const AiTrainingData = await prisma.aiTrainingData.delete({
     *   where: {
     *     // ... filter to delete one AiTrainingData
     *   }
     * })
     * 
     */
    delete<T extends AiTrainingDataDeleteArgs>(args: SelectSubset<T, AiTrainingDataDeleteArgs<ExtArgs>>): Prisma__AiTrainingDataClient<$Result.GetResult<Prisma.$AiTrainingDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiTrainingData.
     * @param {AiTrainingDataUpdateArgs} args - Arguments to update one AiTrainingData.
     * @example
     * // Update one AiTrainingData
     * const aiTrainingData = await prisma.aiTrainingData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiTrainingDataUpdateArgs>(args: SelectSubset<T, AiTrainingDataUpdateArgs<ExtArgs>>): Prisma__AiTrainingDataClient<$Result.GetResult<Prisma.$AiTrainingDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiTrainingData.
     * @param {AiTrainingDataDeleteManyArgs} args - Arguments to filter AiTrainingData to delete.
     * @example
     * // Delete a few AiTrainingData
     * const { count } = await prisma.aiTrainingData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiTrainingDataDeleteManyArgs>(args?: SelectSubset<T, AiTrainingDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiTrainingData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiTrainingDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiTrainingData
     * const aiTrainingData = await prisma.aiTrainingData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiTrainingDataUpdateManyArgs>(args: SelectSubset<T, AiTrainingDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiTrainingData and returns the data updated in the database.
     * @param {AiTrainingDataUpdateManyAndReturnArgs} args - Arguments to update many AiTrainingData.
     * @example
     * // Update many AiTrainingData
     * const aiTrainingData = await prisma.aiTrainingData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiTrainingData and only return the `id`
     * const aiTrainingDataWithIdOnly = await prisma.aiTrainingData.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiTrainingDataUpdateManyAndReturnArgs>(args: SelectSubset<T, AiTrainingDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiTrainingDataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiTrainingData.
     * @param {AiTrainingDataUpsertArgs} args - Arguments to update or create a AiTrainingData.
     * @example
     * // Update or create a AiTrainingData
     * const aiTrainingData = await prisma.aiTrainingData.upsert({
     *   create: {
     *     // ... data to create a AiTrainingData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiTrainingData we want to update
     *   }
     * })
     */
    upsert<T extends AiTrainingDataUpsertArgs>(args: SelectSubset<T, AiTrainingDataUpsertArgs<ExtArgs>>): Prisma__AiTrainingDataClient<$Result.GetResult<Prisma.$AiTrainingDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiTrainingData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiTrainingDataCountArgs} args - Arguments to filter AiTrainingData to count.
     * @example
     * // Count the number of AiTrainingData
     * const count = await prisma.aiTrainingData.count({
     *   where: {
     *     // ... the filter for the AiTrainingData we want to count
     *   }
     * })
    **/
    count<T extends AiTrainingDataCountArgs>(
      args?: Subset<T, AiTrainingDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiTrainingDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiTrainingData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiTrainingDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiTrainingDataAggregateArgs>(args: Subset<T, AiTrainingDataAggregateArgs>): Prisma.PrismaPromise<GetAiTrainingDataAggregateType<T>>

    /**
     * Group by AiTrainingData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiTrainingDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiTrainingDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiTrainingDataGroupByArgs['orderBy'] }
        : { orderBy?: AiTrainingDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiTrainingDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiTrainingDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiTrainingData model
   */
  readonly fields: AiTrainingDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiTrainingData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiTrainingDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AiAgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiAgentDefaultArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiTrainingData model
   */
  interface AiTrainingDataFieldRefs {
    readonly id: FieldRef<"AiTrainingData", 'String'>
    readonly agentId: FieldRef<"AiTrainingData", 'String'>
    readonly suggestion: FieldRef<"AiTrainingData", 'String'>
    readonly adminDecision: FieldRef<"AiTrainingData", 'String'>
    readonly feedbackScore: FieldRef<"AiTrainingData", 'Int'>
    readonly createdAt: FieldRef<"AiTrainingData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiTrainingData findUnique
   */
  export type AiTrainingDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTrainingData
     */
    select?: AiTrainingDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiTrainingData
     */
    omit?: AiTrainingDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTrainingDataInclude<ExtArgs> | null
    /**
     * Filter, which AiTrainingData to fetch.
     */
    where: AiTrainingDataWhereUniqueInput
  }

  /**
   * AiTrainingData findUniqueOrThrow
   */
  export type AiTrainingDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTrainingData
     */
    select?: AiTrainingDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiTrainingData
     */
    omit?: AiTrainingDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTrainingDataInclude<ExtArgs> | null
    /**
     * Filter, which AiTrainingData to fetch.
     */
    where: AiTrainingDataWhereUniqueInput
  }

  /**
   * AiTrainingData findFirst
   */
  export type AiTrainingDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTrainingData
     */
    select?: AiTrainingDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiTrainingData
     */
    omit?: AiTrainingDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTrainingDataInclude<ExtArgs> | null
    /**
     * Filter, which AiTrainingData to fetch.
     */
    where?: AiTrainingDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiTrainingData to fetch.
     */
    orderBy?: AiTrainingDataOrderByWithRelationInput | AiTrainingDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiTrainingData.
     */
    cursor?: AiTrainingDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiTrainingData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiTrainingData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiTrainingData.
     */
    distinct?: AiTrainingDataScalarFieldEnum | AiTrainingDataScalarFieldEnum[]
  }

  /**
   * AiTrainingData findFirstOrThrow
   */
  export type AiTrainingDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTrainingData
     */
    select?: AiTrainingDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiTrainingData
     */
    omit?: AiTrainingDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTrainingDataInclude<ExtArgs> | null
    /**
     * Filter, which AiTrainingData to fetch.
     */
    where?: AiTrainingDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiTrainingData to fetch.
     */
    orderBy?: AiTrainingDataOrderByWithRelationInput | AiTrainingDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiTrainingData.
     */
    cursor?: AiTrainingDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiTrainingData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiTrainingData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiTrainingData.
     */
    distinct?: AiTrainingDataScalarFieldEnum | AiTrainingDataScalarFieldEnum[]
  }

  /**
   * AiTrainingData findMany
   */
  export type AiTrainingDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTrainingData
     */
    select?: AiTrainingDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiTrainingData
     */
    omit?: AiTrainingDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTrainingDataInclude<ExtArgs> | null
    /**
     * Filter, which AiTrainingData to fetch.
     */
    where?: AiTrainingDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiTrainingData to fetch.
     */
    orderBy?: AiTrainingDataOrderByWithRelationInput | AiTrainingDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiTrainingData.
     */
    cursor?: AiTrainingDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiTrainingData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiTrainingData.
     */
    skip?: number
    distinct?: AiTrainingDataScalarFieldEnum | AiTrainingDataScalarFieldEnum[]
  }

  /**
   * AiTrainingData create
   */
  export type AiTrainingDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTrainingData
     */
    select?: AiTrainingDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiTrainingData
     */
    omit?: AiTrainingDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTrainingDataInclude<ExtArgs> | null
    /**
     * The data needed to create a AiTrainingData.
     */
    data: XOR<AiTrainingDataCreateInput, AiTrainingDataUncheckedCreateInput>
  }

  /**
   * AiTrainingData createMany
   */
  export type AiTrainingDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiTrainingData.
     */
    data: AiTrainingDataCreateManyInput | AiTrainingDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiTrainingData createManyAndReturn
   */
  export type AiTrainingDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTrainingData
     */
    select?: AiTrainingDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiTrainingData
     */
    omit?: AiTrainingDataOmit<ExtArgs> | null
    /**
     * The data used to create many AiTrainingData.
     */
    data: AiTrainingDataCreateManyInput | AiTrainingDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTrainingDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiTrainingData update
   */
  export type AiTrainingDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTrainingData
     */
    select?: AiTrainingDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiTrainingData
     */
    omit?: AiTrainingDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTrainingDataInclude<ExtArgs> | null
    /**
     * The data needed to update a AiTrainingData.
     */
    data: XOR<AiTrainingDataUpdateInput, AiTrainingDataUncheckedUpdateInput>
    /**
     * Choose, which AiTrainingData to update.
     */
    where: AiTrainingDataWhereUniqueInput
  }

  /**
   * AiTrainingData updateMany
   */
  export type AiTrainingDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiTrainingData.
     */
    data: XOR<AiTrainingDataUpdateManyMutationInput, AiTrainingDataUncheckedUpdateManyInput>
    /**
     * Filter which AiTrainingData to update
     */
    where?: AiTrainingDataWhereInput
    /**
     * Limit how many AiTrainingData to update.
     */
    limit?: number
  }

  /**
   * AiTrainingData updateManyAndReturn
   */
  export type AiTrainingDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTrainingData
     */
    select?: AiTrainingDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiTrainingData
     */
    omit?: AiTrainingDataOmit<ExtArgs> | null
    /**
     * The data used to update AiTrainingData.
     */
    data: XOR<AiTrainingDataUpdateManyMutationInput, AiTrainingDataUncheckedUpdateManyInput>
    /**
     * Filter which AiTrainingData to update
     */
    where?: AiTrainingDataWhereInput
    /**
     * Limit how many AiTrainingData to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTrainingDataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiTrainingData upsert
   */
  export type AiTrainingDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTrainingData
     */
    select?: AiTrainingDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiTrainingData
     */
    omit?: AiTrainingDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTrainingDataInclude<ExtArgs> | null
    /**
     * The filter to search for the AiTrainingData to update in case it exists.
     */
    where: AiTrainingDataWhereUniqueInput
    /**
     * In case the AiTrainingData found by the `where` argument doesn't exist, create a new AiTrainingData with this data.
     */
    create: XOR<AiTrainingDataCreateInput, AiTrainingDataUncheckedCreateInput>
    /**
     * In case the AiTrainingData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiTrainingDataUpdateInput, AiTrainingDataUncheckedUpdateInput>
  }

  /**
   * AiTrainingData delete
   */
  export type AiTrainingDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTrainingData
     */
    select?: AiTrainingDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiTrainingData
     */
    omit?: AiTrainingDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTrainingDataInclude<ExtArgs> | null
    /**
     * Filter which AiTrainingData to delete.
     */
    where: AiTrainingDataWhereUniqueInput
  }

  /**
   * AiTrainingData deleteMany
   */
  export type AiTrainingDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiTrainingData to delete
     */
    where?: AiTrainingDataWhereInput
    /**
     * Limit how many AiTrainingData to delete.
     */
    limit?: number
  }

  /**
   * AiTrainingData without action
   */
  export type AiTrainingDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTrainingData
     */
    select?: AiTrainingDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiTrainingData
     */
    omit?: AiTrainingDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTrainingDataInclude<ExtArgs> | null
  }


  /**
   * Model Vehicle
   */

  export type AggregateVehicle = {
    _count: VehicleCountAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  export type VehicleMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.VehicleType | null
    status: $Enums.VehicleStatus | null
    currentDeliveryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehicleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.VehicleType | null
    status: $Enums.VehicleStatus | null
    currentDeliveryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehicleCountAggregateOutputType = {
    id: number
    name: number
    type: number
    status: number
    currentDeliveryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VehicleMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    currentDeliveryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehicleMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    currentDeliveryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehicleCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    currentDeliveryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VehicleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicle to aggregate.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vehicles
    **/
    _count?: true | VehicleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleMaxAggregateInputType
  }

  export type GetVehicleAggregateType<T extends VehicleAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle[P]>
      : GetScalarType<T[P], AggregateVehicle[P]>
  }




  export type VehicleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithAggregationInput | VehicleOrderByWithAggregationInput[]
    by: VehicleScalarFieldEnum[] | VehicleScalarFieldEnum
    having?: VehicleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleCountAggregateInputType | true
    _min?: VehicleMinAggregateInputType
    _max?: VehicleMaxAggregateInputType
  }

  export type VehicleGroupByOutputType = {
    id: string
    name: string
    type: $Enums.VehicleType
    status: $Enums.VehicleStatus
    currentDeliveryId: string | null
    createdAt: Date
    updatedAt: Date
    _count: VehicleCountAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  type GetVehicleGroupByPayload<T extends VehicleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleGroupByOutputType[P]>
        }
      >
    >


  export type VehicleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    currentDeliveryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deliveries?: boolean | Vehicle$deliveriesArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    currentDeliveryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    currentDeliveryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    currentDeliveryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VehicleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "status" | "currentDeliveryId" | "createdAt" | "updatedAt", ExtArgs["result"]["vehicle"]>
  export type VehicleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveries?: boolean | Vehicle$deliveriesArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VehicleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VehicleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VehiclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vehicle"
    objects: {
      deliveries: Prisma.$DeliveryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.VehicleType
      status: $Enums.VehicleStatus
      currentDeliveryId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vehicle"]>
    composites: {}
  }

  type VehicleGetPayload<S extends boolean | null | undefined | VehicleDefaultArgs> = $Result.GetResult<Prisma.$VehiclePayload, S>

  type VehicleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VehicleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehicleCountAggregateInputType | true
    }

  export interface VehicleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vehicle'], meta: { name: 'Vehicle' } }
    /**
     * Find zero or one Vehicle that matches the filter.
     * @param {VehicleFindUniqueArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleFindUniqueArgs>(args: SelectSubset<T, VehicleFindUniqueArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VehicleFindUniqueOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleFindFirstArgs>(args?: SelectSubset<T, VehicleFindFirstArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicles
     * const vehicles = await prisma.vehicle.findMany()
     * 
     * // Get first 10 Vehicles
     * const vehicles = await prisma.vehicle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleFindManyArgs>(args?: SelectSubset<T, VehicleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicle.
     * @param {VehicleCreateArgs} args - Arguments to create a Vehicle.
     * @example
     * // Create one Vehicle
     * const Vehicle = await prisma.vehicle.create({
     *   data: {
     *     // ... data to create a Vehicle
     *   }
     * })
     * 
     */
    create<T extends VehicleCreateArgs>(args: SelectSubset<T, VehicleCreateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicles.
     * @param {VehicleCreateManyArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleCreateManyArgs>(args?: SelectSubset<T, VehicleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehicles and returns the data saved in the database.
     * @param {VehicleCreateManyAndReturnArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehicles and only return the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vehicle.
     * @param {VehicleDeleteArgs} args - Arguments to delete one Vehicle.
     * @example
     * // Delete one Vehicle
     * const Vehicle = await prisma.vehicle.delete({
     *   where: {
     *     // ... filter to delete one Vehicle
     *   }
     * })
     * 
     */
    delete<T extends VehicleDeleteArgs>(args: SelectSubset<T, VehicleDeleteArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicle.
     * @param {VehicleUpdateArgs} args - Arguments to update one Vehicle.
     * @example
     * // Update one Vehicle
     * const vehicle = await prisma.vehicle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleUpdateArgs>(args: SelectSubset<T, VehicleUpdateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicles.
     * @param {VehicleDeleteManyArgs} args - Arguments to filter Vehicles to delete.
     * @example
     * // Delete a few Vehicles
     * const { count } = await prisma.vehicle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleDeleteManyArgs>(args?: SelectSubset<T, VehicleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleUpdateManyArgs>(args: SelectSubset<T, VehicleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles and returns the data updated in the database.
     * @param {VehicleUpdateManyAndReturnArgs} args - Arguments to update many Vehicles.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vehicles and only return the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VehicleUpdateManyAndReturnArgs>(args: SelectSubset<T, VehicleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vehicle.
     * @param {VehicleUpsertArgs} args - Arguments to update or create a Vehicle.
     * @example
     * // Update or create a Vehicle
     * const vehicle = await prisma.vehicle.upsert({
     *   create: {
     *     // ... data to create a Vehicle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle we want to update
     *   }
     * })
     */
    upsert<T extends VehicleUpsertArgs>(args: SelectSubset<T, VehicleUpsertArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleCountArgs} args - Arguments to filter Vehicles to count.
     * @example
     * // Count the number of Vehicles
     * const count = await prisma.vehicle.count({
     *   where: {
     *     // ... the filter for the Vehicles we want to count
     *   }
     * })
    **/
    count<T extends VehicleCountArgs>(
      args?: Subset<T, VehicleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleAggregateArgs>(args: Subset<T, VehicleAggregateArgs>): Prisma.PrismaPromise<GetVehicleAggregateType<T>>

    /**
     * Group by Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleGroupByArgs['orderBy'] }
        : { orderBy?: VehicleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vehicle model
   */
  readonly fields: VehicleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vehicle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deliveries<T extends Vehicle$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vehicle model
   */
  interface VehicleFieldRefs {
    readonly id: FieldRef<"Vehicle", 'String'>
    readonly name: FieldRef<"Vehicle", 'String'>
    readonly type: FieldRef<"Vehicle", 'VehicleType'>
    readonly status: FieldRef<"Vehicle", 'VehicleStatus'>
    readonly currentDeliveryId: FieldRef<"Vehicle", 'String'>
    readonly createdAt: FieldRef<"Vehicle", 'DateTime'>
    readonly updatedAt: FieldRef<"Vehicle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vehicle findUnique
   */
  export type VehicleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findUniqueOrThrow
   */
  export type VehicleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findFirst
   */
  export type VehicleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findFirstOrThrow
   */
  export type VehicleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findMany
   */
  export type VehicleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicles to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle create
   */
  export type VehicleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to create a Vehicle.
     */
    data: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
  }

  /**
   * Vehicle createMany
   */
  export type VehicleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vehicle createManyAndReturn
   */
  export type VehicleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vehicle update
   */
  export type VehicleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to update a Vehicle.
     */
    data: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
    /**
     * Choose, which Vehicle to update.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle updateMany
   */
  export type VehicleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to update.
     */
    limit?: number
  }

  /**
   * Vehicle updateManyAndReturn
   */
  export type VehicleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to update.
     */
    limit?: number
  }

  /**
   * Vehicle upsert
   */
  export type VehicleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The filter to search for the Vehicle to update in case it exists.
     */
    where: VehicleWhereUniqueInput
    /**
     * In case the Vehicle found by the `where` argument doesn't exist, create a new Vehicle with this data.
     */
    create: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
    /**
     * In case the Vehicle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
  }

  /**
   * Vehicle delete
   */
  export type VehicleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter which Vehicle to delete.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle deleteMany
   */
  export type VehicleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicles to delete
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to delete.
     */
    limit?: number
  }

  /**
   * Vehicle.deliveries
   */
  export type Vehicle$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    where?: DeliveryWhereInput
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    cursor?: DeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Vehicle without action
   */
  export type VehicleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
  }


  /**
   * Model Delivery
   */

  export type AggregateDelivery = {
    _count: DeliveryCountAggregateOutputType | null
    _avg: DeliveryAvgAggregateOutputType | null
    _sum: DeliverySumAggregateOutputType | null
    _min: DeliveryMinAggregateOutputType | null
    _max: DeliveryMaxAggregateOutputType | null
  }

  export type DeliveryAvgAggregateOutputType = {
    etaOverrideCount: number | null
    delayMinutes: number | null
    latitude: number | null
    longitude: number | null
  }

  export type DeliverySumAggregateOutputType = {
    etaOverrideCount: number | null
    delayMinutes: number | null
    latitude: number | null
    longitude: number | null
  }

  export type DeliveryMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    deliveryMethod: $Enums.DeliveryMethod | null
    deliveryType: $Enums.DeliveryType | null
    vehicleId: string | null
    status: $Enums.DeliveryStatus | null
    claimedByWorkerId: string | null
    claimedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    eta: Date | null
    etaOverrideCount: number | null
    delayMinutes: number | null
    latitude: number | null
    longitude: number | null
    lastLocationUpdate: Date | null
    trackingCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    deliveryMethod: $Enums.DeliveryMethod | null
    deliveryType: $Enums.DeliveryType | null
    vehicleId: string | null
    status: $Enums.DeliveryStatus | null
    claimedByWorkerId: string | null
    claimedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    eta: Date | null
    etaOverrideCount: number | null
    delayMinutes: number | null
    latitude: number | null
    longitude: number | null
    lastLocationUpdate: Date | null
    trackingCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryCountAggregateOutputType = {
    id: number
    invoiceId: number
    deliveryMethod: number
    deliveryType: number
    vehicleId: number
    status: number
    claimedByWorkerId: number
    claimedAt: number
    startedAt: number
    completedAt: number
    eta: number
    etaOverrideCount: number
    delayMinutes: number
    latitude: number
    longitude: number
    lastLocationUpdate: number
    trackingCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeliveryAvgAggregateInputType = {
    etaOverrideCount?: true
    delayMinutes?: true
    latitude?: true
    longitude?: true
  }

  export type DeliverySumAggregateInputType = {
    etaOverrideCount?: true
    delayMinutes?: true
    latitude?: true
    longitude?: true
  }

  export type DeliveryMinAggregateInputType = {
    id?: true
    invoiceId?: true
    deliveryMethod?: true
    deliveryType?: true
    vehicleId?: true
    status?: true
    claimedByWorkerId?: true
    claimedAt?: true
    startedAt?: true
    completedAt?: true
    eta?: true
    etaOverrideCount?: true
    delayMinutes?: true
    latitude?: true
    longitude?: true
    lastLocationUpdate?: true
    trackingCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    deliveryMethod?: true
    deliveryType?: true
    vehicleId?: true
    status?: true
    claimedByWorkerId?: true
    claimedAt?: true
    startedAt?: true
    completedAt?: true
    eta?: true
    etaOverrideCount?: true
    delayMinutes?: true
    latitude?: true
    longitude?: true
    lastLocationUpdate?: true
    trackingCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryCountAggregateInputType = {
    id?: true
    invoiceId?: true
    deliveryMethod?: true
    deliveryType?: true
    vehicleId?: true
    status?: true
    claimedByWorkerId?: true
    claimedAt?: true
    startedAt?: true
    completedAt?: true
    eta?: true
    etaOverrideCount?: true
    delayMinutes?: true
    latitude?: true
    longitude?: true
    lastLocationUpdate?: true
    trackingCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeliveryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Delivery to aggregate.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deliveries
    **/
    _count?: true | DeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliverySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryMaxAggregateInputType
  }

  export type GetDeliveryAggregateType<T extends DeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDelivery[P]>
      : GetScalarType<T[P], AggregateDelivery[P]>
  }




  export type DeliveryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryWhereInput
    orderBy?: DeliveryOrderByWithAggregationInput | DeliveryOrderByWithAggregationInput[]
    by: DeliveryScalarFieldEnum[] | DeliveryScalarFieldEnum
    having?: DeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryCountAggregateInputType | true
    _avg?: DeliveryAvgAggregateInputType
    _sum?: DeliverySumAggregateInputType
    _min?: DeliveryMinAggregateInputType
    _max?: DeliveryMaxAggregateInputType
  }

  export type DeliveryGroupByOutputType = {
    id: string
    invoiceId: string | null
    deliveryMethod: $Enums.DeliveryMethod
    deliveryType: $Enums.DeliveryType
    vehicleId: string | null
    status: $Enums.DeliveryStatus
    claimedByWorkerId: string | null
    claimedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    eta: Date | null
    etaOverrideCount: number
    delayMinutes: number
    latitude: number | null
    longitude: number | null
    lastLocationUpdate: Date | null
    trackingCode: string | null
    createdAt: Date
    updatedAt: Date
    _count: DeliveryCountAggregateOutputType | null
    _avg: DeliveryAvgAggregateOutputType | null
    _sum: DeliverySumAggregateOutputType | null
    _min: DeliveryMinAggregateOutputType | null
    _max: DeliveryMaxAggregateOutputType | null
  }

  type GetDeliveryGroupByPayload<T extends DeliveryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryGroupByOutputType[P]>
        }
      >
    >


  export type DeliverySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    deliveryMethod?: boolean
    deliveryType?: boolean
    vehicleId?: boolean
    status?: boolean
    claimedByWorkerId?: boolean
    claimedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    eta?: boolean
    etaOverrideCount?: boolean
    delayMinutes?: boolean
    latitude?: boolean
    longitude?: boolean
    lastLocationUpdate?: boolean
    trackingCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | Delivery$invoiceArgs<ExtArgs>
    vehicle?: boolean | Delivery$vehicleArgs<ExtArgs>
    claimedByWorker?: boolean | Delivery$claimedByWorkerArgs<ExtArgs>
    items?: boolean | Delivery$itemsArgs<ExtArgs>
    logs?: boolean | Delivery$logsArgs<ExtArgs>
    editLogs?: boolean | Delivery$editLogsArgs<ExtArgs>
    _count?: boolean | DeliveryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["delivery"]>

  export type DeliverySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    deliveryMethod?: boolean
    deliveryType?: boolean
    vehicleId?: boolean
    status?: boolean
    claimedByWorkerId?: boolean
    claimedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    eta?: boolean
    etaOverrideCount?: boolean
    delayMinutes?: boolean
    latitude?: boolean
    longitude?: boolean
    lastLocationUpdate?: boolean
    trackingCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | Delivery$invoiceArgs<ExtArgs>
    vehicle?: boolean | Delivery$vehicleArgs<ExtArgs>
    claimedByWorker?: boolean | Delivery$claimedByWorkerArgs<ExtArgs>
  }, ExtArgs["result"]["delivery"]>

  export type DeliverySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    deliveryMethod?: boolean
    deliveryType?: boolean
    vehicleId?: boolean
    status?: boolean
    claimedByWorkerId?: boolean
    claimedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    eta?: boolean
    etaOverrideCount?: boolean
    delayMinutes?: boolean
    latitude?: boolean
    longitude?: boolean
    lastLocationUpdate?: boolean
    trackingCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | Delivery$invoiceArgs<ExtArgs>
    vehicle?: boolean | Delivery$vehicleArgs<ExtArgs>
    claimedByWorker?: boolean | Delivery$claimedByWorkerArgs<ExtArgs>
  }, ExtArgs["result"]["delivery"]>

  export type DeliverySelectScalar = {
    id?: boolean
    invoiceId?: boolean
    deliveryMethod?: boolean
    deliveryType?: boolean
    vehicleId?: boolean
    status?: boolean
    claimedByWorkerId?: boolean
    claimedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    eta?: boolean
    etaOverrideCount?: boolean
    delayMinutes?: boolean
    latitude?: boolean
    longitude?: boolean
    lastLocationUpdate?: boolean
    trackingCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeliveryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "deliveryMethod" | "deliveryType" | "vehicleId" | "status" | "claimedByWorkerId" | "claimedAt" | "startedAt" | "completedAt" | "eta" | "etaOverrideCount" | "delayMinutes" | "latitude" | "longitude" | "lastLocationUpdate" | "trackingCode" | "createdAt" | "updatedAt", ExtArgs["result"]["delivery"]>
  export type DeliveryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | Delivery$invoiceArgs<ExtArgs>
    vehicle?: boolean | Delivery$vehicleArgs<ExtArgs>
    claimedByWorker?: boolean | Delivery$claimedByWorkerArgs<ExtArgs>
    items?: boolean | Delivery$itemsArgs<ExtArgs>
    logs?: boolean | Delivery$logsArgs<ExtArgs>
    editLogs?: boolean | Delivery$editLogsArgs<ExtArgs>
    _count?: boolean | DeliveryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeliveryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | Delivery$invoiceArgs<ExtArgs>
    vehicle?: boolean | Delivery$vehicleArgs<ExtArgs>
    claimedByWorker?: boolean | Delivery$claimedByWorkerArgs<ExtArgs>
  }
  export type DeliveryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | Delivery$invoiceArgs<ExtArgs>
    vehicle?: boolean | Delivery$vehicleArgs<ExtArgs>
    claimedByWorker?: boolean | Delivery$claimedByWorkerArgs<ExtArgs>
  }

  export type $DeliveryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Delivery"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      vehicle: Prisma.$VehiclePayload<ExtArgs> | null
      claimedByWorker: Prisma.$UserPayload<ExtArgs> | null
      items: Prisma.$DeliveryItemPayload<ExtArgs>[]
      logs: Prisma.$DeliveryLogPayload<ExtArgs>[]
      editLogs: Prisma.$DeliveryEditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string | null
      deliveryMethod: $Enums.DeliveryMethod
      deliveryType: $Enums.DeliveryType
      vehicleId: string | null
      status: $Enums.DeliveryStatus
      claimedByWorkerId: string | null
      claimedAt: Date | null
      startedAt: Date | null
      completedAt: Date | null
      eta: Date | null
      etaOverrideCount: number
      delayMinutes: number
      latitude: number | null
      longitude: number | null
      lastLocationUpdate: Date | null
      trackingCode: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["delivery"]>
    composites: {}
  }

  type DeliveryGetPayload<S extends boolean | null | undefined | DeliveryDefaultArgs> = $Result.GetResult<Prisma.$DeliveryPayload, S>

  type DeliveryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryCountAggregateInputType | true
    }

  export interface DeliveryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Delivery'], meta: { name: 'Delivery' } }
    /**
     * Find zero or one Delivery that matches the filter.
     * @param {DeliveryFindUniqueArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryFindUniqueArgs>(args: SelectSubset<T, DeliveryFindUniqueArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Delivery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryFindUniqueOrThrowArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Delivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindFirstArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryFindFirstArgs>(args?: SelectSubset<T, DeliveryFindFirstArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Delivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindFirstOrThrowArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Deliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deliveries
     * const deliveries = await prisma.delivery.findMany()
     * 
     * // Get first 10 Deliveries
     * const deliveries = await prisma.delivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryWithIdOnly = await prisma.delivery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryFindManyArgs>(args?: SelectSubset<T, DeliveryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Delivery.
     * @param {DeliveryCreateArgs} args - Arguments to create a Delivery.
     * @example
     * // Create one Delivery
     * const Delivery = await prisma.delivery.create({
     *   data: {
     *     // ... data to create a Delivery
     *   }
     * })
     * 
     */
    create<T extends DeliveryCreateArgs>(args: SelectSubset<T, DeliveryCreateArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Deliveries.
     * @param {DeliveryCreateManyArgs} args - Arguments to create many Deliveries.
     * @example
     * // Create many Deliveries
     * const delivery = await prisma.delivery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryCreateManyArgs>(args?: SelectSubset<T, DeliveryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deliveries and returns the data saved in the database.
     * @param {DeliveryCreateManyAndReturnArgs} args - Arguments to create many Deliveries.
     * @example
     * // Create many Deliveries
     * const delivery = await prisma.delivery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deliveries and only return the `id`
     * const deliveryWithIdOnly = await prisma.delivery.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Delivery.
     * @param {DeliveryDeleteArgs} args - Arguments to delete one Delivery.
     * @example
     * // Delete one Delivery
     * const Delivery = await prisma.delivery.delete({
     *   where: {
     *     // ... filter to delete one Delivery
     *   }
     * })
     * 
     */
    delete<T extends DeliveryDeleteArgs>(args: SelectSubset<T, DeliveryDeleteArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Delivery.
     * @param {DeliveryUpdateArgs} args - Arguments to update one Delivery.
     * @example
     * // Update one Delivery
     * const delivery = await prisma.delivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryUpdateArgs>(args: SelectSubset<T, DeliveryUpdateArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Deliveries.
     * @param {DeliveryDeleteManyArgs} args - Arguments to filter Deliveries to delete.
     * @example
     * // Delete a few Deliveries
     * const { count } = await prisma.delivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryDeleteManyArgs>(args?: SelectSubset<T, DeliveryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deliveries
     * const delivery = await prisma.delivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryUpdateManyArgs>(args: SelectSubset<T, DeliveryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deliveries and returns the data updated in the database.
     * @param {DeliveryUpdateManyAndReturnArgs} args - Arguments to update many Deliveries.
     * @example
     * // Update many Deliveries
     * const delivery = await prisma.delivery.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Deliveries and only return the `id`
     * const deliveryWithIdOnly = await prisma.delivery.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Delivery.
     * @param {DeliveryUpsertArgs} args - Arguments to update or create a Delivery.
     * @example
     * // Update or create a Delivery
     * const delivery = await prisma.delivery.upsert({
     *   create: {
     *     // ... data to create a Delivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Delivery we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryUpsertArgs>(args: SelectSubset<T, DeliveryUpsertArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Deliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryCountArgs} args - Arguments to filter Deliveries to count.
     * @example
     * // Count the number of Deliveries
     * const count = await prisma.delivery.count({
     *   where: {
     *     // ... the filter for the Deliveries we want to count
     *   }
     * })
    **/
    count<T extends DeliveryCountArgs>(
      args?: Subset<T, DeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Delivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryAggregateArgs>(args: Subset<T, DeliveryAggregateArgs>): Prisma.PrismaPromise<GetDeliveryAggregateType<T>>

    /**
     * Group by Delivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Delivery model
   */
  readonly fields: DeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Delivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends Delivery$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Delivery$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    vehicle<T extends Delivery$vehicleArgs<ExtArgs> = {}>(args?: Subset<T, Delivery$vehicleArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    claimedByWorker<T extends Delivery$claimedByWorkerArgs<ExtArgs> = {}>(args?: Subset<T, Delivery$claimedByWorkerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Delivery$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Delivery$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    logs<T extends Delivery$logsArgs<ExtArgs> = {}>(args?: Subset<T, Delivery$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    editLogs<T extends Delivery$editLogsArgs<ExtArgs> = {}>(args?: Subset<T, Delivery$editLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryEditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Delivery model
   */
  interface DeliveryFieldRefs {
    readonly id: FieldRef<"Delivery", 'String'>
    readonly invoiceId: FieldRef<"Delivery", 'String'>
    readonly deliveryMethod: FieldRef<"Delivery", 'DeliveryMethod'>
    readonly deliveryType: FieldRef<"Delivery", 'DeliveryType'>
    readonly vehicleId: FieldRef<"Delivery", 'String'>
    readonly status: FieldRef<"Delivery", 'DeliveryStatus'>
    readonly claimedByWorkerId: FieldRef<"Delivery", 'String'>
    readonly claimedAt: FieldRef<"Delivery", 'DateTime'>
    readonly startedAt: FieldRef<"Delivery", 'DateTime'>
    readonly completedAt: FieldRef<"Delivery", 'DateTime'>
    readonly eta: FieldRef<"Delivery", 'DateTime'>
    readonly etaOverrideCount: FieldRef<"Delivery", 'Int'>
    readonly delayMinutes: FieldRef<"Delivery", 'Int'>
    readonly latitude: FieldRef<"Delivery", 'Float'>
    readonly longitude: FieldRef<"Delivery", 'Float'>
    readonly lastLocationUpdate: FieldRef<"Delivery", 'DateTime'>
    readonly trackingCode: FieldRef<"Delivery", 'String'>
    readonly createdAt: FieldRef<"Delivery", 'DateTime'>
    readonly updatedAt: FieldRef<"Delivery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Delivery findUnique
   */
  export type DeliveryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery findUniqueOrThrow
   */
  export type DeliveryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery findFirst
   */
  export type DeliveryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deliveries.
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deliveries.
     */
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Delivery findFirstOrThrow
   */
  export type DeliveryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deliveries.
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deliveries.
     */
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Delivery findMany
   */
  export type DeliveryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Deliveries to fetch.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deliveries.
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Delivery create
   */
  export type DeliveryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * The data needed to create a Delivery.
     */
    data: XOR<DeliveryCreateInput, DeliveryUncheckedCreateInput>
  }

  /**
   * Delivery createMany
   */
  export type DeliveryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deliveries.
     */
    data: DeliveryCreateManyInput | DeliveryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Delivery createManyAndReturn
   */
  export type DeliveryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * The data used to create many Deliveries.
     */
    data: DeliveryCreateManyInput | DeliveryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Delivery update
   */
  export type DeliveryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * The data needed to update a Delivery.
     */
    data: XOR<DeliveryUpdateInput, DeliveryUncheckedUpdateInput>
    /**
     * Choose, which Delivery to update.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery updateMany
   */
  export type DeliveryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deliveries.
     */
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyInput>
    /**
     * Filter which Deliveries to update
     */
    where?: DeliveryWhereInput
    /**
     * Limit how many Deliveries to update.
     */
    limit?: number
  }

  /**
   * Delivery updateManyAndReturn
   */
  export type DeliveryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * The data used to update Deliveries.
     */
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyInput>
    /**
     * Filter which Deliveries to update
     */
    where?: DeliveryWhereInput
    /**
     * Limit how many Deliveries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Delivery upsert
   */
  export type DeliveryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * The filter to search for the Delivery to update in case it exists.
     */
    where: DeliveryWhereUniqueInput
    /**
     * In case the Delivery found by the `where` argument doesn't exist, create a new Delivery with this data.
     */
    create: XOR<DeliveryCreateInput, DeliveryUncheckedCreateInput>
    /**
     * In case the Delivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryUpdateInput, DeliveryUncheckedUpdateInput>
  }

  /**
   * Delivery delete
   */
  export type DeliveryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter which Delivery to delete.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery deleteMany
   */
  export type DeliveryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deliveries to delete
     */
    where?: DeliveryWhereInput
    /**
     * Limit how many Deliveries to delete.
     */
    limit?: number
  }

  /**
   * Delivery.invoice
   */
  export type Delivery$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Delivery.vehicle
   */
  export type Delivery$vehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    where?: VehicleWhereInput
  }

  /**
   * Delivery.claimedByWorker
   */
  export type Delivery$claimedByWorkerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Delivery.items
   */
  export type Delivery$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryItem
     */
    omit?: DeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryItemInclude<ExtArgs> | null
    where?: DeliveryItemWhereInput
    orderBy?: DeliveryItemOrderByWithRelationInput | DeliveryItemOrderByWithRelationInput[]
    cursor?: DeliveryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryItemScalarFieldEnum | DeliveryItemScalarFieldEnum[]
  }

  /**
   * Delivery.logs
   */
  export type Delivery$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogInclude<ExtArgs> | null
    where?: DeliveryLogWhereInput
    orderBy?: DeliveryLogOrderByWithRelationInput | DeliveryLogOrderByWithRelationInput[]
    cursor?: DeliveryLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryLogScalarFieldEnum | DeliveryLogScalarFieldEnum[]
  }

  /**
   * Delivery.editLogs
   */
  export type Delivery$editLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEditLog
     */
    select?: DeliveryEditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEditLog
     */
    omit?: DeliveryEditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEditLogInclude<ExtArgs> | null
    where?: DeliveryEditLogWhereInput
    orderBy?: DeliveryEditLogOrderByWithRelationInput | DeliveryEditLogOrderByWithRelationInput[]
    cursor?: DeliveryEditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryEditLogScalarFieldEnum | DeliveryEditLogScalarFieldEnum[]
  }

  /**
   * Delivery without action
   */
  export type DeliveryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryItem
   */

  export type AggregateDeliveryItem = {
    _count: DeliveryItemCountAggregateOutputType | null
    _avg: DeliveryItemAvgAggregateOutputType | null
    _sum: DeliveryItemSumAggregateOutputType | null
    _min: DeliveryItemMinAggregateOutputType | null
    _max: DeliveryItemMaxAggregateOutputType | null
  }

  export type DeliveryItemAvgAggregateOutputType = {
    quantity: number | null
  }

  export type DeliveryItemSumAggregateOutputType = {
    quantity: number | null
  }

  export type DeliveryItemMinAggregateOutputType = {
    id: string | null
    deliveryId: string | null
    rentalItemId: string | null
    quantity: number | null
  }

  export type DeliveryItemMaxAggregateOutputType = {
    id: string | null
    deliveryId: string | null
    rentalItemId: string | null
    quantity: number | null
  }

  export type DeliveryItemCountAggregateOutputType = {
    id: number
    deliveryId: number
    rentalItemId: number
    quantity: number
    _all: number
  }


  export type DeliveryItemAvgAggregateInputType = {
    quantity?: true
  }

  export type DeliveryItemSumAggregateInputType = {
    quantity?: true
  }

  export type DeliveryItemMinAggregateInputType = {
    id?: true
    deliveryId?: true
    rentalItemId?: true
    quantity?: true
  }

  export type DeliveryItemMaxAggregateInputType = {
    id?: true
    deliveryId?: true
    rentalItemId?: true
    quantity?: true
  }

  export type DeliveryItemCountAggregateInputType = {
    id?: true
    deliveryId?: true
    rentalItemId?: true
    quantity?: true
    _all?: true
  }

  export type DeliveryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryItem to aggregate.
     */
    where?: DeliveryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryItems to fetch.
     */
    orderBy?: DeliveryItemOrderByWithRelationInput | DeliveryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryItems
    **/
    _count?: true | DeliveryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryItemMaxAggregateInputType
  }

  export type GetDeliveryItemAggregateType<T extends DeliveryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryItem[P]>
      : GetScalarType<T[P], AggregateDeliveryItem[P]>
  }




  export type DeliveryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryItemWhereInput
    orderBy?: DeliveryItemOrderByWithAggregationInput | DeliveryItemOrderByWithAggregationInput[]
    by: DeliveryItemScalarFieldEnum[] | DeliveryItemScalarFieldEnum
    having?: DeliveryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryItemCountAggregateInputType | true
    _avg?: DeliveryItemAvgAggregateInputType
    _sum?: DeliveryItemSumAggregateInputType
    _min?: DeliveryItemMinAggregateInputType
    _max?: DeliveryItemMaxAggregateInputType
  }

  export type DeliveryItemGroupByOutputType = {
    id: string
    deliveryId: string
    rentalItemId: string
    quantity: number
    _count: DeliveryItemCountAggregateOutputType | null
    _avg: DeliveryItemAvgAggregateOutputType | null
    _sum: DeliveryItemSumAggregateOutputType | null
    _min: DeliveryItemMinAggregateOutputType | null
    _max: DeliveryItemMaxAggregateOutputType | null
  }

  type GetDeliveryItemGroupByPayload<T extends DeliveryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryItemGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryItemGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deliveryId?: boolean
    rentalItemId?: boolean
    quantity?: boolean
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    rentalItem?: boolean | RentalItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryItem"]>

  export type DeliveryItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deliveryId?: boolean
    rentalItemId?: boolean
    quantity?: boolean
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    rentalItem?: boolean | RentalItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryItem"]>

  export type DeliveryItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deliveryId?: boolean
    rentalItemId?: boolean
    quantity?: boolean
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    rentalItem?: boolean | RentalItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryItem"]>

  export type DeliveryItemSelectScalar = {
    id?: boolean
    deliveryId?: boolean
    rentalItemId?: boolean
    quantity?: boolean
  }

  export type DeliveryItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deliveryId" | "rentalItemId" | "quantity", ExtArgs["result"]["deliveryItem"]>
  export type DeliveryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    rentalItem?: boolean | RentalItemDefaultArgs<ExtArgs>
  }
  export type DeliveryItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    rentalItem?: boolean | RentalItemDefaultArgs<ExtArgs>
  }
  export type DeliveryItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    rentalItem?: boolean | RentalItemDefaultArgs<ExtArgs>
  }

  export type $DeliveryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryItem"
    objects: {
      delivery: Prisma.$DeliveryPayload<ExtArgs>
      rentalItem: Prisma.$RentalItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deliveryId: string
      rentalItemId: string
      quantity: number
    }, ExtArgs["result"]["deliveryItem"]>
    composites: {}
  }

  type DeliveryItemGetPayload<S extends boolean | null | undefined | DeliveryItemDefaultArgs> = $Result.GetResult<Prisma.$DeliveryItemPayload, S>

  type DeliveryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryItemCountAggregateInputType | true
    }

  export interface DeliveryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryItem'], meta: { name: 'DeliveryItem' } }
    /**
     * Find zero or one DeliveryItem that matches the filter.
     * @param {DeliveryItemFindUniqueArgs} args - Arguments to find a DeliveryItem
     * @example
     * // Get one DeliveryItem
     * const deliveryItem = await prisma.deliveryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryItemFindUniqueArgs>(args: SelectSubset<T, DeliveryItemFindUniqueArgs<ExtArgs>>): Prisma__DeliveryItemClient<$Result.GetResult<Prisma.$DeliveryItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryItemFindUniqueOrThrowArgs} args - Arguments to find a DeliveryItem
     * @example
     * // Get one DeliveryItem
     * const deliveryItem = await prisma.deliveryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryItemClient<$Result.GetResult<Prisma.$DeliveryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryItemFindFirstArgs} args - Arguments to find a DeliveryItem
     * @example
     * // Get one DeliveryItem
     * const deliveryItem = await prisma.deliveryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryItemFindFirstArgs>(args?: SelectSubset<T, DeliveryItemFindFirstArgs<ExtArgs>>): Prisma__DeliveryItemClient<$Result.GetResult<Prisma.$DeliveryItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryItemFindFirstOrThrowArgs} args - Arguments to find a DeliveryItem
     * @example
     * // Get one DeliveryItem
     * const deliveryItem = await prisma.deliveryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryItemClient<$Result.GetResult<Prisma.$DeliveryItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryItems
     * const deliveryItems = await prisma.deliveryItem.findMany()
     * 
     * // Get first 10 DeliveryItems
     * const deliveryItems = await prisma.deliveryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryItemWithIdOnly = await prisma.deliveryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryItemFindManyArgs>(args?: SelectSubset<T, DeliveryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryItem.
     * @param {DeliveryItemCreateArgs} args - Arguments to create a DeliveryItem.
     * @example
     * // Create one DeliveryItem
     * const DeliveryItem = await prisma.deliveryItem.create({
     *   data: {
     *     // ... data to create a DeliveryItem
     *   }
     * })
     * 
     */
    create<T extends DeliveryItemCreateArgs>(args: SelectSubset<T, DeliveryItemCreateArgs<ExtArgs>>): Prisma__DeliveryItemClient<$Result.GetResult<Prisma.$DeliveryItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryItems.
     * @param {DeliveryItemCreateManyArgs} args - Arguments to create many DeliveryItems.
     * @example
     * // Create many DeliveryItems
     * const deliveryItem = await prisma.deliveryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryItemCreateManyArgs>(args?: SelectSubset<T, DeliveryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryItems and returns the data saved in the database.
     * @param {DeliveryItemCreateManyAndReturnArgs} args - Arguments to create many DeliveryItems.
     * @example
     * // Create many DeliveryItems
     * const deliveryItem = await prisma.deliveryItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryItems and only return the `id`
     * const deliveryItemWithIdOnly = await prisma.deliveryItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryItemCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryItem.
     * @param {DeliveryItemDeleteArgs} args - Arguments to delete one DeliveryItem.
     * @example
     * // Delete one DeliveryItem
     * const DeliveryItem = await prisma.deliveryItem.delete({
     *   where: {
     *     // ... filter to delete one DeliveryItem
     *   }
     * })
     * 
     */
    delete<T extends DeliveryItemDeleteArgs>(args: SelectSubset<T, DeliveryItemDeleteArgs<ExtArgs>>): Prisma__DeliveryItemClient<$Result.GetResult<Prisma.$DeliveryItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryItem.
     * @param {DeliveryItemUpdateArgs} args - Arguments to update one DeliveryItem.
     * @example
     * // Update one DeliveryItem
     * const deliveryItem = await prisma.deliveryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryItemUpdateArgs>(args: SelectSubset<T, DeliveryItemUpdateArgs<ExtArgs>>): Prisma__DeliveryItemClient<$Result.GetResult<Prisma.$DeliveryItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryItems.
     * @param {DeliveryItemDeleteManyArgs} args - Arguments to filter DeliveryItems to delete.
     * @example
     * // Delete a few DeliveryItems
     * const { count } = await prisma.deliveryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryItemDeleteManyArgs>(args?: SelectSubset<T, DeliveryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryItems
     * const deliveryItem = await prisma.deliveryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryItemUpdateManyArgs>(args: SelectSubset<T, DeliveryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryItems and returns the data updated in the database.
     * @param {DeliveryItemUpdateManyAndReturnArgs} args - Arguments to update many DeliveryItems.
     * @example
     * // Update many DeliveryItems
     * const deliveryItem = await prisma.deliveryItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryItems and only return the `id`
     * const deliveryItemWithIdOnly = await prisma.deliveryItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryItemUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryItem.
     * @param {DeliveryItemUpsertArgs} args - Arguments to update or create a DeliveryItem.
     * @example
     * // Update or create a DeliveryItem
     * const deliveryItem = await prisma.deliveryItem.upsert({
     *   create: {
     *     // ... data to create a DeliveryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryItem we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryItemUpsertArgs>(args: SelectSubset<T, DeliveryItemUpsertArgs<ExtArgs>>): Prisma__DeliveryItemClient<$Result.GetResult<Prisma.$DeliveryItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryItemCountArgs} args - Arguments to filter DeliveryItems to count.
     * @example
     * // Count the number of DeliveryItems
     * const count = await prisma.deliveryItem.count({
     *   where: {
     *     // ... the filter for the DeliveryItems we want to count
     *   }
     * })
    **/
    count<T extends DeliveryItemCountArgs>(
      args?: Subset<T, DeliveryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryItemAggregateArgs>(args: Subset<T, DeliveryItemAggregateArgs>): Prisma.PrismaPromise<GetDeliveryItemAggregateType<T>>

    /**
     * Group by DeliveryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryItemGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryItem model
   */
  readonly fields: DeliveryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    delivery<T extends DeliveryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryDefaultArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rentalItem<T extends RentalItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RentalItemDefaultArgs<ExtArgs>>): Prisma__RentalItemClient<$Result.GetResult<Prisma.$RentalItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryItem model
   */
  interface DeliveryItemFieldRefs {
    readonly id: FieldRef<"DeliveryItem", 'String'>
    readonly deliveryId: FieldRef<"DeliveryItem", 'String'>
    readonly rentalItemId: FieldRef<"DeliveryItem", 'String'>
    readonly quantity: FieldRef<"DeliveryItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryItem findUnique
   */
  export type DeliveryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryItem
     */
    omit?: DeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryItemInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryItem to fetch.
     */
    where: DeliveryItemWhereUniqueInput
  }

  /**
   * DeliveryItem findUniqueOrThrow
   */
  export type DeliveryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryItem
     */
    omit?: DeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryItemInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryItem to fetch.
     */
    where: DeliveryItemWhereUniqueInput
  }

  /**
   * DeliveryItem findFirst
   */
  export type DeliveryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryItem
     */
    omit?: DeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryItemInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryItem to fetch.
     */
    where?: DeliveryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryItems to fetch.
     */
    orderBy?: DeliveryItemOrderByWithRelationInput | DeliveryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryItems.
     */
    cursor?: DeliveryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryItems.
     */
    distinct?: DeliveryItemScalarFieldEnum | DeliveryItemScalarFieldEnum[]
  }

  /**
   * DeliveryItem findFirstOrThrow
   */
  export type DeliveryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryItem
     */
    omit?: DeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryItemInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryItem to fetch.
     */
    where?: DeliveryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryItems to fetch.
     */
    orderBy?: DeliveryItemOrderByWithRelationInput | DeliveryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryItems.
     */
    cursor?: DeliveryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryItems.
     */
    distinct?: DeliveryItemScalarFieldEnum | DeliveryItemScalarFieldEnum[]
  }

  /**
   * DeliveryItem findMany
   */
  export type DeliveryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryItem
     */
    omit?: DeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryItemInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryItems to fetch.
     */
    where?: DeliveryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryItems to fetch.
     */
    orderBy?: DeliveryItemOrderByWithRelationInput | DeliveryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryItems.
     */
    cursor?: DeliveryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryItems.
     */
    skip?: number
    distinct?: DeliveryItemScalarFieldEnum | DeliveryItemScalarFieldEnum[]
  }

  /**
   * DeliveryItem create
   */
  export type DeliveryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryItem
     */
    omit?: DeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryItem.
     */
    data: XOR<DeliveryItemCreateInput, DeliveryItemUncheckedCreateInput>
  }

  /**
   * DeliveryItem createMany
   */
  export type DeliveryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryItems.
     */
    data: DeliveryItemCreateManyInput | DeliveryItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryItem createManyAndReturn
   */
  export type DeliveryItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryItem
     */
    omit?: DeliveryItemOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryItems.
     */
    data: DeliveryItemCreateManyInput | DeliveryItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryItem update
   */
  export type DeliveryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryItem
     */
    omit?: DeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryItem.
     */
    data: XOR<DeliveryItemUpdateInput, DeliveryItemUncheckedUpdateInput>
    /**
     * Choose, which DeliveryItem to update.
     */
    where: DeliveryItemWhereUniqueInput
  }

  /**
   * DeliveryItem updateMany
   */
  export type DeliveryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryItems.
     */
    data: XOR<DeliveryItemUpdateManyMutationInput, DeliveryItemUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryItems to update
     */
    where?: DeliveryItemWhereInput
    /**
     * Limit how many DeliveryItems to update.
     */
    limit?: number
  }

  /**
   * DeliveryItem updateManyAndReturn
   */
  export type DeliveryItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryItem
     */
    omit?: DeliveryItemOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryItems.
     */
    data: XOR<DeliveryItemUpdateManyMutationInput, DeliveryItemUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryItems to update
     */
    where?: DeliveryItemWhereInput
    /**
     * Limit how many DeliveryItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryItem upsert
   */
  export type DeliveryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryItem
     */
    omit?: DeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryItem to update in case it exists.
     */
    where: DeliveryItemWhereUniqueInput
    /**
     * In case the DeliveryItem found by the `where` argument doesn't exist, create a new DeliveryItem with this data.
     */
    create: XOR<DeliveryItemCreateInput, DeliveryItemUncheckedCreateInput>
    /**
     * In case the DeliveryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryItemUpdateInput, DeliveryItemUncheckedUpdateInput>
  }

  /**
   * DeliveryItem delete
   */
  export type DeliveryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryItem
     */
    omit?: DeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryItemInclude<ExtArgs> | null
    /**
     * Filter which DeliveryItem to delete.
     */
    where: DeliveryItemWhereUniqueInput
  }

  /**
   * DeliveryItem deleteMany
   */
  export type DeliveryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryItems to delete
     */
    where?: DeliveryItemWhereInput
    /**
     * Limit how many DeliveryItems to delete.
     */
    limit?: number
  }

  /**
   * DeliveryItem without action
   */
  export type DeliveryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryItem
     */
    omit?: DeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryItemInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryLog
   */

  export type AggregateDeliveryLog = {
    _count: DeliveryLogCountAggregateOutputType | null
    _min: DeliveryLogMinAggregateOutputType | null
    _max: DeliveryLogMaxAggregateOutputType | null
  }

  export type DeliveryLogMinAggregateOutputType = {
    id: string | null
    deliveryId: string | null
    eventType: string | null
    createdByUserId: string | null
    role: $Enums.DeliveryRole | null
    createdAt: Date | null
  }

  export type DeliveryLogMaxAggregateOutputType = {
    id: string | null
    deliveryId: string | null
    eventType: string | null
    createdByUserId: string | null
    role: $Enums.DeliveryRole | null
    createdAt: Date | null
  }

  export type DeliveryLogCountAggregateOutputType = {
    id: number
    deliveryId: number
    eventType: number
    oldValue: number
    newValue: number
    createdByUserId: number
    role: number
    createdAt: number
    _all: number
  }


  export type DeliveryLogMinAggregateInputType = {
    id?: true
    deliveryId?: true
    eventType?: true
    createdByUserId?: true
    role?: true
    createdAt?: true
  }

  export type DeliveryLogMaxAggregateInputType = {
    id?: true
    deliveryId?: true
    eventType?: true
    createdByUserId?: true
    role?: true
    createdAt?: true
  }

  export type DeliveryLogCountAggregateInputType = {
    id?: true
    deliveryId?: true
    eventType?: true
    oldValue?: true
    newValue?: true
    createdByUserId?: true
    role?: true
    createdAt?: true
    _all?: true
  }

  export type DeliveryLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryLog to aggregate.
     */
    where?: DeliveryLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryLogs to fetch.
     */
    orderBy?: DeliveryLogOrderByWithRelationInput | DeliveryLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryLogs
    **/
    _count?: true | DeliveryLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryLogMaxAggregateInputType
  }

  export type GetDeliveryLogAggregateType<T extends DeliveryLogAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryLog[P]>
      : GetScalarType<T[P], AggregateDeliveryLog[P]>
  }




  export type DeliveryLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryLogWhereInput
    orderBy?: DeliveryLogOrderByWithAggregationInput | DeliveryLogOrderByWithAggregationInput[]
    by: DeliveryLogScalarFieldEnum[] | DeliveryLogScalarFieldEnum
    having?: DeliveryLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryLogCountAggregateInputType | true
    _min?: DeliveryLogMinAggregateInputType
    _max?: DeliveryLogMaxAggregateInputType
  }

  export type DeliveryLogGroupByOutputType = {
    id: string
    deliveryId: string
    eventType: string
    oldValue: JsonValue | null
    newValue: JsonValue | null
    createdByUserId: string | null
    role: $Enums.DeliveryRole
    createdAt: Date
    _count: DeliveryLogCountAggregateOutputType | null
    _min: DeliveryLogMinAggregateOutputType | null
    _max: DeliveryLogMaxAggregateOutputType | null
  }

  type GetDeliveryLogGroupByPayload<T extends DeliveryLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryLogGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryLogGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deliveryId?: boolean
    eventType?: boolean
    oldValue?: boolean
    newValue?: boolean
    createdByUserId?: boolean
    role?: boolean
    createdAt?: boolean
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    createdByUser?: boolean | DeliveryLog$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryLog"]>

  export type DeliveryLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deliveryId?: boolean
    eventType?: boolean
    oldValue?: boolean
    newValue?: boolean
    createdByUserId?: boolean
    role?: boolean
    createdAt?: boolean
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    createdByUser?: boolean | DeliveryLog$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryLog"]>

  export type DeliveryLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deliveryId?: boolean
    eventType?: boolean
    oldValue?: boolean
    newValue?: boolean
    createdByUserId?: boolean
    role?: boolean
    createdAt?: boolean
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    createdByUser?: boolean | DeliveryLog$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryLog"]>

  export type DeliveryLogSelectScalar = {
    id?: boolean
    deliveryId?: boolean
    eventType?: boolean
    oldValue?: boolean
    newValue?: boolean
    createdByUserId?: boolean
    role?: boolean
    createdAt?: boolean
  }

  export type DeliveryLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deliveryId" | "eventType" | "oldValue" | "newValue" | "createdByUserId" | "role" | "createdAt", ExtArgs["result"]["deliveryLog"]>
  export type DeliveryLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    createdByUser?: boolean | DeliveryLog$createdByUserArgs<ExtArgs>
  }
  export type DeliveryLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    createdByUser?: boolean | DeliveryLog$createdByUserArgs<ExtArgs>
  }
  export type DeliveryLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    createdByUser?: boolean | DeliveryLog$createdByUserArgs<ExtArgs>
  }

  export type $DeliveryLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryLog"
    objects: {
      delivery: Prisma.$DeliveryPayload<ExtArgs>
      createdByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deliveryId: string
      eventType: string
      oldValue: Prisma.JsonValue | null
      newValue: Prisma.JsonValue | null
      createdByUserId: string | null
      role: $Enums.DeliveryRole
      createdAt: Date
    }, ExtArgs["result"]["deliveryLog"]>
    composites: {}
  }

  type DeliveryLogGetPayload<S extends boolean | null | undefined | DeliveryLogDefaultArgs> = $Result.GetResult<Prisma.$DeliveryLogPayload, S>

  type DeliveryLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryLogCountAggregateInputType | true
    }

  export interface DeliveryLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryLog'], meta: { name: 'DeliveryLog' } }
    /**
     * Find zero or one DeliveryLog that matches the filter.
     * @param {DeliveryLogFindUniqueArgs} args - Arguments to find a DeliveryLog
     * @example
     * // Get one DeliveryLog
     * const deliveryLog = await prisma.deliveryLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryLogFindUniqueArgs>(args: SelectSubset<T, DeliveryLogFindUniqueArgs<ExtArgs>>): Prisma__DeliveryLogClient<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryLogFindUniqueOrThrowArgs} args - Arguments to find a DeliveryLog
     * @example
     * // Get one DeliveryLog
     * const deliveryLog = await prisma.deliveryLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryLogFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryLogClient<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLogFindFirstArgs} args - Arguments to find a DeliveryLog
     * @example
     * // Get one DeliveryLog
     * const deliveryLog = await prisma.deliveryLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryLogFindFirstArgs>(args?: SelectSubset<T, DeliveryLogFindFirstArgs<ExtArgs>>): Prisma__DeliveryLogClient<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLogFindFirstOrThrowArgs} args - Arguments to find a DeliveryLog
     * @example
     * // Get one DeliveryLog
     * const deliveryLog = await prisma.deliveryLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryLogFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryLogClient<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryLogs
     * const deliveryLogs = await prisma.deliveryLog.findMany()
     * 
     * // Get first 10 DeliveryLogs
     * const deliveryLogs = await prisma.deliveryLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryLogWithIdOnly = await prisma.deliveryLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryLogFindManyArgs>(args?: SelectSubset<T, DeliveryLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryLog.
     * @param {DeliveryLogCreateArgs} args - Arguments to create a DeliveryLog.
     * @example
     * // Create one DeliveryLog
     * const DeliveryLog = await prisma.deliveryLog.create({
     *   data: {
     *     // ... data to create a DeliveryLog
     *   }
     * })
     * 
     */
    create<T extends DeliveryLogCreateArgs>(args: SelectSubset<T, DeliveryLogCreateArgs<ExtArgs>>): Prisma__DeliveryLogClient<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryLogs.
     * @param {DeliveryLogCreateManyArgs} args - Arguments to create many DeliveryLogs.
     * @example
     * // Create many DeliveryLogs
     * const deliveryLog = await prisma.deliveryLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryLogCreateManyArgs>(args?: SelectSubset<T, DeliveryLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryLogs and returns the data saved in the database.
     * @param {DeliveryLogCreateManyAndReturnArgs} args - Arguments to create many DeliveryLogs.
     * @example
     * // Create many DeliveryLogs
     * const deliveryLog = await prisma.deliveryLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryLogs and only return the `id`
     * const deliveryLogWithIdOnly = await prisma.deliveryLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryLogCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryLog.
     * @param {DeliveryLogDeleteArgs} args - Arguments to delete one DeliveryLog.
     * @example
     * // Delete one DeliveryLog
     * const DeliveryLog = await prisma.deliveryLog.delete({
     *   where: {
     *     // ... filter to delete one DeliveryLog
     *   }
     * })
     * 
     */
    delete<T extends DeliveryLogDeleteArgs>(args: SelectSubset<T, DeliveryLogDeleteArgs<ExtArgs>>): Prisma__DeliveryLogClient<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryLog.
     * @param {DeliveryLogUpdateArgs} args - Arguments to update one DeliveryLog.
     * @example
     * // Update one DeliveryLog
     * const deliveryLog = await prisma.deliveryLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryLogUpdateArgs>(args: SelectSubset<T, DeliveryLogUpdateArgs<ExtArgs>>): Prisma__DeliveryLogClient<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryLogs.
     * @param {DeliveryLogDeleteManyArgs} args - Arguments to filter DeliveryLogs to delete.
     * @example
     * // Delete a few DeliveryLogs
     * const { count } = await prisma.deliveryLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryLogDeleteManyArgs>(args?: SelectSubset<T, DeliveryLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryLogs
     * const deliveryLog = await prisma.deliveryLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryLogUpdateManyArgs>(args: SelectSubset<T, DeliveryLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryLogs and returns the data updated in the database.
     * @param {DeliveryLogUpdateManyAndReturnArgs} args - Arguments to update many DeliveryLogs.
     * @example
     * // Update many DeliveryLogs
     * const deliveryLog = await prisma.deliveryLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryLogs and only return the `id`
     * const deliveryLogWithIdOnly = await prisma.deliveryLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryLogUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryLog.
     * @param {DeliveryLogUpsertArgs} args - Arguments to update or create a DeliveryLog.
     * @example
     * // Update or create a DeliveryLog
     * const deliveryLog = await prisma.deliveryLog.upsert({
     *   create: {
     *     // ... data to create a DeliveryLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryLog we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryLogUpsertArgs>(args: SelectSubset<T, DeliveryLogUpsertArgs<ExtArgs>>): Prisma__DeliveryLogClient<$Result.GetResult<Prisma.$DeliveryLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLogCountArgs} args - Arguments to filter DeliveryLogs to count.
     * @example
     * // Count the number of DeliveryLogs
     * const count = await prisma.deliveryLog.count({
     *   where: {
     *     // ... the filter for the DeliveryLogs we want to count
     *   }
     * })
    **/
    count<T extends DeliveryLogCountArgs>(
      args?: Subset<T, DeliveryLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryLogAggregateArgs>(args: Subset<T, DeliveryLogAggregateArgs>): Prisma.PrismaPromise<GetDeliveryLogAggregateType<T>>

    /**
     * Group by DeliveryLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryLogGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryLog model
   */
  readonly fields: DeliveryLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    delivery<T extends DeliveryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryDefaultArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdByUser<T extends DeliveryLog$createdByUserArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryLog$createdByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryLog model
   */
  interface DeliveryLogFieldRefs {
    readonly id: FieldRef<"DeliveryLog", 'String'>
    readonly deliveryId: FieldRef<"DeliveryLog", 'String'>
    readonly eventType: FieldRef<"DeliveryLog", 'String'>
    readonly oldValue: FieldRef<"DeliveryLog", 'Json'>
    readonly newValue: FieldRef<"DeliveryLog", 'Json'>
    readonly createdByUserId: FieldRef<"DeliveryLog", 'String'>
    readonly role: FieldRef<"DeliveryLog", 'DeliveryRole'>
    readonly createdAt: FieldRef<"DeliveryLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryLog findUnique
   */
  export type DeliveryLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryLog to fetch.
     */
    where: DeliveryLogWhereUniqueInput
  }

  /**
   * DeliveryLog findUniqueOrThrow
   */
  export type DeliveryLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryLog to fetch.
     */
    where: DeliveryLogWhereUniqueInput
  }

  /**
   * DeliveryLog findFirst
   */
  export type DeliveryLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryLog to fetch.
     */
    where?: DeliveryLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryLogs to fetch.
     */
    orderBy?: DeliveryLogOrderByWithRelationInput | DeliveryLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryLogs.
     */
    cursor?: DeliveryLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryLogs.
     */
    distinct?: DeliveryLogScalarFieldEnum | DeliveryLogScalarFieldEnum[]
  }

  /**
   * DeliveryLog findFirstOrThrow
   */
  export type DeliveryLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryLog to fetch.
     */
    where?: DeliveryLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryLogs to fetch.
     */
    orderBy?: DeliveryLogOrderByWithRelationInput | DeliveryLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryLogs.
     */
    cursor?: DeliveryLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryLogs.
     */
    distinct?: DeliveryLogScalarFieldEnum | DeliveryLogScalarFieldEnum[]
  }

  /**
   * DeliveryLog findMany
   */
  export type DeliveryLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryLogs to fetch.
     */
    where?: DeliveryLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryLogs to fetch.
     */
    orderBy?: DeliveryLogOrderByWithRelationInput | DeliveryLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryLogs.
     */
    cursor?: DeliveryLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryLogs.
     */
    skip?: number
    distinct?: DeliveryLogScalarFieldEnum | DeliveryLogScalarFieldEnum[]
  }

  /**
   * DeliveryLog create
   */
  export type DeliveryLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryLog.
     */
    data: XOR<DeliveryLogCreateInput, DeliveryLogUncheckedCreateInput>
  }

  /**
   * DeliveryLog createMany
   */
  export type DeliveryLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryLogs.
     */
    data: DeliveryLogCreateManyInput | DeliveryLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryLog createManyAndReturn
   */
  export type DeliveryLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryLogs.
     */
    data: DeliveryLogCreateManyInput | DeliveryLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryLog update
   */
  export type DeliveryLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryLog.
     */
    data: XOR<DeliveryLogUpdateInput, DeliveryLogUncheckedUpdateInput>
    /**
     * Choose, which DeliveryLog to update.
     */
    where: DeliveryLogWhereUniqueInput
  }

  /**
   * DeliveryLog updateMany
   */
  export type DeliveryLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryLogs.
     */
    data: XOR<DeliveryLogUpdateManyMutationInput, DeliveryLogUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryLogs to update
     */
    where?: DeliveryLogWhereInput
    /**
     * Limit how many DeliveryLogs to update.
     */
    limit?: number
  }

  /**
   * DeliveryLog updateManyAndReturn
   */
  export type DeliveryLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryLogs.
     */
    data: XOR<DeliveryLogUpdateManyMutationInput, DeliveryLogUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryLogs to update
     */
    where?: DeliveryLogWhereInput
    /**
     * Limit how many DeliveryLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryLog upsert
   */
  export type DeliveryLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryLog to update in case it exists.
     */
    where: DeliveryLogWhereUniqueInput
    /**
     * In case the DeliveryLog found by the `where` argument doesn't exist, create a new DeliveryLog with this data.
     */
    create: XOR<DeliveryLogCreateInput, DeliveryLogUncheckedCreateInput>
    /**
     * In case the DeliveryLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryLogUpdateInput, DeliveryLogUncheckedUpdateInput>
  }

  /**
   * DeliveryLog delete
   */
  export type DeliveryLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogInclude<ExtArgs> | null
    /**
     * Filter which DeliveryLog to delete.
     */
    where: DeliveryLogWhereUniqueInput
  }

  /**
   * DeliveryLog deleteMany
   */
  export type DeliveryLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryLogs to delete
     */
    where?: DeliveryLogWhereInput
    /**
     * Limit how many DeliveryLogs to delete.
     */
    limit?: number
  }

  /**
   * DeliveryLog.createdByUser
   */
  export type DeliveryLog$createdByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * DeliveryLog without action
   */
  export type DeliveryLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryLog
     */
    select?: DeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryLog
     */
    omit?: DeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryLogInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryEditLog
   */

  export type AggregateDeliveryEditLog = {
    _count: DeliveryEditLogCountAggregateOutputType | null
    _min: DeliveryEditLogMinAggregateOutputType | null
    _max: DeliveryEditLogMaxAggregateOutputType | null
  }

  export type DeliveryEditLogMinAggregateOutputType = {
    id: string | null
    deliveryId: string | null
    editedByUserId: string | null
    role: $Enums.DeliveryRole | null
    fieldChanged: string | null
    oldValue: string | null
    newValue: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type DeliveryEditLogMaxAggregateOutputType = {
    id: string | null
    deliveryId: string | null
    editedByUserId: string | null
    role: $Enums.DeliveryRole | null
    fieldChanged: string | null
    oldValue: string | null
    newValue: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type DeliveryEditLogCountAggregateOutputType = {
    id: number
    deliveryId: number
    editedByUserId: number
    role: number
    fieldChanged: number
    oldValue: number
    newValue: number
    reason: number
    createdAt: number
    _all: number
  }


  export type DeliveryEditLogMinAggregateInputType = {
    id?: true
    deliveryId?: true
    editedByUserId?: true
    role?: true
    fieldChanged?: true
    oldValue?: true
    newValue?: true
    reason?: true
    createdAt?: true
  }

  export type DeliveryEditLogMaxAggregateInputType = {
    id?: true
    deliveryId?: true
    editedByUserId?: true
    role?: true
    fieldChanged?: true
    oldValue?: true
    newValue?: true
    reason?: true
    createdAt?: true
  }

  export type DeliveryEditLogCountAggregateInputType = {
    id?: true
    deliveryId?: true
    editedByUserId?: true
    role?: true
    fieldChanged?: true
    oldValue?: true
    newValue?: true
    reason?: true
    createdAt?: true
    _all?: true
  }

  export type DeliveryEditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryEditLog to aggregate.
     */
    where?: DeliveryEditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryEditLogs to fetch.
     */
    orderBy?: DeliveryEditLogOrderByWithRelationInput | DeliveryEditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryEditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryEditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryEditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryEditLogs
    **/
    _count?: true | DeliveryEditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryEditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryEditLogMaxAggregateInputType
  }

  export type GetDeliveryEditLogAggregateType<T extends DeliveryEditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryEditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryEditLog[P]>
      : GetScalarType<T[P], AggregateDeliveryEditLog[P]>
  }




  export type DeliveryEditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryEditLogWhereInput
    orderBy?: DeliveryEditLogOrderByWithAggregationInput | DeliveryEditLogOrderByWithAggregationInput[]
    by: DeliveryEditLogScalarFieldEnum[] | DeliveryEditLogScalarFieldEnum
    having?: DeliveryEditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryEditLogCountAggregateInputType | true
    _min?: DeliveryEditLogMinAggregateInputType
    _max?: DeliveryEditLogMaxAggregateInputType
  }

  export type DeliveryEditLogGroupByOutputType = {
    id: string
    deliveryId: string
    editedByUserId: string
    role: $Enums.DeliveryRole
    fieldChanged: string
    oldValue: string | null
    newValue: string | null
    reason: string | null
    createdAt: Date
    _count: DeliveryEditLogCountAggregateOutputType | null
    _min: DeliveryEditLogMinAggregateOutputType | null
    _max: DeliveryEditLogMaxAggregateOutputType | null
  }

  type GetDeliveryEditLogGroupByPayload<T extends DeliveryEditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryEditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryEditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryEditLogGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryEditLogGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryEditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deliveryId?: boolean
    editedByUserId?: boolean
    role?: boolean
    fieldChanged?: boolean
    oldValue?: boolean
    newValue?: boolean
    reason?: boolean
    createdAt?: boolean
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    editedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryEditLog"]>

  export type DeliveryEditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deliveryId?: boolean
    editedByUserId?: boolean
    role?: boolean
    fieldChanged?: boolean
    oldValue?: boolean
    newValue?: boolean
    reason?: boolean
    createdAt?: boolean
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    editedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryEditLog"]>

  export type DeliveryEditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deliveryId?: boolean
    editedByUserId?: boolean
    role?: boolean
    fieldChanged?: boolean
    oldValue?: boolean
    newValue?: boolean
    reason?: boolean
    createdAt?: boolean
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    editedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryEditLog"]>

  export type DeliveryEditLogSelectScalar = {
    id?: boolean
    deliveryId?: boolean
    editedByUserId?: boolean
    role?: boolean
    fieldChanged?: boolean
    oldValue?: boolean
    newValue?: boolean
    reason?: boolean
    createdAt?: boolean
  }

  export type DeliveryEditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deliveryId" | "editedByUserId" | "role" | "fieldChanged" | "oldValue" | "newValue" | "reason" | "createdAt", ExtArgs["result"]["deliveryEditLog"]>
  export type DeliveryEditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    editedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeliveryEditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    editedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeliveryEditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delivery?: boolean | DeliveryDefaultArgs<ExtArgs>
    editedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DeliveryEditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryEditLog"
    objects: {
      delivery: Prisma.$DeliveryPayload<ExtArgs>
      editedByUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deliveryId: string
      editedByUserId: string
      role: $Enums.DeliveryRole
      fieldChanged: string
      oldValue: string | null
      newValue: string | null
      reason: string | null
      createdAt: Date
    }, ExtArgs["result"]["deliveryEditLog"]>
    composites: {}
  }

  type DeliveryEditLogGetPayload<S extends boolean | null | undefined | DeliveryEditLogDefaultArgs> = $Result.GetResult<Prisma.$DeliveryEditLogPayload, S>

  type DeliveryEditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryEditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryEditLogCountAggregateInputType | true
    }

  export interface DeliveryEditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryEditLog'], meta: { name: 'DeliveryEditLog' } }
    /**
     * Find zero or one DeliveryEditLog that matches the filter.
     * @param {DeliveryEditLogFindUniqueArgs} args - Arguments to find a DeliveryEditLog
     * @example
     * // Get one DeliveryEditLog
     * const deliveryEditLog = await prisma.deliveryEditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryEditLogFindUniqueArgs>(args: SelectSubset<T, DeliveryEditLogFindUniqueArgs<ExtArgs>>): Prisma__DeliveryEditLogClient<$Result.GetResult<Prisma.$DeliveryEditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryEditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryEditLogFindUniqueOrThrowArgs} args - Arguments to find a DeliveryEditLog
     * @example
     * // Get one DeliveryEditLog
     * const deliveryEditLog = await prisma.deliveryEditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryEditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryEditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryEditLogClient<$Result.GetResult<Prisma.$DeliveryEditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryEditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEditLogFindFirstArgs} args - Arguments to find a DeliveryEditLog
     * @example
     * // Get one DeliveryEditLog
     * const deliveryEditLog = await prisma.deliveryEditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryEditLogFindFirstArgs>(args?: SelectSubset<T, DeliveryEditLogFindFirstArgs<ExtArgs>>): Prisma__DeliveryEditLogClient<$Result.GetResult<Prisma.$DeliveryEditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryEditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEditLogFindFirstOrThrowArgs} args - Arguments to find a DeliveryEditLog
     * @example
     * // Get one DeliveryEditLog
     * const deliveryEditLog = await prisma.deliveryEditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryEditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryEditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryEditLogClient<$Result.GetResult<Prisma.$DeliveryEditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryEditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryEditLogs
     * const deliveryEditLogs = await prisma.deliveryEditLog.findMany()
     * 
     * // Get first 10 DeliveryEditLogs
     * const deliveryEditLogs = await prisma.deliveryEditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryEditLogWithIdOnly = await prisma.deliveryEditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryEditLogFindManyArgs>(args?: SelectSubset<T, DeliveryEditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryEditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryEditLog.
     * @param {DeliveryEditLogCreateArgs} args - Arguments to create a DeliveryEditLog.
     * @example
     * // Create one DeliveryEditLog
     * const DeliveryEditLog = await prisma.deliveryEditLog.create({
     *   data: {
     *     // ... data to create a DeliveryEditLog
     *   }
     * })
     * 
     */
    create<T extends DeliveryEditLogCreateArgs>(args: SelectSubset<T, DeliveryEditLogCreateArgs<ExtArgs>>): Prisma__DeliveryEditLogClient<$Result.GetResult<Prisma.$DeliveryEditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryEditLogs.
     * @param {DeliveryEditLogCreateManyArgs} args - Arguments to create many DeliveryEditLogs.
     * @example
     * // Create many DeliveryEditLogs
     * const deliveryEditLog = await prisma.deliveryEditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryEditLogCreateManyArgs>(args?: SelectSubset<T, DeliveryEditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryEditLogs and returns the data saved in the database.
     * @param {DeliveryEditLogCreateManyAndReturnArgs} args - Arguments to create many DeliveryEditLogs.
     * @example
     * // Create many DeliveryEditLogs
     * const deliveryEditLog = await prisma.deliveryEditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryEditLogs and only return the `id`
     * const deliveryEditLogWithIdOnly = await prisma.deliveryEditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryEditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryEditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryEditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryEditLog.
     * @param {DeliveryEditLogDeleteArgs} args - Arguments to delete one DeliveryEditLog.
     * @example
     * // Delete one DeliveryEditLog
     * const DeliveryEditLog = await prisma.deliveryEditLog.delete({
     *   where: {
     *     // ... filter to delete one DeliveryEditLog
     *   }
     * })
     * 
     */
    delete<T extends DeliveryEditLogDeleteArgs>(args: SelectSubset<T, DeliveryEditLogDeleteArgs<ExtArgs>>): Prisma__DeliveryEditLogClient<$Result.GetResult<Prisma.$DeliveryEditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryEditLog.
     * @param {DeliveryEditLogUpdateArgs} args - Arguments to update one DeliveryEditLog.
     * @example
     * // Update one DeliveryEditLog
     * const deliveryEditLog = await prisma.deliveryEditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryEditLogUpdateArgs>(args: SelectSubset<T, DeliveryEditLogUpdateArgs<ExtArgs>>): Prisma__DeliveryEditLogClient<$Result.GetResult<Prisma.$DeliveryEditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryEditLogs.
     * @param {DeliveryEditLogDeleteManyArgs} args - Arguments to filter DeliveryEditLogs to delete.
     * @example
     * // Delete a few DeliveryEditLogs
     * const { count } = await prisma.deliveryEditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryEditLogDeleteManyArgs>(args?: SelectSubset<T, DeliveryEditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryEditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryEditLogs
     * const deliveryEditLog = await prisma.deliveryEditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryEditLogUpdateManyArgs>(args: SelectSubset<T, DeliveryEditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryEditLogs and returns the data updated in the database.
     * @param {DeliveryEditLogUpdateManyAndReturnArgs} args - Arguments to update many DeliveryEditLogs.
     * @example
     * // Update many DeliveryEditLogs
     * const deliveryEditLog = await prisma.deliveryEditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryEditLogs and only return the `id`
     * const deliveryEditLogWithIdOnly = await prisma.deliveryEditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryEditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryEditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryEditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryEditLog.
     * @param {DeliveryEditLogUpsertArgs} args - Arguments to update or create a DeliveryEditLog.
     * @example
     * // Update or create a DeliveryEditLog
     * const deliveryEditLog = await prisma.deliveryEditLog.upsert({
     *   create: {
     *     // ... data to create a DeliveryEditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryEditLog we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryEditLogUpsertArgs>(args: SelectSubset<T, DeliveryEditLogUpsertArgs<ExtArgs>>): Prisma__DeliveryEditLogClient<$Result.GetResult<Prisma.$DeliveryEditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryEditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEditLogCountArgs} args - Arguments to filter DeliveryEditLogs to count.
     * @example
     * // Count the number of DeliveryEditLogs
     * const count = await prisma.deliveryEditLog.count({
     *   where: {
     *     // ... the filter for the DeliveryEditLogs we want to count
     *   }
     * })
    **/
    count<T extends DeliveryEditLogCountArgs>(
      args?: Subset<T, DeliveryEditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryEditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryEditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryEditLogAggregateArgs>(args: Subset<T, DeliveryEditLogAggregateArgs>): Prisma.PrismaPromise<GetDeliveryEditLogAggregateType<T>>

    /**
     * Group by DeliveryEditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryEditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryEditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryEditLogGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryEditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryEditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryEditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryEditLog model
   */
  readonly fields: DeliveryEditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryEditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryEditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    delivery<T extends DeliveryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryDefaultArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    editedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryEditLog model
   */
  interface DeliveryEditLogFieldRefs {
    readonly id: FieldRef<"DeliveryEditLog", 'String'>
    readonly deliveryId: FieldRef<"DeliveryEditLog", 'String'>
    readonly editedByUserId: FieldRef<"DeliveryEditLog", 'String'>
    readonly role: FieldRef<"DeliveryEditLog", 'DeliveryRole'>
    readonly fieldChanged: FieldRef<"DeliveryEditLog", 'String'>
    readonly oldValue: FieldRef<"DeliveryEditLog", 'String'>
    readonly newValue: FieldRef<"DeliveryEditLog", 'String'>
    readonly reason: FieldRef<"DeliveryEditLog", 'String'>
    readonly createdAt: FieldRef<"DeliveryEditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryEditLog findUnique
   */
  export type DeliveryEditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEditLog
     */
    select?: DeliveryEditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEditLog
     */
    omit?: DeliveryEditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEditLogInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryEditLog to fetch.
     */
    where: DeliveryEditLogWhereUniqueInput
  }

  /**
   * DeliveryEditLog findUniqueOrThrow
   */
  export type DeliveryEditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEditLog
     */
    select?: DeliveryEditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEditLog
     */
    omit?: DeliveryEditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEditLogInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryEditLog to fetch.
     */
    where: DeliveryEditLogWhereUniqueInput
  }

  /**
   * DeliveryEditLog findFirst
   */
  export type DeliveryEditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEditLog
     */
    select?: DeliveryEditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEditLog
     */
    omit?: DeliveryEditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEditLogInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryEditLog to fetch.
     */
    where?: DeliveryEditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryEditLogs to fetch.
     */
    orderBy?: DeliveryEditLogOrderByWithRelationInput | DeliveryEditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryEditLogs.
     */
    cursor?: DeliveryEditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryEditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryEditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryEditLogs.
     */
    distinct?: DeliveryEditLogScalarFieldEnum | DeliveryEditLogScalarFieldEnum[]
  }

  /**
   * DeliveryEditLog findFirstOrThrow
   */
  export type DeliveryEditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEditLog
     */
    select?: DeliveryEditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEditLog
     */
    omit?: DeliveryEditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEditLogInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryEditLog to fetch.
     */
    where?: DeliveryEditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryEditLogs to fetch.
     */
    orderBy?: DeliveryEditLogOrderByWithRelationInput | DeliveryEditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryEditLogs.
     */
    cursor?: DeliveryEditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryEditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryEditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryEditLogs.
     */
    distinct?: DeliveryEditLogScalarFieldEnum | DeliveryEditLogScalarFieldEnum[]
  }

  /**
   * DeliveryEditLog findMany
   */
  export type DeliveryEditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEditLog
     */
    select?: DeliveryEditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEditLog
     */
    omit?: DeliveryEditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEditLogInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryEditLogs to fetch.
     */
    where?: DeliveryEditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryEditLogs to fetch.
     */
    orderBy?: DeliveryEditLogOrderByWithRelationInput | DeliveryEditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryEditLogs.
     */
    cursor?: DeliveryEditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryEditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryEditLogs.
     */
    skip?: number
    distinct?: DeliveryEditLogScalarFieldEnum | DeliveryEditLogScalarFieldEnum[]
  }

  /**
   * DeliveryEditLog create
   */
  export type DeliveryEditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEditLog
     */
    select?: DeliveryEditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEditLog
     */
    omit?: DeliveryEditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryEditLog.
     */
    data: XOR<DeliveryEditLogCreateInput, DeliveryEditLogUncheckedCreateInput>
  }

  /**
   * DeliveryEditLog createMany
   */
  export type DeliveryEditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryEditLogs.
     */
    data: DeliveryEditLogCreateManyInput | DeliveryEditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryEditLog createManyAndReturn
   */
  export type DeliveryEditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEditLog
     */
    select?: DeliveryEditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEditLog
     */
    omit?: DeliveryEditLogOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryEditLogs.
     */
    data: DeliveryEditLogCreateManyInput | DeliveryEditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryEditLog update
   */
  export type DeliveryEditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEditLog
     */
    select?: DeliveryEditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEditLog
     */
    omit?: DeliveryEditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryEditLog.
     */
    data: XOR<DeliveryEditLogUpdateInput, DeliveryEditLogUncheckedUpdateInput>
    /**
     * Choose, which DeliveryEditLog to update.
     */
    where: DeliveryEditLogWhereUniqueInput
  }

  /**
   * DeliveryEditLog updateMany
   */
  export type DeliveryEditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryEditLogs.
     */
    data: XOR<DeliveryEditLogUpdateManyMutationInput, DeliveryEditLogUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryEditLogs to update
     */
    where?: DeliveryEditLogWhereInput
    /**
     * Limit how many DeliveryEditLogs to update.
     */
    limit?: number
  }

  /**
   * DeliveryEditLog updateManyAndReturn
   */
  export type DeliveryEditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEditLog
     */
    select?: DeliveryEditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEditLog
     */
    omit?: DeliveryEditLogOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryEditLogs.
     */
    data: XOR<DeliveryEditLogUpdateManyMutationInput, DeliveryEditLogUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryEditLogs to update
     */
    where?: DeliveryEditLogWhereInput
    /**
     * Limit how many DeliveryEditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryEditLog upsert
   */
  export type DeliveryEditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEditLog
     */
    select?: DeliveryEditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEditLog
     */
    omit?: DeliveryEditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryEditLog to update in case it exists.
     */
    where: DeliveryEditLogWhereUniqueInput
    /**
     * In case the DeliveryEditLog found by the `where` argument doesn't exist, create a new DeliveryEditLog with this data.
     */
    create: XOR<DeliveryEditLogCreateInput, DeliveryEditLogUncheckedCreateInput>
    /**
     * In case the DeliveryEditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryEditLogUpdateInput, DeliveryEditLogUncheckedUpdateInput>
  }

  /**
   * DeliveryEditLog delete
   */
  export type DeliveryEditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEditLog
     */
    select?: DeliveryEditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEditLog
     */
    omit?: DeliveryEditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEditLogInclude<ExtArgs> | null
    /**
     * Filter which DeliveryEditLog to delete.
     */
    where: DeliveryEditLogWhereUniqueInput
  }

  /**
   * DeliveryEditLog deleteMany
   */
  export type DeliveryEditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryEditLogs to delete
     */
    where?: DeliveryEditLogWhereInput
    /**
     * Limit how many DeliveryEditLogs to delete.
     */
    limit?: number
  }

  /**
   * DeliveryEditLog without action
   */
  export type DeliveryEditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryEditLog
     */
    select?: DeliveryEditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryEditLog
     */
    omit?: DeliveryEditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryEditLogInclude<ExtArgs> | null
  }


  /**
   * Model SpecialOffer
   */

  export type AggregateSpecialOffer = {
    _count: SpecialOfferCountAggregateOutputType | null
    _avg: SpecialOfferAvgAggregateOutputType | null
    _sum: SpecialOfferSumAggregateOutputType | null
    _min: SpecialOfferMinAggregateOutputType | null
    _max: SpecialOfferMaxAggregateOutputType | null
  }

  export type SpecialOfferAvgAggregateOutputType = {
    discountPercentage: number | null
    originalPrice: Decimal | null
    finalPrice: Decimal | null
  }

  export type SpecialOfferSumAggregateOutputType = {
    discountPercentage: number | null
    originalPrice: Decimal | null
    finalPrice: Decimal | null
  }

  export type SpecialOfferMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    badgeText: string | null
    discountPercentage: number | null
    originalPrice: Decimal | null
    finalPrice: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type SpecialOfferMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    badgeText: string | null
    discountPercentage: number | null
    originalPrice: Decimal | null
    finalPrice: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type SpecialOfferCountAggregateOutputType = {
    id: number
    title: number
    description: number
    badgeText: number
    discountPercentage: number
    originalPrice: number
    finalPrice: number
    images: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type SpecialOfferAvgAggregateInputType = {
    discountPercentage?: true
    originalPrice?: true
    finalPrice?: true
  }

  export type SpecialOfferSumAggregateInputType = {
    discountPercentage?: true
    originalPrice?: true
    finalPrice?: true
  }

  export type SpecialOfferMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    badgeText?: true
    discountPercentage?: true
    originalPrice?: true
    finalPrice?: true
    isActive?: true
    createdAt?: true
  }

  export type SpecialOfferMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    badgeText?: true
    discountPercentage?: true
    originalPrice?: true
    finalPrice?: true
    isActive?: true
    createdAt?: true
  }

  export type SpecialOfferCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    badgeText?: true
    discountPercentage?: true
    originalPrice?: true
    finalPrice?: true
    images?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type SpecialOfferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpecialOffer to aggregate.
     */
    where?: SpecialOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecialOffers to fetch.
     */
    orderBy?: SpecialOfferOrderByWithRelationInput | SpecialOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpecialOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecialOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecialOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpecialOffers
    **/
    _count?: true | SpecialOfferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpecialOfferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpecialOfferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecialOfferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecialOfferMaxAggregateInputType
  }

  export type GetSpecialOfferAggregateType<T extends SpecialOfferAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecialOffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecialOffer[P]>
      : GetScalarType<T[P], AggregateSpecialOffer[P]>
  }




  export type SpecialOfferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecialOfferWhereInput
    orderBy?: SpecialOfferOrderByWithAggregationInput | SpecialOfferOrderByWithAggregationInput[]
    by: SpecialOfferScalarFieldEnum[] | SpecialOfferScalarFieldEnum
    having?: SpecialOfferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecialOfferCountAggregateInputType | true
    _avg?: SpecialOfferAvgAggregateInputType
    _sum?: SpecialOfferSumAggregateInputType
    _min?: SpecialOfferMinAggregateInputType
    _max?: SpecialOfferMaxAggregateInputType
  }

  export type SpecialOfferGroupByOutputType = {
    id: string
    title: string
    description: string
    badgeText: string | null
    discountPercentage: number
    originalPrice: Decimal
    finalPrice: Decimal
    images: string[]
    isActive: boolean
    createdAt: Date
    _count: SpecialOfferCountAggregateOutputType | null
    _avg: SpecialOfferAvgAggregateOutputType | null
    _sum: SpecialOfferSumAggregateOutputType | null
    _min: SpecialOfferMinAggregateOutputType | null
    _max: SpecialOfferMaxAggregateOutputType | null
  }

  type GetSpecialOfferGroupByPayload<T extends SpecialOfferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpecialOfferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecialOfferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecialOfferGroupByOutputType[P]>
            : GetScalarType<T[P], SpecialOfferGroupByOutputType[P]>
        }
      >
    >


  export type SpecialOfferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    badgeText?: boolean
    discountPercentage?: boolean
    originalPrice?: boolean
    finalPrice?: boolean
    images?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["specialOffer"]>

  export type SpecialOfferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    badgeText?: boolean
    discountPercentage?: boolean
    originalPrice?: boolean
    finalPrice?: boolean
    images?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["specialOffer"]>

  export type SpecialOfferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    badgeText?: boolean
    discountPercentage?: boolean
    originalPrice?: boolean
    finalPrice?: boolean
    images?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["specialOffer"]>

  export type SpecialOfferSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    badgeText?: boolean
    discountPercentage?: boolean
    originalPrice?: boolean
    finalPrice?: boolean
    images?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type SpecialOfferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "badgeText" | "discountPercentage" | "originalPrice" | "finalPrice" | "images" | "isActive" | "createdAt", ExtArgs["result"]["specialOffer"]>

  export type $SpecialOfferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpecialOffer"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      badgeText: string | null
      discountPercentage: number
      originalPrice: Prisma.Decimal
      finalPrice: Prisma.Decimal
      images: string[]
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["specialOffer"]>
    composites: {}
  }

  type SpecialOfferGetPayload<S extends boolean | null | undefined | SpecialOfferDefaultArgs> = $Result.GetResult<Prisma.$SpecialOfferPayload, S>

  type SpecialOfferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpecialOfferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpecialOfferCountAggregateInputType | true
    }

  export interface SpecialOfferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpecialOffer'], meta: { name: 'SpecialOffer' } }
    /**
     * Find zero or one SpecialOffer that matches the filter.
     * @param {SpecialOfferFindUniqueArgs} args - Arguments to find a SpecialOffer
     * @example
     * // Get one SpecialOffer
     * const specialOffer = await prisma.specialOffer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpecialOfferFindUniqueArgs>(args: SelectSubset<T, SpecialOfferFindUniqueArgs<ExtArgs>>): Prisma__SpecialOfferClient<$Result.GetResult<Prisma.$SpecialOfferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpecialOffer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpecialOfferFindUniqueOrThrowArgs} args - Arguments to find a SpecialOffer
     * @example
     * // Get one SpecialOffer
     * const specialOffer = await prisma.specialOffer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpecialOfferFindUniqueOrThrowArgs>(args: SelectSubset<T, SpecialOfferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpecialOfferClient<$Result.GetResult<Prisma.$SpecialOfferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpecialOffer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialOfferFindFirstArgs} args - Arguments to find a SpecialOffer
     * @example
     * // Get one SpecialOffer
     * const specialOffer = await prisma.specialOffer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpecialOfferFindFirstArgs>(args?: SelectSubset<T, SpecialOfferFindFirstArgs<ExtArgs>>): Prisma__SpecialOfferClient<$Result.GetResult<Prisma.$SpecialOfferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpecialOffer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialOfferFindFirstOrThrowArgs} args - Arguments to find a SpecialOffer
     * @example
     * // Get one SpecialOffer
     * const specialOffer = await prisma.specialOffer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpecialOfferFindFirstOrThrowArgs>(args?: SelectSubset<T, SpecialOfferFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpecialOfferClient<$Result.GetResult<Prisma.$SpecialOfferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpecialOffers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialOfferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpecialOffers
     * const specialOffers = await prisma.specialOffer.findMany()
     * 
     * // Get first 10 SpecialOffers
     * const specialOffers = await prisma.specialOffer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const specialOfferWithIdOnly = await prisma.specialOffer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpecialOfferFindManyArgs>(args?: SelectSubset<T, SpecialOfferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpecialOffer.
     * @param {SpecialOfferCreateArgs} args - Arguments to create a SpecialOffer.
     * @example
     * // Create one SpecialOffer
     * const SpecialOffer = await prisma.specialOffer.create({
     *   data: {
     *     // ... data to create a SpecialOffer
     *   }
     * })
     * 
     */
    create<T extends SpecialOfferCreateArgs>(args: SelectSubset<T, SpecialOfferCreateArgs<ExtArgs>>): Prisma__SpecialOfferClient<$Result.GetResult<Prisma.$SpecialOfferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpecialOffers.
     * @param {SpecialOfferCreateManyArgs} args - Arguments to create many SpecialOffers.
     * @example
     * // Create many SpecialOffers
     * const specialOffer = await prisma.specialOffer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpecialOfferCreateManyArgs>(args?: SelectSubset<T, SpecialOfferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpecialOffers and returns the data saved in the database.
     * @param {SpecialOfferCreateManyAndReturnArgs} args - Arguments to create many SpecialOffers.
     * @example
     * // Create many SpecialOffers
     * const specialOffer = await prisma.specialOffer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpecialOffers and only return the `id`
     * const specialOfferWithIdOnly = await prisma.specialOffer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpecialOfferCreateManyAndReturnArgs>(args?: SelectSubset<T, SpecialOfferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialOfferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SpecialOffer.
     * @param {SpecialOfferDeleteArgs} args - Arguments to delete one SpecialOffer.
     * @example
     * // Delete one SpecialOffer
     * const SpecialOffer = await prisma.specialOffer.delete({
     *   where: {
     *     // ... filter to delete one SpecialOffer
     *   }
     * })
     * 
     */
    delete<T extends SpecialOfferDeleteArgs>(args: SelectSubset<T, SpecialOfferDeleteArgs<ExtArgs>>): Prisma__SpecialOfferClient<$Result.GetResult<Prisma.$SpecialOfferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpecialOffer.
     * @param {SpecialOfferUpdateArgs} args - Arguments to update one SpecialOffer.
     * @example
     * // Update one SpecialOffer
     * const specialOffer = await prisma.specialOffer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpecialOfferUpdateArgs>(args: SelectSubset<T, SpecialOfferUpdateArgs<ExtArgs>>): Prisma__SpecialOfferClient<$Result.GetResult<Prisma.$SpecialOfferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpecialOffers.
     * @param {SpecialOfferDeleteManyArgs} args - Arguments to filter SpecialOffers to delete.
     * @example
     * // Delete a few SpecialOffers
     * const { count } = await prisma.specialOffer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpecialOfferDeleteManyArgs>(args?: SelectSubset<T, SpecialOfferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpecialOffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialOfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpecialOffers
     * const specialOffer = await prisma.specialOffer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpecialOfferUpdateManyArgs>(args: SelectSubset<T, SpecialOfferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpecialOffers and returns the data updated in the database.
     * @param {SpecialOfferUpdateManyAndReturnArgs} args - Arguments to update many SpecialOffers.
     * @example
     * // Update many SpecialOffers
     * const specialOffer = await prisma.specialOffer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SpecialOffers and only return the `id`
     * const specialOfferWithIdOnly = await prisma.specialOffer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpecialOfferUpdateManyAndReturnArgs>(args: SelectSubset<T, SpecialOfferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialOfferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SpecialOffer.
     * @param {SpecialOfferUpsertArgs} args - Arguments to update or create a SpecialOffer.
     * @example
     * // Update or create a SpecialOffer
     * const specialOffer = await prisma.specialOffer.upsert({
     *   create: {
     *     // ... data to create a SpecialOffer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpecialOffer we want to update
     *   }
     * })
     */
    upsert<T extends SpecialOfferUpsertArgs>(args: SelectSubset<T, SpecialOfferUpsertArgs<ExtArgs>>): Prisma__SpecialOfferClient<$Result.GetResult<Prisma.$SpecialOfferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpecialOffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialOfferCountArgs} args - Arguments to filter SpecialOffers to count.
     * @example
     * // Count the number of SpecialOffers
     * const count = await prisma.specialOffer.count({
     *   where: {
     *     // ... the filter for the SpecialOffers we want to count
     *   }
     * })
    **/
    count<T extends SpecialOfferCountArgs>(
      args?: Subset<T, SpecialOfferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecialOfferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpecialOffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialOfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecialOfferAggregateArgs>(args: Subset<T, SpecialOfferAggregateArgs>): Prisma.PrismaPromise<GetSpecialOfferAggregateType<T>>

    /**
     * Group by SpecialOffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialOfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpecialOfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpecialOfferGroupByArgs['orderBy'] }
        : { orderBy?: SpecialOfferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpecialOfferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecialOfferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpecialOffer model
   */
  readonly fields: SpecialOfferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpecialOffer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpecialOfferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpecialOffer model
   */
  interface SpecialOfferFieldRefs {
    readonly id: FieldRef<"SpecialOffer", 'String'>
    readonly title: FieldRef<"SpecialOffer", 'String'>
    readonly description: FieldRef<"SpecialOffer", 'String'>
    readonly badgeText: FieldRef<"SpecialOffer", 'String'>
    readonly discountPercentage: FieldRef<"SpecialOffer", 'Int'>
    readonly originalPrice: FieldRef<"SpecialOffer", 'Decimal'>
    readonly finalPrice: FieldRef<"SpecialOffer", 'Decimal'>
    readonly images: FieldRef<"SpecialOffer", 'String[]'>
    readonly isActive: FieldRef<"SpecialOffer", 'Boolean'>
    readonly createdAt: FieldRef<"SpecialOffer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SpecialOffer findUnique
   */
  export type SpecialOfferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOffer
     */
    select?: SpecialOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOffer
     */
    omit?: SpecialOfferOmit<ExtArgs> | null
    /**
     * Filter, which SpecialOffer to fetch.
     */
    where: SpecialOfferWhereUniqueInput
  }

  /**
   * SpecialOffer findUniqueOrThrow
   */
  export type SpecialOfferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOffer
     */
    select?: SpecialOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOffer
     */
    omit?: SpecialOfferOmit<ExtArgs> | null
    /**
     * Filter, which SpecialOffer to fetch.
     */
    where: SpecialOfferWhereUniqueInput
  }

  /**
   * SpecialOffer findFirst
   */
  export type SpecialOfferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOffer
     */
    select?: SpecialOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOffer
     */
    omit?: SpecialOfferOmit<ExtArgs> | null
    /**
     * Filter, which SpecialOffer to fetch.
     */
    where?: SpecialOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecialOffers to fetch.
     */
    orderBy?: SpecialOfferOrderByWithRelationInput | SpecialOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpecialOffers.
     */
    cursor?: SpecialOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecialOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecialOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpecialOffers.
     */
    distinct?: SpecialOfferScalarFieldEnum | SpecialOfferScalarFieldEnum[]
  }

  /**
   * SpecialOffer findFirstOrThrow
   */
  export type SpecialOfferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOffer
     */
    select?: SpecialOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOffer
     */
    omit?: SpecialOfferOmit<ExtArgs> | null
    /**
     * Filter, which SpecialOffer to fetch.
     */
    where?: SpecialOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecialOffers to fetch.
     */
    orderBy?: SpecialOfferOrderByWithRelationInput | SpecialOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpecialOffers.
     */
    cursor?: SpecialOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecialOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecialOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpecialOffers.
     */
    distinct?: SpecialOfferScalarFieldEnum | SpecialOfferScalarFieldEnum[]
  }

  /**
   * SpecialOffer findMany
   */
  export type SpecialOfferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOffer
     */
    select?: SpecialOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOffer
     */
    omit?: SpecialOfferOmit<ExtArgs> | null
    /**
     * Filter, which SpecialOffers to fetch.
     */
    where?: SpecialOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecialOffers to fetch.
     */
    orderBy?: SpecialOfferOrderByWithRelationInput | SpecialOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpecialOffers.
     */
    cursor?: SpecialOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecialOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecialOffers.
     */
    skip?: number
    distinct?: SpecialOfferScalarFieldEnum | SpecialOfferScalarFieldEnum[]
  }

  /**
   * SpecialOffer create
   */
  export type SpecialOfferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOffer
     */
    select?: SpecialOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOffer
     */
    omit?: SpecialOfferOmit<ExtArgs> | null
    /**
     * The data needed to create a SpecialOffer.
     */
    data: XOR<SpecialOfferCreateInput, SpecialOfferUncheckedCreateInput>
  }

  /**
   * SpecialOffer createMany
   */
  export type SpecialOfferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpecialOffers.
     */
    data: SpecialOfferCreateManyInput | SpecialOfferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpecialOffer createManyAndReturn
   */
  export type SpecialOfferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOffer
     */
    select?: SpecialOfferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOffer
     */
    omit?: SpecialOfferOmit<ExtArgs> | null
    /**
     * The data used to create many SpecialOffers.
     */
    data: SpecialOfferCreateManyInput | SpecialOfferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpecialOffer update
   */
  export type SpecialOfferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOffer
     */
    select?: SpecialOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOffer
     */
    omit?: SpecialOfferOmit<ExtArgs> | null
    /**
     * The data needed to update a SpecialOffer.
     */
    data: XOR<SpecialOfferUpdateInput, SpecialOfferUncheckedUpdateInput>
    /**
     * Choose, which SpecialOffer to update.
     */
    where: SpecialOfferWhereUniqueInput
  }

  /**
   * SpecialOffer updateMany
   */
  export type SpecialOfferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpecialOffers.
     */
    data: XOR<SpecialOfferUpdateManyMutationInput, SpecialOfferUncheckedUpdateManyInput>
    /**
     * Filter which SpecialOffers to update
     */
    where?: SpecialOfferWhereInput
    /**
     * Limit how many SpecialOffers to update.
     */
    limit?: number
  }

  /**
   * SpecialOffer updateManyAndReturn
   */
  export type SpecialOfferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOffer
     */
    select?: SpecialOfferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOffer
     */
    omit?: SpecialOfferOmit<ExtArgs> | null
    /**
     * The data used to update SpecialOffers.
     */
    data: XOR<SpecialOfferUpdateManyMutationInput, SpecialOfferUncheckedUpdateManyInput>
    /**
     * Filter which SpecialOffers to update
     */
    where?: SpecialOfferWhereInput
    /**
     * Limit how many SpecialOffers to update.
     */
    limit?: number
  }

  /**
   * SpecialOffer upsert
   */
  export type SpecialOfferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOffer
     */
    select?: SpecialOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOffer
     */
    omit?: SpecialOfferOmit<ExtArgs> | null
    /**
     * The filter to search for the SpecialOffer to update in case it exists.
     */
    where: SpecialOfferWhereUniqueInput
    /**
     * In case the SpecialOffer found by the `where` argument doesn't exist, create a new SpecialOffer with this data.
     */
    create: XOR<SpecialOfferCreateInput, SpecialOfferUncheckedCreateInput>
    /**
     * In case the SpecialOffer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpecialOfferUpdateInput, SpecialOfferUncheckedUpdateInput>
  }

  /**
   * SpecialOffer delete
   */
  export type SpecialOfferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOffer
     */
    select?: SpecialOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOffer
     */
    omit?: SpecialOfferOmit<ExtArgs> | null
    /**
     * Filter which SpecialOffer to delete.
     */
    where: SpecialOfferWhereUniqueInput
  }

  /**
   * SpecialOffer deleteMany
   */
  export type SpecialOfferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpecialOffers to delete
     */
    where?: SpecialOfferWhereInput
    /**
     * Limit how many SpecialOffers to delete.
     */
    limit?: number
  }

  /**
   * SpecialOffer without action
   */
  export type SpecialOfferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialOffer
     */
    select?: SpecialOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpecialOffer
     */
    omit?: SpecialOfferOmit<ExtArgs> | null
  }


  /**
   * Model ContactMessage
   */

  export type AggregateContactMessage = {
    _count: ContactMessageCountAggregateOutputType | null
    _min: ContactMessageMinAggregateOutputType | null
    _max: ContactMessageMaxAggregateOutputType | null
  }

  export type ContactMessageMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    subject: string | null
    message: string | null
    source: string | null
    createdAt: Date | null
  }

  export type ContactMessageMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    subject: string | null
    message: string | null
    source: string | null
    createdAt: Date | null
  }

  export type ContactMessageCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    subject: number
    message: number
    source: number
    createdAt: number
    _all: number
  }


  export type ContactMessageMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    subject?: true
    message?: true
    source?: true
    createdAt?: true
  }

  export type ContactMessageMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    subject?: true
    message?: true
    source?: true
    createdAt?: true
  }

  export type ContactMessageCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    subject?: true
    message?: true
    source?: true
    createdAt?: true
    _all?: true
  }

  export type ContactMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactMessage to aggregate.
     */
    where?: ContactMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactMessages to fetch.
     */
    orderBy?: ContactMessageOrderByWithRelationInput | ContactMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactMessages
    **/
    _count?: true | ContactMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMessageMaxAggregateInputType
  }

  export type GetContactMessageAggregateType<T extends ContactMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateContactMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactMessage[P]>
      : GetScalarType<T[P], AggregateContactMessage[P]>
  }




  export type ContactMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactMessageWhereInput
    orderBy?: ContactMessageOrderByWithAggregationInput | ContactMessageOrderByWithAggregationInput[]
    by: ContactMessageScalarFieldEnum[] | ContactMessageScalarFieldEnum
    having?: ContactMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactMessageCountAggregateInputType | true
    _min?: ContactMessageMinAggregateInputType
    _max?: ContactMessageMaxAggregateInputType
  }

  export type ContactMessageGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string | null
    subject: string | null
    message: string
    source: string
    createdAt: Date
    _count: ContactMessageCountAggregateOutputType | null
    _min: ContactMessageMinAggregateOutputType | null
    _max: ContactMessageMaxAggregateOutputType | null
  }

  type GetContactMessageGroupByPayload<T extends ContactMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ContactMessageGroupByOutputType[P]>
        }
      >
    >


  export type ContactMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    source?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contactMessage"]>

  export type ContactMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    source?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contactMessage"]>

  export type ContactMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    source?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contactMessage"]>

  export type ContactMessageSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    source?: boolean
    createdAt?: boolean
  }

  export type ContactMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "subject" | "message" | "source" | "createdAt", ExtArgs["result"]["contactMessage"]>

  export type $ContactMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactMessage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string | null
      subject: string | null
      message: string
      source: string
      createdAt: Date
    }, ExtArgs["result"]["contactMessage"]>
    composites: {}
  }

  type ContactMessageGetPayload<S extends boolean | null | undefined | ContactMessageDefaultArgs> = $Result.GetResult<Prisma.$ContactMessagePayload, S>

  type ContactMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactMessageCountAggregateInputType | true
    }

  export interface ContactMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactMessage'], meta: { name: 'ContactMessage' } }
    /**
     * Find zero or one ContactMessage that matches the filter.
     * @param {ContactMessageFindUniqueArgs} args - Arguments to find a ContactMessage
     * @example
     * // Get one ContactMessage
     * const contactMessage = await prisma.contactMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactMessageFindUniqueArgs>(args: SelectSubset<T, ContactMessageFindUniqueArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactMessageFindUniqueOrThrowArgs} args - Arguments to find a ContactMessage
     * @example
     * // Get one ContactMessage
     * const contactMessage = await prisma.contactMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageFindFirstArgs} args - Arguments to find a ContactMessage
     * @example
     * // Get one ContactMessage
     * const contactMessage = await prisma.contactMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactMessageFindFirstArgs>(args?: SelectSubset<T, ContactMessageFindFirstArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageFindFirstOrThrowArgs} args - Arguments to find a ContactMessage
     * @example
     * // Get one ContactMessage
     * const contactMessage = await prisma.contactMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactMessages
     * const contactMessages = await prisma.contactMessage.findMany()
     * 
     * // Get first 10 ContactMessages
     * const contactMessages = await prisma.contactMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactMessageWithIdOnly = await prisma.contactMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactMessageFindManyArgs>(args?: SelectSubset<T, ContactMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactMessage.
     * @param {ContactMessageCreateArgs} args - Arguments to create a ContactMessage.
     * @example
     * // Create one ContactMessage
     * const ContactMessage = await prisma.contactMessage.create({
     *   data: {
     *     // ... data to create a ContactMessage
     *   }
     * })
     * 
     */
    create<T extends ContactMessageCreateArgs>(args: SelectSubset<T, ContactMessageCreateArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactMessages.
     * @param {ContactMessageCreateManyArgs} args - Arguments to create many ContactMessages.
     * @example
     * // Create many ContactMessages
     * const contactMessage = await prisma.contactMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactMessageCreateManyArgs>(args?: SelectSubset<T, ContactMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactMessages and returns the data saved in the database.
     * @param {ContactMessageCreateManyAndReturnArgs} args - Arguments to create many ContactMessages.
     * @example
     * // Create many ContactMessages
     * const contactMessage = await prisma.contactMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactMessages and only return the `id`
     * const contactMessageWithIdOnly = await prisma.contactMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactMessage.
     * @param {ContactMessageDeleteArgs} args - Arguments to delete one ContactMessage.
     * @example
     * // Delete one ContactMessage
     * const ContactMessage = await prisma.contactMessage.delete({
     *   where: {
     *     // ... filter to delete one ContactMessage
     *   }
     * })
     * 
     */
    delete<T extends ContactMessageDeleteArgs>(args: SelectSubset<T, ContactMessageDeleteArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactMessage.
     * @param {ContactMessageUpdateArgs} args - Arguments to update one ContactMessage.
     * @example
     * // Update one ContactMessage
     * const contactMessage = await prisma.contactMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactMessageUpdateArgs>(args: SelectSubset<T, ContactMessageUpdateArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactMessages.
     * @param {ContactMessageDeleteManyArgs} args - Arguments to filter ContactMessages to delete.
     * @example
     * // Delete a few ContactMessages
     * const { count } = await prisma.contactMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactMessageDeleteManyArgs>(args?: SelectSubset<T, ContactMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactMessages
     * const contactMessage = await prisma.contactMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactMessageUpdateManyArgs>(args: SelectSubset<T, ContactMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactMessages and returns the data updated in the database.
     * @param {ContactMessageUpdateManyAndReturnArgs} args - Arguments to update many ContactMessages.
     * @example
     * // Update many ContactMessages
     * const contactMessage = await prisma.contactMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactMessages and only return the `id`
     * const contactMessageWithIdOnly = await prisma.contactMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactMessage.
     * @param {ContactMessageUpsertArgs} args - Arguments to update or create a ContactMessage.
     * @example
     * // Update or create a ContactMessage
     * const contactMessage = await prisma.contactMessage.upsert({
     *   create: {
     *     // ... data to create a ContactMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactMessage we want to update
     *   }
     * })
     */
    upsert<T extends ContactMessageUpsertArgs>(args: SelectSubset<T, ContactMessageUpsertArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageCountArgs} args - Arguments to filter ContactMessages to count.
     * @example
     * // Count the number of ContactMessages
     * const count = await prisma.contactMessage.count({
     *   where: {
     *     // ... the filter for the ContactMessages we want to count
     *   }
     * })
    **/
    count<T extends ContactMessageCountArgs>(
      args?: Subset<T, ContactMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactMessageAggregateArgs>(args: Subset<T, ContactMessageAggregateArgs>): Prisma.PrismaPromise<GetContactMessageAggregateType<T>>

    /**
     * Group by ContactMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactMessageGroupByArgs['orderBy'] }
        : { orderBy?: ContactMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactMessage model
   */
  readonly fields: ContactMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactMessage model
   */
  interface ContactMessageFieldRefs {
    readonly id: FieldRef<"ContactMessage", 'String'>
    readonly name: FieldRef<"ContactMessage", 'String'>
    readonly email: FieldRef<"ContactMessage", 'String'>
    readonly phone: FieldRef<"ContactMessage", 'String'>
    readonly subject: FieldRef<"ContactMessage", 'String'>
    readonly message: FieldRef<"ContactMessage", 'String'>
    readonly source: FieldRef<"ContactMessage", 'String'>
    readonly createdAt: FieldRef<"ContactMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactMessage findUnique
   */
  export type ContactMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null
    /**
     * Filter, which ContactMessage to fetch.
     */
    where: ContactMessageWhereUniqueInput
  }

  /**
   * ContactMessage findUniqueOrThrow
   */
  export type ContactMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null
    /**
     * Filter, which ContactMessage to fetch.
     */
    where: ContactMessageWhereUniqueInput
  }

  /**
   * ContactMessage findFirst
   */
  export type ContactMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null
    /**
     * Filter, which ContactMessage to fetch.
     */
    where?: ContactMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactMessages to fetch.
     */
    orderBy?: ContactMessageOrderByWithRelationInput | ContactMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactMessages.
     */
    cursor?: ContactMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactMessages.
     */
    distinct?: ContactMessageScalarFieldEnum | ContactMessageScalarFieldEnum[]
  }

  /**
   * ContactMessage findFirstOrThrow
   */
  export type ContactMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null
    /**
     * Filter, which ContactMessage to fetch.
     */
    where?: ContactMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactMessages to fetch.
     */
    orderBy?: ContactMessageOrderByWithRelationInput | ContactMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactMessages.
     */
    cursor?: ContactMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactMessages.
     */
    distinct?: ContactMessageScalarFieldEnum | ContactMessageScalarFieldEnum[]
  }

  /**
   * ContactMessage findMany
   */
  export type ContactMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null
    /**
     * Filter, which ContactMessages to fetch.
     */
    where?: ContactMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactMessages to fetch.
     */
    orderBy?: ContactMessageOrderByWithRelationInput | ContactMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactMessages.
     */
    cursor?: ContactMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactMessages.
     */
    skip?: number
    distinct?: ContactMessageScalarFieldEnum | ContactMessageScalarFieldEnum[]
  }

  /**
   * ContactMessage create
   */
  export type ContactMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null
    /**
     * The data needed to create a ContactMessage.
     */
    data: XOR<ContactMessageCreateInput, ContactMessageUncheckedCreateInput>
  }

  /**
   * ContactMessage createMany
   */
  export type ContactMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactMessages.
     */
    data: ContactMessageCreateManyInput | ContactMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactMessage createManyAndReturn
   */
  export type ContactMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ContactMessages.
     */
    data: ContactMessageCreateManyInput | ContactMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactMessage update
   */
  export type ContactMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null
    /**
     * The data needed to update a ContactMessage.
     */
    data: XOR<ContactMessageUpdateInput, ContactMessageUncheckedUpdateInput>
    /**
     * Choose, which ContactMessage to update.
     */
    where: ContactMessageWhereUniqueInput
  }

  /**
   * ContactMessage updateMany
   */
  export type ContactMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactMessages.
     */
    data: XOR<ContactMessageUpdateManyMutationInput, ContactMessageUncheckedUpdateManyInput>
    /**
     * Filter which ContactMessages to update
     */
    where?: ContactMessageWhereInput
    /**
     * Limit how many ContactMessages to update.
     */
    limit?: number
  }

  /**
   * ContactMessage updateManyAndReturn
   */
  export type ContactMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null
    /**
     * The data used to update ContactMessages.
     */
    data: XOR<ContactMessageUpdateManyMutationInput, ContactMessageUncheckedUpdateManyInput>
    /**
     * Filter which ContactMessages to update
     */
    where?: ContactMessageWhereInput
    /**
     * Limit how many ContactMessages to update.
     */
    limit?: number
  }

  /**
   * ContactMessage upsert
   */
  export type ContactMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null
    /**
     * The filter to search for the ContactMessage to update in case it exists.
     */
    where: ContactMessageWhereUniqueInput
    /**
     * In case the ContactMessage found by the `where` argument doesn't exist, create a new ContactMessage with this data.
     */
    create: XOR<ContactMessageCreateInput, ContactMessageUncheckedCreateInput>
    /**
     * In case the ContactMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactMessageUpdateInput, ContactMessageUncheckedUpdateInput>
  }

  /**
   * ContactMessage delete
   */
  export type ContactMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null
    /**
     * Filter which ContactMessage to delete.
     */
    where: ContactMessageWhereUniqueInput
  }

  /**
   * ContactMessage deleteMany
   */
  export type ContactMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactMessages to delete
     */
    where?: ContactMessageWhereInput
    /**
     * Limit how many ContactMessages to delete.
     */
    limit?: number
  }

  /**
   * ContactMessage without action
   */
  export type ContactMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    invoiceNumber: 'invoiceNumber',
    orderId: 'orderId',
    subtotal: 'subtotal',
    tax: 'tax',
    deliveryFee: 'deliveryFee',
    total: 'total',
    currency: 'currency',
    createdAt: 'createdAt',
    userId: 'userId',
    status: 'status',
    guestEmail: 'guestEmail',
    guestName: 'guestName',
    guestWhatsapp: 'guestWhatsapp',
    guestAddress: 'guestAddress',
    deliveryFeeOverride: 'deliveryFeeOverride',
    taxRate: 'taxRate',
    discountPercentage: 'discountPercentage',
    discountAmount: 'discountAmount',
    shareableToken: 'shareableToken',
    emailSent: 'emailSent',
    emailSentAt: 'emailSentAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    duration: 'duration',
    totalAmount: 'totalAmount',
    subtotal: 'subtotal',
    tax: 'tax',
    deliveryFee: 'deliveryFee',
    discountPercentage: 'discountPercentage',
    discountAmount: 'discountAmount',
    currency: 'currency',
    paymentMethod: 'paymentMethod',
    createdAt: 'createdAt',
    userId: 'userId',
    paymentStatus: 'paymentStatus',
    paymentConfirmedBy: 'paymentConfirmedBy',
    paymentConfirmedAt: 'paymentConfirmedAt',
    deliveryAddress: 'deliveryAddress'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const PaymentTransactionScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    provider: 'provider',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    externalReferenceId: 'externalReferenceId',
    proofUrl: 'proofUrl',
    verifiedByAdminId: 'verifiedByAdminId',
    verifiedAt: 'verifiedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentTransactionScalarFieldEnum = (typeof PaymentTransactionScalarFieldEnum)[keyof typeof PaymentTransactionScalarFieldEnum]


  export const ProductRelationScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    relatedProductId: 'relatedProductId',
    relationType: 'relationType',
    priority: 'priority',
    aiScore: 'aiScore',
    createdAt: 'createdAt'
  };

  export type ProductRelationScalarFieldEnum = (typeof ProductRelationScalarFieldEnum)[keyof typeof ProductRelationScalarFieldEnum]


  export const RentalPackageItemScalarFieldEnum: {
    id: 'id',
    rentalPackageId: 'rentalPackageId',
    productId: 'productId',
    quantity: 'quantity',
    createdAt: 'createdAt'
  };

  export type RentalPackageItemScalarFieldEnum = (typeof RentalPackageItemScalarFieldEnum)[keyof typeof RentalPackageItemScalarFieldEnum]


  export const RentalPackageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    imageUrl: 'imageUrl',
    price: 'price',
    discountPercentage: 'discountPercentage',
    duration: 'duration',
    createdAt: 'createdAt',
    images: 'images',
    specs: 'specs'
  };

  export type RentalPackageScalarFieldEnum = (typeof RentalPackageScalarFieldEnum)[keyof typeof RentalPackageScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    monthlyPrice: 'monthlyPrice',
    discountPercentage: 'discountPercentage',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt',
    images: 'images',
    specs: 'specs'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductVariantScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    color: 'color',
    sku: 'sku',
    monthlyPrice: 'monthlyPrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductVariantScalarFieldEnum = (typeof ProductVariantScalarFieldEnum)[keyof typeof ProductVariantScalarFieldEnum]


  export const ProductUnitScalarFieldEnum: {
    id: 'id',
    variantId: 'variantId',
    serialNumber: 'serialNumber',
    status: 'status',
    condition: 'condition',
    assignedOrderId: 'assignedOrderId',
    purchaseDate: 'purchaseDate',
    lastServiceDate: 'lastServiceDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductUnitScalarFieldEnum = (typeof ProductUnitScalarFieldEnum)[keyof typeof ProductUnitScalarFieldEnum]


  export const UnitHistoryScalarFieldEnum: {
    id: 'id',
    unitId: 'unitId',
    oldStatus: 'oldStatus',
    newStatus: 'newStatus',
    oldCondition: 'oldCondition',
    newCondition: 'newCondition',
    details: 'details',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type UnitHistoryScalarFieldEnum = (typeof UnitHistoryScalarFieldEnum)[keyof typeof UnitHistoryScalarFieldEnum]


  export const SystemNotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    userId: 'userId',
    entityId: 'entityId',
    entityType: 'entityType',
    relatedType: 'relatedType',
    createdAt: 'createdAt'
  };

  export type SystemNotificationScalarFieldEnum = (typeof SystemNotificationScalarFieldEnum)[keyof typeof SystemNotificationScalarFieldEnum]


  export const RentalItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    variantId: 'variantId',
    packageId: 'packageId',
    quantity: 'quantity',
    createdAt: 'createdAt',
    unitId: 'unitId'
  };

  export type RentalItemScalarFieldEnum = (typeof RentalItemScalarFieldEnum)[keyof typeof RentalItemScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    plainPassword: 'plainPassword',
    email: 'email',
    fullName: 'fullName',
    whatsapp: 'whatsapp',
    baliAddress: 'baliAddress',
    mapsAddressLink: 'mapsAddressLink',
    role: 'role',
    createdAt: 'createdAt',
    isVerified: 'isVerified',
    resetPasswordExpires: 'resetPasswordExpires',
    resetPasswordToken: 'resetPasswordToken',
    isActive: 'isActive',
    profileImage: 'profileImage',
    identityFile: 'identityFile',
    identityType: 'identityType'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ChatGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChatGroupScalarFieldEnum = (typeof ChatGroupScalarFieldEnum)[keyof typeof ChatGroupScalarFieldEnum]


  export const ChatGroupMemberScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt'
  };

  export type ChatGroupMemberScalarFieldEnum = (typeof ChatGroupMemberScalarFieldEnum)[keyof typeof ChatGroupMemberScalarFieldEnum]


  export const GroupMessageScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    senderId: 'senderId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type GroupMessageScalarFieldEnum = (typeof GroupMessageScalarFieldEnum)[keyof typeof GroupMessageScalarFieldEnum]


  export const SiteSettingScalarFieldEnum: {
    key: 'key',
    value: 'value',
    section: 'section',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SiteSettingScalarFieldEnum = (typeof SiteSettingScalarFieldEnum)[keyof typeof SiteSettingScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    entity: 'entity',
    details: 'details',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const WorkerAttendanceScalarFieldEnum: {
    id: 'id',
    workerId: 'workerId',
    date: 'date',
    status: 'status',
    checkInTime: 'checkInTime',
    checkOutTime: 'checkOutTime',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type WorkerAttendanceScalarFieldEnum = (typeof WorkerAttendanceScalarFieldEnum)[keyof typeof WorkerAttendanceScalarFieldEnum]


  export const InventorySyncLogScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    oldQuantity: 'oldQuantity',
    newQuantity: 'newQuantity',
    updatedBy: 'updatedBy',
    source: 'source',
    conflict: 'conflict',
    resolved: 'resolved',
    resolvedBy: 'resolvedBy',
    resolvedAt: 'resolvedAt',
    createdAt: 'createdAt'
  };

  export type InventorySyncLogScalarFieldEnum = (typeof InventorySyncLogScalarFieldEnum)[keyof typeof InventorySyncLogScalarFieldEnum]


  export const WorkerNotificationScalarFieldEnum: {
    id: 'id',
    workerId: 'workerId',
    fromAdminId: 'fromAdminId',
    type: 'type',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type WorkerNotificationScalarFieldEnum = (typeof WorkerNotificationScalarFieldEnum)[keyof typeof WorkerNotificationScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    receiverId: 'receiverId',
    content: 'content',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const NotificationDismissalScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    entityId: 'entityId',
    entityType: 'entityType',
    createdAt: 'createdAt'
  };

  export type NotificationDismissalScalarFieldEnum = (typeof NotificationDismissalScalarFieldEnum)[keyof typeof NotificationDismissalScalarFieldEnum]


  export const SystemJobLogScalarFieldEnum: {
    id: 'id',
    jobName: 'jobName',
    status: 'status',
    message: 'message',
    createdAt: 'createdAt'
  };

  export type SystemJobLogScalarFieldEnum = (typeof SystemJobLogScalarFieldEnum)[keyof typeof SystemJobLogScalarFieldEnum]


  export const IdempotencyKeyScalarFieldEnum: {
    id: 'id',
    key: 'key',
    createdAt: 'createdAt',
    response: 'response'
  };

  export type IdempotencyKeyScalarFieldEnum = (typeof IdempotencyKeyScalarFieldEnum)[keyof typeof IdempotencyKeyScalarFieldEnum]


  export const JobQueueScalarFieldEnum: {
    id: 'id',
    type: 'type',
    payload: 'payload',
    status: 'status',
    retryCount: 'retryCount',
    runAt: 'runAt',
    createdAt: 'createdAt',
    processedAt: 'processedAt',
    error: 'error'
  };

  export type JobQueueScalarFieldEnum = (typeof JobQueueScalarFieldEnum)[keyof typeof JobQueueScalarFieldEnum]


  export const CronLockScalarFieldEnum: {
    id: 'id',
    lockedAt: 'lockedAt',
    lockedBy: 'lockedBy'
  };

  export type CronLockScalarFieldEnum = (typeof CronLockScalarFieldEnum)[keyof typeof CronLockScalarFieldEnum]


  export const AiAgentScalarFieldEnum: {
    id: 'id',
    systemName: 'systemName',
    displayName: 'displayName',
    isActive: 'isActive',
    canMutateData: 'canMutateData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AiAgentScalarFieldEnum = (typeof AiAgentScalarFieldEnum)[keyof typeof AiAgentScalarFieldEnum]


  export const AiPermissionScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    canModifyProducts: 'canModifyProducts',
    canModifyPackages: 'canModifyPackages',
    canModifyOrders: 'canModifyOrders',
    requiresAdminConfirmation: 'requiresAdminConfirmation'
  };

  export type AiPermissionScalarFieldEnum = (typeof AiPermissionScalarFieldEnum)[keyof typeof AiPermissionScalarFieldEnum]


  export const AiActionScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    actionType: 'actionType',
    payloadBefore: 'payloadBefore',
    payloadAfter: 'payloadAfter',
    status: 'status',
    approvedBy: 'approvedBy',
    createdAt: 'createdAt',
    executedAt: 'executedAt'
  };

  export type AiActionScalarFieldEnum = (typeof AiActionScalarFieldEnum)[keyof typeof AiActionScalarFieldEnum]


  export const AiTrainingDataScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    suggestion: 'suggestion',
    adminDecision: 'adminDecision',
    feedbackScore: 'feedbackScore',
    createdAt: 'createdAt'
  };

  export type AiTrainingDataScalarFieldEnum = (typeof AiTrainingDataScalarFieldEnum)[keyof typeof AiTrainingDataScalarFieldEnum]


  export const VehicleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    status: 'status',
    currentDeliveryId: 'currentDeliveryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VehicleScalarFieldEnum = (typeof VehicleScalarFieldEnum)[keyof typeof VehicleScalarFieldEnum]


  export const DeliveryScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    deliveryMethod: 'deliveryMethod',
    deliveryType: 'deliveryType',
    vehicleId: 'vehicleId',
    status: 'status',
    claimedByWorkerId: 'claimedByWorkerId',
    claimedAt: 'claimedAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    eta: 'eta',
    etaOverrideCount: 'etaOverrideCount',
    delayMinutes: 'delayMinutes',
    latitude: 'latitude',
    longitude: 'longitude',
    lastLocationUpdate: 'lastLocationUpdate',
    trackingCode: 'trackingCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeliveryScalarFieldEnum = (typeof DeliveryScalarFieldEnum)[keyof typeof DeliveryScalarFieldEnum]


  export const DeliveryItemScalarFieldEnum: {
    id: 'id',
    deliveryId: 'deliveryId',
    rentalItemId: 'rentalItemId',
    quantity: 'quantity'
  };

  export type DeliveryItemScalarFieldEnum = (typeof DeliveryItemScalarFieldEnum)[keyof typeof DeliveryItemScalarFieldEnum]


  export const DeliveryLogScalarFieldEnum: {
    id: 'id',
    deliveryId: 'deliveryId',
    eventType: 'eventType',
    oldValue: 'oldValue',
    newValue: 'newValue',
    createdByUserId: 'createdByUserId',
    role: 'role',
    createdAt: 'createdAt'
  };

  export type DeliveryLogScalarFieldEnum = (typeof DeliveryLogScalarFieldEnum)[keyof typeof DeliveryLogScalarFieldEnum]


  export const DeliveryEditLogScalarFieldEnum: {
    id: 'id',
    deliveryId: 'deliveryId',
    editedByUserId: 'editedByUserId',
    role: 'role',
    fieldChanged: 'fieldChanged',
    oldValue: 'oldValue',
    newValue: 'newValue',
    reason: 'reason',
    createdAt: 'createdAt'
  };

  export type DeliveryEditLogScalarFieldEnum = (typeof DeliveryEditLogScalarFieldEnum)[keyof typeof DeliveryEditLogScalarFieldEnum]


  export const SpecialOfferScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    badgeText: 'badgeText',
    discountPercentage: 'discountPercentage',
    originalPrice: 'originalPrice',
    finalPrice: 'finalPrice',
    images: 'images',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type SpecialOfferScalarFieldEnum = (typeof SpecialOfferScalarFieldEnum)[keyof typeof SpecialOfferScalarFieldEnum]


  export const ContactMessageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    subject: 'subject',
    message: 'message',
    source: 'source',
    createdAt: 'createdAt'
  };

  export type ContactMessageScalarFieldEnum = (typeof ContactMessageScalarFieldEnum)[keyof typeof ContactMessageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'PaymentProvider'
   */
  export type EnumPaymentProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentProvider'>
    


  /**
   * Reference to a field of type 'PaymentProvider[]'
   */
  export type ListEnumPaymentProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentProvider[]'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'TransactionStatus[]'
   */
  export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    


  /**
   * Reference to a field of type 'RelationType'
   */
  export type EnumRelationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RelationType'>
    


  /**
   * Reference to a field of type 'RelationType[]'
   */
  export type ListEnumRelationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RelationType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'UnitStatus'
   */
  export type EnumUnitStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UnitStatus'>
    


  /**
   * Reference to a field of type 'UnitStatus[]'
   */
  export type ListEnumUnitStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UnitStatus[]'>
    


  /**
   * Reference to a field of type 'UnitCondition'
   */
  export type EnumUnitConditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UnitCondition'>
    


  /**
   * Reference to a field of type 'UnitCondition[]'
   */
  export type ListEnumUnitConditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UnitCondition[]'>
    


  /**
   * Reference to a field of type 'attendance_status'
   */
  export type Enumattendance_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'attendance_status'>
    


  /**
   * Reference to a field of type 'attendance_status[]'
   */
  export type ListEnumattendance_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'attendance_status[]'>
    


  /**
   * Reference to a field of type 'inventory_source'
   */
  export type Enuminventory_sourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inventory_source'>
    


  /**
   * Reference to a field of type 'inventory_source[]'
   */
  export type ListEnuminventory_sourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inventory_source[]'>
    


  /**
   * Reference to a field of type 'AiAgentSystemName'
   */
  export type EnumAiAgentSystemNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AiAgentSystemName'>
    


  /**
   * Reference to a field of type 'AiAgentSystemName[]'
   */
  export type ListEnumAiAgentSystemNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AiAgentSystemName[]'>
    


  /**
   * Reference to a field of type 'AiActionStatus'
   */
  export type EnumAiActionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AiActionStatus'>
    


  /**
   * Reference to a field of type 'AiActionStatus[]'
   */
  export type ListEnumAiActionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AiActionStatus[]'>
    


  /**
   * Reference to a field of type 'VehicleType'
   */
  export type EnumVehicleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VehicleType'>
    


  /**
   * Reference to a field of type 'VehicleType[]'
   */
  export type ListEnumVehicleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VehicleType[]'>
    


  /**
   * Reference to a field of type 'VehicleStatus'
   */
  export type EnumVehicleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VehicleStatus'>
    


  /**
   * Reference to a field of type 'VehicleStatus[]'
   */
  export type ListEnumVehicleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VehicleStatus[]'>
    


  /**
   * Reference to a field of type 'DeliveryMethod'
   */
  export type EnumDeliveryMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryMethod'>
    


  /**
   * Reference to a field of type 'DeliveryMethod[]'
   */
  export type ListEnumDeliveryMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryMethod[]'>
    


  /**
   * Reference to a field of type 'DeliveryType'
   */
  export type EnumDeliveryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryType'>
    


  /**
   * Reference to a field of type 'DeliveryType[]'
   */
  export type ListEnumDeliveryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryType[]'>
    


  /**
   * Reference to a field of type 'DeliveryStatus'
   */
  export type EnumDeliveryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryStatus'>
    


  /**
   * Reference to a field of type 'DeliveryStatus[]'
   */
  export type ListEnumDeliveryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryStatus[]'>
    


  /**
   * Reference to a field of type 'DeliveryRole'
   */
  export type EnumDeliveryRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryRole'>
    


  /**
   * Reference to a field of type 'DeliveryRole[]'
   */
  export type ListEnumDeliveryRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryRole[]'>
    
  /**
   * Deep Input Types
   */


  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: UuidFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    orderId?: UuidNullableFilter<"Invoice"> | string | null
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    currency?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    userId?: UuidNullableFilter<"Invoice"> | string | null
    status?: StringFilter<"Invoice"> | string
    guestEmail?: StringNullableFilter<"Invoice"> | string | null
    guestName?: StringNullableFilter<"Invoice"> | string | null
    guestWhatsapp?: StringNullableFilter<"Invoice"> | string | null
    guestAddress?: StringNullableFilter<"Invoice"> | string | null
    deliveryFeeOverride?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    taxRate?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: IntNullableFilter<"Invoice"> | number | null
    discountAmount?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    shareableToken?: StringNullableFilter<"Invoice"> | string | null
    emailSent?: BoolNullableFilter<"Invoice"> | boolean | null
    emailSentAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    deliveries?: DeliveryListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    orderId?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    deliveryFee?: SortOrder
    total?: SortOrder
    currency?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    status?: SortOrder
    guestEmail?: SortOrderInput | SortOrder
    guestName?: SortOrderInput | SortOrder
    guestWhatsapp?: SortOrderInput | SortOrder
    guestAddress?: SortOrderInput | SortOrder
    deliveryFeeOverride?: SortOrderInput | SortOrder
    taxRate?: SortOrderInput | SortOrder
    discountPercentage?: SortOrderInput | SortOrder
    discountAmount?: SortOrderInput | SortOrder
    shareableToken?: SortOrderInput | SortOrder
    emailSent?: SortOrderInput | SortOrder
    emailSentAt?: SortOrderInput | SortOrder
    order?: OrderOrderByWithRelationInput
    deliveries?: DeliveryOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNumber?: string
    shareableToken?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    orderId?: UuidNullableFilter<"Invoice"> | string | null
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    currency?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    userId?: UuidNullableFilter<"Invoice"> | string | null
    status?: StringFilter<"Invoice"> | string
    guestEmail?: StringNullableFilter<"Invoice"> | string | null
    guestName?: StringNullableFilter<"Invoice"> | string | null
    guestWhatsapp?: StringNullableFilter<"Invoice"> | string | null
    guestAddress?: StringNullableFilter<"Invoice"> | string | null
    deliveryFeeOverride?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    taxRate?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: IntNullableFilter<"Invoice"> | number | null
    discountAmount?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    emailSent?: BoolNullableFilter<"Invoice"> | boolean | null
    emailSentAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    deliveries?: DeliveryListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "invoiceNumber" | "shareableToken">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    orderId?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    deliveryFee?: SortOrder
    total?: SortOrder
    currency?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    status?: SortOrder
    guestEmail?: SortOrderInput | SortOrder
    guestName?: SortOrderInput | SortOrder
    guestWhatsapp?: SortOrderInput | SortOrder
    guestAddress?: SortOrderInput | SortOrder
    deliveryFeeOverride?: SortOrderInput | SortOrder
    taxRate?: SortOrderInput | SortOrder
    discountPercentage?: SortOrderInput | SortOrder
    discountAmount?: SortOrderInput | SortOrder
    shareableToken?: SortOrderInput | SortOrder
    emailSent?: SortOrderInput | SortOrder
    emailSentAt?: SortOrderInput | SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Invoice"> | string
    invoiceNumber?: StringWithAggregatesFilter<"Invoice"> | string
    orderId?: UuidNullableWithAggregatesFilter<"Invoice"> | string | null
    subtotal?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    currency?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    userId?: UuidNullableWithAggregatesFilter<"Invoice"> | string | null
    status?: StringWithAggregatesFilter<"Invoice"> | string
    guestEmail?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    guestName?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    guestWhatsapp?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    guestAddress?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    deliveryFeeOverride?: DecimalNullableWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    taxRate?: DecimalNullableWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: IntNullableWithAggregatesFilter<"Invoice"> | number | null
    discountAmount?: DecimalNullableWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    shareableToken?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    emailSent?: BoolNullableWithAggregatesFilter<"Invoice"> | boolean | null
    emailSentAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: UuidFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    status?: StringFilter<"Order"> | string
    startDate?: DateTimeFilter<"Order"> | Date | string
    endDate?: DateTimeFilter<"Order"> | Date | string
    duration?: IntFilter<"Order"> | number
    totalAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    discountPercentage?: IntNullableFilter<"Order"> | number | null
    discountAmount?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"Order"> | string | null
    paymentMethod?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    userId?: UuidFilter<"Order"> | string
    paymentStatus?: StringNullableFilter<"Order"> | string | null
    paymentConfirmedBy?: UuidNullableFilter<"Order"> | string | null
    paymentConfirmedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveryAddress?: StringNullableFilter<"Order"> | string | null
    invoices?: InvoiceListRelationFilter
    assignedUnits?: ProductUnitListRelationFilter
    users_orders_payment_confirmed_byTousers?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    rentalItems?: RentalItemListRelationFilter
    paymentTransactions?: PaymentTransactionListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    totalAmount?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    deliveryFee?: SortOrder
    discountPercentage?: SortOrderInput | SortOrder
    discountAmount?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    paymentConfirmedBy?: SortOrderInput | SortOrder
    paymentConfirmedAt?: SortOrderInput | SortOrder
    deliveryAddress?: SortOrderInput | SortOrder
    invoices?: InvoiceOrderByRelationAggregateInput
    assignedUnits?: ProductUnitOrderByRelationAggregateInput
    users_orders_payment_confirmed_byTousers?: UserOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    rentalItems?: RentalItemOrderByRelationAggregateInput
    paymentTransactions?: PaymentTransactionOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNumber?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    status?: StringFilter<"Order"> | string
    startDate?: DateTimeFilter<"Order"> | Date | string
    endDate?: DateTimeFilter<"Order"> | Date | string
    duration?: IntFilter<"Order"> | number
    totalAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    discountPercentage?: IntNullableFilter<"Order"> | number | null
    discountAmount?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"Order"> | string | null
    paymentMethod?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    userId?: UuidFilter<"Order"> | string
    paymentStatus?: StringNullableFilter<"Order"> | string | null
    paymentConfirmedBy?: UuidNullableFilter<"Order"> | string | null
    paymentConfirmedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveryAddress?: StringNullableFilter<"Order"> | string | null
    invoices?: InvoiceListRelationFilter
    assignedUnits?: ProductUnitListRelationFilter
    users_orders_payment_confirmed_byTousers?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    rentalItems?: RentalItemListRelationFilter
    paymentTransactions?: PaymentTransactionListRelationFilter
  }, "id" | "orderNumber">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    totalAmount?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    deliveryFee?: SortOrder
    discountPercentage?: SortOrderInput | SortOrder
    discountAmount?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    paymentConfirmedBy?: SortOrderInput | SortOrder
    paymentConfirmedAt?: SortOrderInput | SortOrder
    deliveryAddress?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Order"> | string
    orderNumber?: StringWithAggregatesFilter<"Order"> | string
    status?: StringWithAggregatesFilter<"Order"> | string
    startDate?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    duration?: IntWithAggregatesFilter<"Order"> | number
    totalAmount?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    discountPercentage?: IntNullableWithAggregatesFilter<"Order"> | number | null
    discountAmount?: DecimalNullableWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableWithAggregatesFilter<"Order"> | string | null
    paymentMethod?: StringNullableWithAggregatesFilter<"Order"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    userId?: UuidWithAggregatesFilter<"Order"> | string
    paymentStatus?: StringNullableWithAggregatesFilter<"Order"> | string | null
    paymentConfirmedBy?: UuidNullableWithAggregatesFilter<"Order"> | string | null
    paymentConfirmedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    deliveryAddress?: StringNullableWithAggregatesFilter<"Order"> | string | null
  }

  export type PaymentTransactionWhereInput = {
    AND?: PaymentTransactionWhereInput | PaymentTransactionWhereInput[]
    OR?: PaymentTransactionWhereInput[]
    NOT?: PaymentTransactionWhereInput | PaymentTransactionWhereInput[]
    id?: UuidFilter<"PaymentTransaction"> | string
    orderId?: UuidFilter<"PaymentTransaction"> | string
    provider?: EnumPaymentProviderFilter<"PaymentTransaction"> | $Enums.PaymentProvider
    amount?: DecimalFilter<"PaymentTransaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"PaymentTransaction"> | string
    status?: EnumTransactionStatusFilter<"PaymentTransaction"> | $Enums.TransactionStatus
    externalReferenceId?: StringNullableFilter<"PaymentTransaction"> | string | null
    proofUrl?: StringNullableFilter<"PaymentTransaction"> | string | null
    verifiedByAdminId?: UuidNullableFilter<"PaymentTransaction"> | string | null
    verifiedAt?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    verifiedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PaymentTransactionOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    externalReferenceId?: SortOrderInput | SortOrder
    proofUrl?: SortOrderInput | SortOrder
    verifiedByAdminId?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    verifiedBy?: UserOrderByWithRelationInput
  }

  export type PaymentTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentTransactionWhereInput | PaymentTransactionWhereInput[]
    OR?: PaymentTransactionWhereInput[]
    NOT?: PaymentTransactionWhereInput | PaymentTransactionWhereInput[]
    orderId?: UuidFilter<"PaymentTransaction"> | string
    provider?: EnumPaymentProviderFilter<"PaymentTransaction"> | $Enums.PaymentProvider
    amount?: DecimalFilter<"PaymentTransaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"PaymentTransaction"> | string
    status?: EnumTransactionStatusFilter<"PaymentTransaction"> | $Enums.TransactionStatus
    externalReferenceId?: StringNullableFilter<"PaymentTransaction"> | string | null
    proofUrl?: StringNullableFilter<"PaymentTransaction"> | string | null
    verifiedByAdminId?: UuidNullableFilter<"PaymentTransaction"> | string | null
    verifiedAt?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    verifiedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type PaymentTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    externalReferenceId?: SortOrderInput | SortOrder
    proofUrl?: SortOrderInput | SortOrder
    verifiedByAdminId?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentTransactionCountOrderByAggregateInput
    _avg?: PaymentTransactionAvgOrderByAggregateInput
    _max?: PaymentTransactionMaxOrderByAggregateInput
    _min?: PaymentTransactionMinOrderByAggregateInput
    _sum?: PaymentTransactionSumOrderByAggregateInput
  }

  export type PaymentTransactionScalarWhereWithAggregatesInput = {
    AND?: PaymentTransactionScalarWhereWithAggregatesInput | PaymentTransactionScalarWhereWithAggregatesInput[]
    OR?: PaymentTransactionScalarWhereWithAggregatesInput[]
    NOT?: PaymentTransactionScalarWhereWithAggregatesInput | PaymentTransactionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PaymentTransaction"> | string
    orderId?: UuidWithAggregatesFilter<"PaymentTransaction"> | string
    provider?: EnumPaymentProviderWithAggregatesFilter<"PaymentTransaction"> | $Enums.PaymentProvider
    amount?: DecimalWithAggregatesFilter<"PaymentTransaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"PaymentTransaction"> | string
    status?: EnumTransactionStatusWithAggregatesFilter<"PaymentTransaction"> | $Enums.TransactionStatus
    externalReferenceId?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    proofUrl?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    verifiedByAdminId?: UuidNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"PaymentTransaction"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PaymentTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentTransaction"> | Date | string
  }

  export type ProductRelationWhereInput = {
    AND?: ProductRelationWhereInput | ProductRelationWhereInput[]
    OR?: ProductRelationWhereInput[]
    NOT?: ProductRelationWhereInput | ProductRelationWhereInput[]
    id?: UuidFilter<"ProductRelation"> | string
    productId?: UuidFilter<"ProductRelation"> | string
    relatedProductId?: UuidFilter<"ProductRelation"> | string
    relationType?: EnumRelationTypeFilter<"ProductRelation"> | $Enums.RelationType
    priority?: IntFilter<"ProductRelation"> | number
    aiScore?: FloatNullableFilter<"ProductRelation"> | number | null
    createdAt?: DateTimeFilter<"ProductRelation"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    relatedProduct?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductRelationOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    relatedProductId?: SortOrder
    relationType?: SortOrder
    priority?: SortOrder
    aiScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    relatedProduct?: ProductOrderByWithRelationInput
  }

  export type ProductRelationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_relatedProductId?: ProductRelationProductIdRelatedProductIdCompoundUniqueInput
    AND?: ProductRelationWhereInput | ProductRelationWhereInput[]
    OR?: ProductRelationWhereInput[]
    NOT?: ProductRelationWhereInput | ProductRelationWhereInput[]
    productId?: UuidFilter<"ProductRelation"> | string
    relatedProductId?: UuidFilter<"ProductRelation"> | string
    relationType?: EnumRelationTypeFilter<"ProductRelation"> | $Enums.RelationType
    priority?: IntFilter<"ProductRelation"> | number
    aiScore?: FloatNullableFilter<"ProductRelation"> | number | null
    createdAt?: DateTimeFilter<"ProductRelation"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    relatedProduct?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "productId_relatedProductId">

  export type ProductRelationOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    relatedProductId?: SortOrder
    relationType?: SortOrder
    priority?: SortOrder
    aiScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ProductRelationCountOrderByAggregateInput
    _avg?: ProductRelationAvgOrderByAggregateInput
    _max?: ProductRelationMaxOrderByAggregateInput
    _min?: ProductRelationMinOrderByAggregateInput
    _sum?: ProductRelationSumOrderByAggregateInput
  }

  export type ProductRelationScalarWhereWithAggregatesInput = {
    AND?: ProductRelationScalarWhereWithAggregatesInput | ProductRelationScalarWhereWithAggregatesInput[]
    OR?: ProductRelationScalarWhereWithAggregatesInput[]
    NOT?: ProductRelationScalarWhereWithAggregatesInput | ProductRelationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProductRelation"> | string
    productId?: UuidWithAggregatesFilter<"ProductRelation"> | string
    relatedProductId?: UuidWithAggregatesFilter<"ProductRelation"> | string
    relationType?: EnumRelationTypeWithAggregatesFilter<"ProductRelation"> | $Enums.RelationType
    priority?: IntWithAggregatesFilter<"ProductRelation"> | number
    aiScore?: FloatNullableWithAggregatesFilter<"ProductRelation"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductRelation"> | Date | string
  }

  export type RentalPackageItemWhereInput = {
    AND?: RentalPackageItemWhereInput | RentalPackageItemWhereInput[]
    OR?: RentalPackageItemWhereInput[]
    NOT?: RentalPackageItemWhereInput | RentalPackageItemWhereInput[]
    id?: UuidFilter<"RentalPackageItem"> | string
    rentalPackageId?: UuidFilter<"RentalPackageItem"> | string
    productId?: UuidFilter<"RentalPackageItem"> | string
    quantity?: IntNullableFilter<"RentalPackageItem"> | number | null
    createdAt?: DateTimeNullableFilter<"RentalPackageItem"> | Date | string | null
    rentalPackage?: XOR<RentalPackageScalarRelationFilter, RentalPackageWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type RentalPackageItemOrderByWithRelationInput = {
    id?: SortOrder
    rentalPackageId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    rentalPackage?: RentalPackageOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type RentalPackageItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RentalPackageItemWhereInput | RentalPackageItemWhereInput[]
    OR?: RentalPackageItemWhereInput[]
    NOT?: RentalPackageItemWhereInput | RentalPackageItemWhereInput[]
    rentalPackageId?: UuidFilter<"RentalPackageItem"> | string
    productId?: UuidFilter<"RentalPackageItem"> | string
    quantity?: IntNullableFilter<"RentalPackageItem"> | number | null
    createdAt?: DateTimeNullableFilter<"RentalPackageItem"> | Date | string | null
    rentalPackage?: XOR<RentalPackageScalarRelationFilter, RentalPackageWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type RentalPackageItemOrderByWithAggregationInput = {
    id?: SortOrder
    rentalPackageId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: RentalPackageItemCountOrderByAggregateInput
    _avg?: RentalPackageItemAvgOrderByAggregateInput
    _max?: RentalPackageItemMaxOrderByAggregateInput
    _min?: RentalPackageItemMinOrderByAggregateInput
    _sum?: RentalPackageItemSumOrderByAggregateInput
  }

  export type RentalPackageItemScalarWhereWithAggregatesInput = {
    AND?: RentalPackageItemScalarWhereWithAggregatesInput | RentalPackageItemScalarWhereWithAggregatesInput[]
    OR?: RentalPackageItemScalarWhereWithAggregatesInput[]
    NOT?: RentalPackageItemScalarWhereWithAggregatesInput | RentalPackageItemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"RentalPackageItem"> | string
    rentalPackageId?: UuidWithAggregatesFilter<"RentalPackageItem"> | string
    productId?: UuidWithAggregatesFilter<"RentalPackageItem"> | string
    quantity?: IntNullableWithAggregatesFilter<"RentalPackageItem"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"RentalPackageItem"> | Date | string | null
  }

  export type RentalPackageWhereInput = {
    AND?: RentalPackageWhereInput | RentalPackageWhereInput[]
    OR?: RentalPackageWhereInput[]
    NOT?: RentalPackageWhereInput | RentalPackageWhereInput[]
    id?: UuidFilter<"RentalPackage"> | string
    name?: StringFilter<"RentalPackage"> | string
    description?: StringNullableFilter<"RentalPackage"> | string | null
    imageUrl?: StringNullableFilter<"RentalPackage"> | string | null
    price?: DecimalFilter<"RentalPackage"> | Decimal | DecimalJsLike | number | string
    discountPercentage?: IntNullableFilter<"RentalPackage"> | number | null
    duration?: IntFilter<"RentalPackage"> | number
    createdAt?: DateTimeNullableFilter<"RentalPackage"> | Date | string | null
    images?: StringNullableListFilter<"RentalPackage">
    specs?: JsonNullableFilter<"RentalPackage">
    rentalPackageItems?: RentalPackageItemListRelationFilter
    rentalItems?: RentalItemListRelationFilter
  }

  export type RentalPackageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    price?: SortOrder
    discountPercentage?: SortOrderInput | SortOrder
    duration?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    images?: SortOrder
    specs?: SortOrderInput | SortOrder
    rentalPackageItems?: RentalPackageItemOrderByRelationAggregateInput
    rentalItems?: RentalItemOrderByRelationAggregateInput
  }

  export type RentalPackageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RentalPackageWhereInput | RentalPackageWhereInput[]
    OR?: RentalPackageWhereInput[]
    NOT?: RentalPackageWhereInput | RentalPackageWhereInput[]
    name?: StringFilter<"RentalPackage"> | string
    description?: StringNullableFilter<"RentalPackage"> | string | null
    imageUrl?: StringNullableFilter<"RentalPackage"> | string | null
    price?: DecimalFilter<"RentalPackage"> | Decimal | DecimalJsLike | number | string
    discountPercentage?: IntNullableFilter<"RentalPackage"> | number | null
    duration?: IntFilter<"RentalPackage"> | number
    createdAt?: DateTimeNullableFilter<"RentalPackage"> | Date | string | null
    images?: StringNullableListFilter<"RentalPackage">
    specs?: JsonNullableFilter<"RentalPackage">
    rentalPackageItems?: RentalPackageItemListRelationFilter
    rentalItems?: RentalItemListRelationFilter
  }, "id">

  export type RentalPackageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    price?: SortOrder
    discountPercentage?: SortOrderInput | SortOrder
    duration?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    images?: SortOrder
    specs?: SortOrderInput | SortOrder
    _count?: RentalPackageCountOrderByAggregateInput
    _avg?: RentalPackageAvgOrderByAggregateInput
    _max?: RentalPackageMaxOrderByAggregateInput
    _min?: RentalPackageMinOrderByAggregateInput
    _sum?: RentalPackageSumOrderByAggregateInput
  }

  export type RentalPackageScalarWhereWithAggregatesInput = {
    AND?: RentalPackageScalarWhereWithAggregatesInput | RentalPackageScalarWhereWithAggregatesInput[]
    OR?: RentalPackageScalarWhereWithAggregatesInput[]
    NOT?: RentalPackageScalarWhereWithAggregatesInput | RentalPackageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"RentalPackage"> | string
    name?: StringWithAggregatesFilter<"RentalPackage"> | string
    description?: StringNullableWithAggregatesFilter<"RentalPackage"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"RentalPackage"> | string | null
    price?: DecimalWithAggregatesFilter<"RentalPackage"> | Decimal | DecimalJsLike | number | string
    discountPercentage?: IntNullableWithAggregatesFilter<"RentalPackage"> | number | null
    duration?: IntWithAggregatesFilter<"RentalPackage"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"RentalPackage"> | Date | string | null
    images?: StringNullableListFilter<"RentalPackage">
    specs?: JsonNullableWithAggregatesFilter<"RentalPackage">
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: UuidFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    category?: StringFilter<"Product"> | string
    monthlyPrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    discountPercentage?: IntNullableFilter<"Product"> | number | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    images?: StringNullableListFilter<"Product">
    specs?: JsonNullableFilter<"Product">
    inventorySyncLogs?: InventorySyncLogListRelationFilter
    rentalPackageItems?: RentalPackageItemListRelationFilter
    productRelations?: ProductRelationListRelationFilter
    relatedTo?: ProductRelationListRelationFilter
    variants?: ProductVariantListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    monthlyPrice?: SortOrder
    discountPercentage?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    images?: SortOrder
    specs?: SortOrderInput | SortOrder
    inventorySyncLogs?: InventorySyncLogOrderByRelationAggregateInput
    rentalPackageItems?: RentalPackageItemOrderByRelationAggregateInput
    productRelations?: ProductRelationOrderByRelationAggregateInput
    relatedTo?: ProductRelationOrderByRelationAggregateInput
    variants?: ProductVariantOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    category?: StringFilter<"Product"> | string
    monthlyPrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    discountPercentage?: IntNullableFilter<"Product"> | number | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    images?: StringNullableListFilter<"Product">
    specs?: JsonNullableFilter<"Product">
    inventorySyncLogs?: InventorySyncLogListRelationFilter
    rentalPackageItems?: RentalPackageItemListRelationFilter
    productRelations?: ProductRelationListRelationFilter
    relatedTo?: ProductRelationListRelationFilter
    variants?: ProductVariantListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    monthlyPrice?: SortOrder
    discountPercentage?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    images?: SortOrder
    specs?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    category?: StringWithAggregatesFilter<"Product"> | string
    monthlyPrice?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    discountPercentage?: IntNullableWithAggregatesFilter<"Product"> | number | null
    imageUrl?: StringNullableWithAggregatesFilter<"Product"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    images?: StringNullableListFilter<"Product">
    specs?: JsonNullableWithAggregatesFilter<"Product">
  }

  export type ProductVariantWhereInput = {
    AND?: ProductVariantWhereInput | ProductVariantWhereInput[]
    OR?: ProductVariantWhereInput[]
    NOT?: ProductVariantWhereInput | ProductVariantWhereInput[]
    id?: UuidFilter<"ProductVariant"> | string
    productId?: UuidFilter<"ProductVariant"> | string
    color?: StringFilter<"ProductVariant"> | string
    sku?: StringFilter<"ProductVariant"> | string
    monthlyPrice?: DecimalNullableFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    rentalItems?: RentalItemListRelationFilter
    units?: ProductUnitListRelationFilter
  }

  export type ProductVariantOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    color?: SortOrder
    sku?: SortOrder
    monthlyPrice?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    rentalItems?: RentalItemOrderByRelationAggregateInput
    units?: ProductUnitOrderByRelationAggregateInput
  }

  export type ProductVariantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    AND?: ProductVariantWhereInput | ProductVariantWhereInput[]
    OR?: ProductVariantWhereInput[]
    NOT?: ProductVariantWhereInput | ProductVariantWhereInput[]
    productId?: UuidFilter<"ProductVariant"> | string
    color?: StringFilter<"ProductVariant"> | string
    monthlyPrice?: DecimalNullableFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    rentalItems?: RentalItemListRelationFilter
    units?: ProductUnitListRelationFilter
  }, "id" | "sku">

  export type ProductVariantOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    color?: SortOrder
    sku?: SortOrder
    monthlyPrice?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductVariantCountOrderByAggregateInput
    _avg?: ProductVariantAvgOrderByAggregateInput
    _max?: ProductVariantMaxOrderByAggregateInput
    _min?: ProductVariantMinOrderByAggregateInput
    _sum?: ProductVariantSumOrderByAggregateInput
  }

  export type ProductVariantScalarWhereWithAggregatesInput = {
    AND?: ProductVariantScalarWhereWithAggregatesInput | ProductVariantScalarWhereWithAggregatesInput[]
    OR?: ProductVariantScalarWhereWithAggregatesInput[]
    NOT?: ProductVariantScalarWhereWithAggregatesInput | ProductVariantScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProductVariant"> | string
    productId?: UuidWithAggregatesFilter<"ProductVariant"> | string
    color?: StringWithAggregatesFilter<"ProductVariant"> | string
    sku?: StringWithAggregatesFilter<"ProductVariant"> | string
    monthlyPrice?: DecimalNullableWithAggregatesFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductVariant"> | Date | string
  }

  export type ProductUnitWhereInput = {
    AND?: ProductUnitWhereInput | ProductUnitWhereInput[]
    OR?: ProductUnitWhereInput[]
    NOT?: ProductUnitWhereInput | ProductUnitWhereInput[]
    id?: UuidFilter<"ProductUnit"> | string
    variantId?: UuidFilter<"ProductUnit"> | string
    serialNumber?: StringFilter<"ProductUnit"> | string
    status?: EnumUnitStatusFilter<"ProductUnit"> | $Enums.UnitStatus
    condition?: EnumUnitConditionFilter<"ProductUnit"> | $Enums.UnitCondition
    assignedOrderId?: UuidNullableFilter<"ProductUnit"> | string | null
    purchaseDate?: DateTimeNullableFilter<"ProductUnit"> | Date | string | null
    lastServiceDate?: DateTimeNullableFilter<"ProductUnit"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductUnit"> | Date | string
    updatedAt?: DateTimeFilter<"ProductUnit"> | Date | string
    variant?: XOR<ProductVariantScalarRelationFilter, ProductVariantWhereInput>
    assignedOrder?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    rentalItems?: RentalItemListRelationFilter
    history?: UnitHistoryListRelationFilter
  }

  export type ProductUnitOrderByWithRelationInput = {
    id?: SortOrder
    variantId?: SortOrder
    serialNumber?: SortOrder
    status?: SortOrder
    condition?: SortOrder
    assignedOrderId?: SortOrderInput | SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    lastServiceDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    variant?: ProductVariantOrderByWithRelationInput
    assignedOrder?: OrderOrderByWithRelationInput
    rentalItems?: RentalItemOrderByRelationAggregateInput
    history?: UnitHistoryOrderByRelationAggregateInput
  }

  export type ProductUnitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    serialNumber?: string
    AND?: ProductUnitWhereInput | ProductUnitWhereInput[]
    OR?: ProductUnitWhereInput[]
    NOT?: ProductUnitWhereInput | ProductUnitWhereInput[]
    variantId?: UuidFilter<"ProductUnit"> | string
    status?: EnumUnitStatusFilter<"ProductUnit"> | $Enums.UnitStatus
    condition?: EnumUnitConditionFilter<"ProductUnit"> | $Enums.UnitCondition
    assignedOrderId?: UuidNullableFilter<"ProductUnit"> | string | null
    purchaseDate?: DateTimeNullableFilter<"ProductUnit"> | Date | string | null
    lastServiceDate?: DateTimeNullableFilter<"ProductUnit"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductUnit"> | Date | string
    updatedAt?: DateTimeFilter<"ProductUnit"> | Date | string
    variant?: XOR<ProductVariantScalarRelationFilter, ProductVariantWhereInput>
    assignedOrder?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    rentalItems?: RentalItemListRelationFilter
    history?: UnitHistoryListRelationFilter
  }, "id" | "serialNumber">

  export type ProductUnitOrderByWithAggregationInput = {
    id?: SortOrder
    variantId?: SortOrder
    serialNumber?: SortOrder
    status?: SortOrder
    condition?: SortOrder
    assignedOrderId?: SortOrderInput | SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    lastServiceDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductUnitCountOrderByAggregateInput
    _max?: ProductUnitMaxOrderByAggregateInput
    _min?: ProductUnitMinOrderByAggregateInput
  }

  export type ProductUnitScalarWhereWithAggregatesInput = {
    AND?: ProductUnitScalarWhereWithAggregatesInput | ProductUnitScalarWhereWithAggregatesInput[]
    OR?: ProductUnitScalarWhereWithAggregatesInput[]
    NOT?: ProductUnitScalarWhereWithAggregatesInput | ProductUnitScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProductUnit"> | string
    variantId?: UuidWithAggregatesFilter<"ProductUnit"> | string
    serialNumber?: StringWithAggregatesFilter<"ProductUnit"> | string
    status?: EnumUnitStatusWithAggregatesFilter<"ProductUnit"> | $Enums.UnitStatus
    condition?: EnumUnitConditionWithAggregatesFilter<"ProductUnit"> | $Enums.UnitCondition
    assignedOrderId?: UuidNullableWithAggregatesFilter<"ProductUnit"> | string | null
    purchaseDate?: DateTimeNullableWithAggregatesFilter<"ProductUnit"> | Date | string | null
    lastServiceDate?: DateTimeNullableWithAggregatesFilter<"ProductUnit"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductUnit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductUnit"> | Date | string
  }

  export type UnitHistoryWhereInput = {
    AND?: UnitHistoryWhereInput | UnitHistoryWhereInput[]
    OR?: UnitHistoryWhereInput[]
    NOT?: UnitHistoryWhereInput | UnitHistoryWhereInput[]
    id?: UuidFilter<"UnitHistory"> | string
    unitId?: UuidFilter<"UnitHistory"> | string
    oldStatus?: StringNullableFilter<"UnitHistory"> | string | null
    newStatus?: StringFilter<"UnitHistory"> | string
    oldCondition?: StringNullableFilter<"UnitHistory"> | string | null
    newCondition?: StringNullableFilter<"UnitHistory"> | string | null
    details?: StringNullableFilter<"UnitHistory"> | string | null
    createdAt?: DateTimeFilter<"UnitHistory"> | Date | string
    userId?: UuidNullableFilter<"UnitHistory"> | string | null
    unit?: XOR<ProductUnitScalarRelationFilter, ProductUnitWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type UnitHistoryOrderByWithRelationInput = {
    id?: SortOrder
    unitId?: SortOrder
    oldStatus?: SortOrderInput | SortOrder
    newStatus?: SortOrder
    oldCondition?: SortOrderInput | SortOrder
    newCondition?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    unit?: ProductUnitOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UnitHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UnitHistoryWhereInput | UnitHistoryWhereInput[]
    OR?: UnitHistoryWhereInput[]
    NOT?: UnitHistoryWhereInput | UnitHistoryWhereInput[]
    unitId?: UuidFilter<"UnitHistory"> | string
    oldStatus?: StringNullableFilter<"UnitHistory"> | string | null
    newStatus?: StringFilter<"UnitHistory"> | string
    oldCondition?: StringNullableFilter<"UnitHistory"> | string | null
    newCondition?: StringNullableFilter<"UnitHistory"> | string | null
    details?: StringNullableFilter<"UnitHistory"> | string | null
    createdAt?: DateTimeFilter<"UnitHistory"> | Date | string
    userId?: UuidNullableFilter<"UnitHistory"> | string | null
    unit?: XOR<ProductUnitScalarRelationFilter, ProductUnitWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type UnitHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    unitId?: SortOrder
    oldStatus?: SortOrderInput | SortOrder
    newStatus?: SortOrder
    oldCondition?: SortOrderInput | SortOrder
    newCondition?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: UnitHistoryCountOrderByAggregateInput
    _max?: UnitHistoryMaxOrderByAggregateInput
    _min?: UnitHistoryMinOrderByAggregateInput
  }

  export type UnitHistoryScalarWhereWithAggregatesInput = {
    AND?: UnitHistoryScalarWhereWithAggregatesInput | UnitHistoryScalarWhereWithAggregatesInput[]
    OR?: UnitHistoryScalarWhereWithAggregatesInput[]
    NOT?: UnitHistoryScalarWhereWithAggregatesInput | UnitHistoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UnitHistory"> | string
    unitId?: UuidWithAggregatesFilter<"UnitHistory"> | string
    oldStatus?: StringNullableWithAggregatesFilter<"UnitHistory"> | string | null
    newStatus?: StringWithAggregatesFilter<"UnitHistory"> | string
    oldCondition?: StringNullableWithAggregatesFilter<"UnitHistory"> | string | null
    newCondition?: StringNullableWithAggregatesFilter<"UnitHistory"> | string | null
    details?: StringNullableWithAggregatesFilter<"UnitHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UnitHistory"> | Date | string
    userId?: UuidNullableWithAggregatesFilter<"UnitHistory"> | string | null
  }

  export type SystemNotificationWhereInput = {
    AND?: SystemNotificationWhereInput | SystemNotificationWhereInput[]
    OR?: SystemNotificationWhereInput[]
    NOT?: SystemNotificationWhereInput | SystemNotificationWhereInput[]
    id?: UuidFilter<"SystemNotification"> | string
    type?: StringFilter<"SystemNotification"> | string
    title?: StringFilter<"SystemNotification"> | string
    message?: StringFilter<"SystemNotification"> | string
    isRead?: BoolFilter<"SystemNotification"> | boolean
    userId?: UuidNullableFilter<"SystemNotification"> | string | null
    entityId?: UuidNullableFilter<"SystemNotification"> | string | null
    entityType?: StringNullableFilter<"SystemNotification"> | string | null
    relatedType?: StringNullableFilter<"SystemNotification"> | string | null
    createdAt?: DateTimeNullableFilter<"SystemNotification"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type SystemNotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    userId?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    entityType?: SortOrderInput | SortOrder
    relatedType?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SystemNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemNotificationWhereInput | SystemNotificationWhereInput[]
    OR?: SystemNotificationWhereInput[]
    NOT?: SystemNotificationWhereInput | SystemNotificationWhereInput[]
    type?: StringFilter<"SystemNotification"> | string
    title?: StringFilter<"SystemNotification"> | string
    message?: StringFilter<"SystemNotification"> | string
    isRead?: BoolFilter<"SystemNotification"> | boolean
    userId?: UuidNullableFilter<"SystemNotification"> | string | null
    entityId?: UuidNullableFilter<"SystemNotification"> | string | null
    entityType?: StringNullableFilter<"SystemNotification"> | string | null
    relatedType?: StringNullableFilter<"SystemNotification"> | string | null
    createdAt?: DateTimeNullableFilter<"SystemNotification"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type SystemNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    userId?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    entityType?: SortOrderInput | SortOrder
    relatedType?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: SystemNotificationCountOrderByAggregateInput
    _max?: SystemNotificationMaxOrderByAggregateInput
    _min?: SystemNotificationMinOrderByAggregateInput
  }

  export type SystemNotificationScalarWhereWithAggregatesInput = {
    AND?: SystemNotificationScalarWhereWithAggregatesInput | SystemNotificationScalarWhereWithAggregatesInput[]
    OR?: SystemNotificationScalarWhereWithAggregatesInput[]
    NOT?: SystemNotificationScalarWhereWithAggregatesInput | SystemNotificationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SystemNotification"> | string
    type?: StringWithAggregatesFilter<"SystemNotification"> | string
    title?: StringWithAggregatesFilter<"SystemNotification"> | string
    message?: StringWithAggregatesFilter<"SystemNotification"> | string
    isRead?: BoolWithAggregatesFilter<"SystemNotification"> | boolean
    userId?: UuidNullableWithAggregatesFilter<"SystemNotification"> | string | null
    entityId?: UuidNullableWithAggregatesFilter<"SystemNotification"> | string | null
    entityType?: StringNullableWithAggregatesFilter<"SystemNotification"> | string | null
    relatedType?: StringNullableWithAggregatesFilter<"SystemNotification"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"SystemNotification"> | Date | string | null
  }

  export type RentalItemWhereInput = {
    AND?: RentalItemWhereInput | RentalItemWhereInput[]
    OR?: RentalItemWhereInput[]
    NOT?: RentalItemWhereInput | RentalItemWhereInput[]
    id?: UuidFilter<"RentalItem"> | string
    orderId?: UuidFilter<"RentalItem"> | string
    variantId?: UuidNullableFilter<"RentalItem"> | string | null
    packageId?: UuidNullableFilter<"RentalItem"> | string | null
    quantity?: IntNullableFilter<"RentalItem"> | number | null
    createdAt?: DateTimeNullableFilter<"RentalItem"> | Date | string | null
    unitId?: UuidNullableFilter<"RentalItem"> | string | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    rentalPackage?: XOR<RentalPackageNullableScalarRelationFilter, RentalPackageWhereInput> | null
    variant?: XOR<ProductVariantNullableScalarRelationFilter, ProductVariantWhereInput> | null
    unit?: XOR<ProductUnitNullableScalarRelationFilter, ProductUnitWhereInput> | null
    deliveryItems?: DeliveryItemListRelationFilter
  }

  export type RentalItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    variantId?: SortOrderInput | SortOrder
    packageId?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    unitId?: SortOrderInput | SortOrder
    order?: OrderOrderByWithRelationInput
    rentalPackage?: RentalPackageOrderByWithRelationInput
    variant?: ProductVariantOrderByWithRelationInput
    unit?: ProductUnitOrderByWithRelationInput
    deliveryItems?: DeliveryItemOrderByRelationAggregateInput
  }

  export type RentalItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RentalItemWhereInput | RentalItemWhereInput[]
    OR?: RentalItemWhereInput[]
    NOT?: RentalItemWhereInput | RentalItemWhereInput[]
    orderId?: UuidFilter<"RentalItem"> | string
    variantId?: UuidNullableFilter<"RentalItem"> | string | null
    packageId?: UuidNullableFilter<"RentalItem"> | string | null
    quantity?: IntNullableFilter<"RentalItem"> | number | null
    createdAt?: DateTimeNullableFilter<"RentalItem"> | Date | string | null
    unitId?: UuidNullableFilter<"RentalItem"> | string | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    rentalPackage?: XOR<RentalPackageNullableScalarRelationFilter, RentalPackageWhereInput> | null
    variant?: XOR<ProductVariantNullableScalarRelationFilter, ProductVariantWhereInput> | null
    unit?: XOR<ProductUnitNullableScalarRelationFilter, ProductUnitWhereInput> | null
    deliveryItems?: DeliveryItemListRelationFilter
  }, "id">

  export type RentalItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    variantId?: SortOrderInput | SortOrder
    packageId?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    unitId?: SortOrderInput | SortOrder
    _count?: RentalItemCountOrderByAggregateInput
    _avg?: RentalItemAvgOrderByAggregateInput
    _max?: RentalItemMaxOrderByAggregateInput
    _min?: RentalItemMinOrderByAggregateInput
    _sum?: RentalItemSumOrderByAggregateInput
  }

  export type RentalItemScalarWhereWithAggregatesInput = {
    AND?: RentalItemScalarWhereWithAggregatesInput | RentalItemScalarWhereWithAggregatesInput[]
    OR?: RentalItemScalarWhereWithAggregatesInput[]
    NOT?: RentalItemScalarWhereWithAggregatesInput | RentalItemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"RentalItem"> | string
    orderId?: UuidWithAggregatesFilter<"RentalItem"> | string
    variantId?: UuidNullableWithAggregatesFilter<"RentalItem"> | string | null
    packageId?: UuidNullableWithAggregatesFilter<"RentalItem"> | string | null
    quantity?: IntNullableWithAggregatesFilter<"RentalItem"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"RentalItem"> | Date | string | null
    unitId?: UuidNullableWithAggregatesFilter<"RentalItem"> | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    plainPassword?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    whatsapp?: StringFilter<"User"> | string
    baliAddress?: StringNullableFilter<"User"> | string | null
    mapsAddressLink?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isVerified?: BoolFilter<"User"> | boolean
    resetPasswordExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    resetPasswordToken?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    profileImage?: StringNullableFilter<"User"> | string | null
    identityFile?: StringNullableFilter<"User"> | string | null
    identityType?: StringNullableFilter<"User"> | string | null
    activityLogs?: ActivityLogListRelationFilter
    inventoryResolutions?: InventorySyncLogListRelationFilter
    inventoryUpdates?: InventorySyncLogListRelationFilter
    invoices?: InvoiceListRelationFilter
    orders_orders_payment_confirmed_byTousers?: OrderListRelationFilter
    orders?: OrderListRelationFilter
    workerAttendance?: WorkerAttendanceListRelationFilter
    claimedDeliveries?: DeliveryListRelationFilter
    deliveryLogs?: DeliveryLogListRelationFilter
    deliveryEditLogs?: DeliveryEditLogListRelationFilter
    sentNotifications?: WorkerNotificationListRelationFilter
    receivedNotifications?: WorkerNotificationListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    chatGroupMemberships?: ChatGroupMemberListRelationFilter
    sentGroupMessages?: GroupMessageListRelationFilter
    notificationDismissals?: NotificationDismissalListRelationFilter
    systemNotifications?: SystemNotificationListRelationFilter
    verifiedTransactions?: PaymentTransactionListRelationFilter
    unitActions?: UnitHistoryListRelationFilter
    aiActionApprovals?: AiActionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    plainPassword?: SortOrderInput | SortOrder
    email?: SortOrder
    fullName?: SortOrder
    whatsapp?: SortOrder
    baliAddress?: SortOrderInput | SortOrder
    mapsAddressLink?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    resetPasswordExpires?: SortOrderInput | SortOrder
    resetPasswordToken?: SortOrderInput | SortOrder
    isActive?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    identityFile?: SortOrderInput | SortOrder
    identityType?: SortOrderInput | SortOrder
    activityLogs?: ActivityLogOrderByRelationAggregateInput
    inventoryResolutions?: InventorySyncLogOrderByRelationAggregateInput
    inventoryUpdates?: InventorySyncLogOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    orders_orders_payment_confirmed_byTousers?: OrderOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    workerAttendance?: WorkerAttendanceOrderByRelationAggregateInput
    claimedDeliveries?: DeliveryOrderByRelationAggregateInput
    deliveryLogs?: DeliveryLogOrderByRelationAggregateInput
    deliveryEditLogs?: DeliveryEditLogOrderByRelationAggregateInput
    sentNotifications?: WorkerNotificationOrderByRelationAggregateInput
    receivedNotifications?: WorkerNotificationOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    receivedMessages?: MessageOrderByRelationAggregateInput
    chatGroupMemberships?: ChatGroupMemberOrderByRelationAggregateInput
    sentGroupMessages?: GroupMessageOrderByRelationAggregateInput
    notificationDismissals?: NotificationDismissalOrderByRelationAggregateInput
    systemNotifications?: SystemNotificationOrderByRelationAggregateInput
    verifiedTransactions?: PaymentTransactionOrderByRelationAggregateInput
    unitActions?: UnitHistoryOrderByRelationAggregateInput
    aiActionApprovals?: AiActionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    plainPassword?: StringNullableFilter<"User"> | string | null
    fullName?: StringFilter<"User"> | string
    whatsapp?: StringFilter<"User"> | string
    baliAddress?: StringNullableFilter<"User"> | string | null
    mapsAddressLink?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isVerified?: BoolFilter<"User"> | boolean
    resetPasswordExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    resetPasswordToken?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    profileImage?: StringNullableFilter<"User"> | string | null
    identityFile?: StringNullableFilter<"User"> | string | null
    identityType?: StringNullableFilter<"User"> | string | null
    activityLogs?: ActivityLogListRelationFilter
    inventoryResolutions?: InventorySyncLogListRelationFilter
    inventoryUpdates?: InventorySyncLogListRelationFilter
    invoices?: InvoiceListRelationFilter
    orders_orders_payment_confirmed_byTousers?: OrderListRelationFilter
    orders?: OrderListRelationFilter
    workerAttendance?: WorkerAttendanceListRelationFilter
    claimedDeliveries?: DeliveryListRelationFilter
    deliveryLogs?: DeliveryLogListRelationFilter
    deliveryEditLogs?: DeliveryEditLogListRelationFilter
    sentNotifications?: WorkerNotificationListRelationFilter
    receivedNotifications?: WorkerNotificationListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    chatGroupMemberships?: ChatGroupMemberListRelationFilter
    sentGroupMessages?: GroupMessageListRelationFilter
    notificationDismissals?: NotificationDismissalListRelationFilter
    systemNotifications?: SystemNotificationListRelationFilter
    verifiedTransactions?: PaymentTransactionListRelationFilter
    unitActions?: UnitHistoryListRelationFilter
    aiActionApprovals?: AiActionListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    plainPassword?: SortOrderInput | SortOrder
    email?: SortOrder
    fullName?: SortOrder
    whatsapp?: SortOrder
    baliAddress?: SortOrderInput | SortOrder
    mapsAddressLink?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    resetPasswordExpires?: SortOrderInput | SortOrder
    resetPasswordToken?: SortOrderInput | SortOrder
    isActive?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    identityFile?: SortOrderInput | SortOrder
    identityType?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    plainPassword?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    fullName?: StringWithAggregatesFilter<"User"> | string
    whatsapp?: StringWithAggregatesFilter<"User"> | string
    baliAddress?: StringNullableWithAggregatesFilter<"User"> | string | null
    mapsAddressLink?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    resetPasswordExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    resetPasswordToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    profileImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    identityFile?: StringNullableWithAggregatesFilter<"User"> | string | null
    identityType?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ChatGroupWhereInput = {
    AND?: ChatGroupWhereInput | ChatGroupWhereInput[]
    OR?: ChatGroupWhereInput[]
    NOT?: ChatGroupWhereInput | ChatGroupWhereInput[]
    id?: UuidFilter<"ChatGroup"> | string
    name?: StringFilter<"ChatGroup"> | string
    type?: StringFilter<"ChatGroup"> | string
    createdAt?: DateTimeFilter<"ChatGroup"> | Date | string
    updatedAt?: DateTimeFilter<"ChatGroup"> | Date | string
    members?: ChatGroupMemberListRelationFilter
    messages?: GroupMessageListRelationFilter
  }

  export type ChatGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: ChatGroupMemberOrderByRelationAggregateInput
    messages?: GroupMessageOrderByRelationAggregateInput
  }

  export type ChatGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatGroupWhereInput | ChatGroupWhereInput[]
    OR?: ChatGroupWhereInput[]
    NOT?: ChatGroupWhereInput | ChatGroupWhereInput[]
    name?: StringFilter<"ChatGroup"> | string
    type?: StringFilter<"ChatGroup"> | string
    createdAt?: DateTimeFilter<"ChatGroup"> | Date | string
    updatedAt?: DateTimeFilter<"ChatGroup"> | Date | string
    members?: ChatGroupMemberListRelationFilter
    messages?: GroupMessageListRelationFilter
  }, "id">

  export type ChatGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChatGroupCountOrderByAggregateInput
    _max?: ChatGroupMaxOrderByAggregateInput
    _min?: ChatGroupMinOrderByAggregateInput
  }

  export type ChatGroupScalarWhereWithAggregatesInput = {
    AND?: ChatGroupScalarWhereWithAggregatesInput | ChatGroupScalarWhereWithAggregatesInput[]
    OR?: ChatGroupScalarWhereWithAggregatesInput[]
    NOT?: ChatGroupScalarWhereWithAggregatesInput | ChatGroupScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ChatGroup"> | string
    name?: StringWithAggregatesFilter<"ChatGroup"> | string
    type?: StringWithAggregatesFilter<"ChatGroup"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChatGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChatGroup"> | Date | string
  }

  export type ChatGroupMemberWhereInput = {
    AND?: ChatGroupMemberWhereInput | ChatGroupMemberWhereInput[]
    OR?: ChatGroupMemberWhereInput[]
    NOT?: ChatGroupMemberWhereInput | ChatGroupMemberWhereInput[]
    id?: UuidFilter<"ChatGroupMember"> | string
    groupId?: UuidFilter<"ChatGroupMember"> | string
    userId?: UuidFilter<"ChatGroupMember"> | string
    role?: StringFilter<"ChatGroupMember"> | string
    joinedAt?: DateTimeFilter<"ChatGroupMember"> | Date | string
    group?: XOR<ChatGroupScalarRelationFilter, ChatGroupWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ChatGroupMemberOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    group?: ChatGroupOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ChatGroupMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    groupId_userId?: ChatGroupMemberGroupIdUserIdCompoundUniqueInput
    AND?: ChatGroupMemberWhereInput | ChatGroupMemberWhereInput[]
    OR?: ChatGroupMemberWhereInput[]
    NOT?: ChatGroupMemberWhereInput | ChatGroupMemberWhereInput[]
    groupId?: UuidFilter<"ChatGroupMember"> | string
    userId?: UuidFilter<"ChatGroupMember"> | string
    role?: StringFilter<"ChatGroupMember"> | string
    joinedAt?: DateTimeFilter<"ChatGroupMember"> | Date | string
    group?: XOR<ChatGroupScalarRelationFilter, ChatGroupWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "groupId_userId">

  export type ChatGroupMemberOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    _count?: ChatGroupMemberCountOrderByAggregateInput
    _max?: ChatGroupMemberMaxOrderByAggregateInput
    _min?: ChatGroupMemberMinOrderByAggregateInput
  }

  export type ChatGroupMemberScalarWhereWithAggregatesInput = {
    AND?: ChatGroupMemberScalarWhereWithAggregatesInput | ChatGroupMemberScalarWhereWithAggregatesInput[]
    OR?: ChatGroupMemberScalarWhereWithAggregatesInput[]
    NOT?: ChatGroupMemberScalarWhereWithAggregatesInput | ChatGroupMemberScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ChatGroupMember"> | string
    groupId?: UuidWithAggregatesFilter<"ChatGroupMember"> | string
    userId?: UuidWithAggregatesFilter<"ChatGroupMember"> | string
    role?: StringWithAggregatesFilter<"ChatGroupMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"ChatGroupMember"> | Date | string
  }

  export type GroupMessageWhereInput = {
    AND?: GroupMessageWhereInput | GroupMessageWhereInput[]
    OR?: GroupMessageWhereInput[]
    NOT?: GroupMessageWhereInput | GroupMessageWhereInput[]
    id?: UuidFilter<"GroupMessage"> | string
    groupId?: UuidFilter<"GroupMessage"> | string
    senderId?: UuidFilter<"GroupMessage"> | string
    content?: StringFilter<"GroupMessage"> | string
    createdAt?: DateTimeFilter<"GroupMessage"> | Date | string
    group?: XOR<ChatGroupScalarRelationFilter, ChatGroupWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GroupMessageOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    group?: ChatGroupOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type GroupMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GroupMessageWhereInput | GroupMessageWhereInput[]
    OR?: GroupMessageWhereInput[]
    NOT?: GroupMessageWhereInput | GroupMessageWhereInput[]
    groupId?: UuidFilter<"GroupMessage"> | string
    senderId?: UuidFilter<"GroupMessage"> | string
    content?: StringFilter<"GroupMessage"> | string
    createdAt?: DateTimeFilter<"GroupMessage"> | Date | string
    group?: XOR<ChatGroupScalarRelationFilter, ChatGroupWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type GroupMessageOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: GroupMessageCountOrderByAggregateInput
    _max?: GroupMessageMaxOrderByAggregateInput
    _min?: GroupMessageMinOrderByAggregateInput
  }

  export type GroupMessageScalarWhereWithAggregatesInput = {
    AND?: GroupMessageScalarWhereWithAggregatesInput | GroupMessageScalarWhereWithAggregatesInput[]
    OR?: GroupMessageScalarWhereWithAggregatesInput[]
    NOT?: GroupMessageScalarWhereWithAggregatesInput | GroupMessageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"GroupMessage"> | string
    groupId?: UuidWithAggregatesFilter<"GroupMessage"> | string
    senderId?: UuidWithAggregatesFilter<"GroupMessage"> | string
    content?: StringWithAggregatesFilter<"GroupMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GroupMessage"> | Date | string
  }

  export type SiteSettingWhereInput = {
    AND?: SiteSettingWhereInput | SiteSettingWhereInput[]
    OR?: SiteSettingWhereInput[]
    NOT?: SiteSettingWhereInput | SiteSettingWhereInput[]
    key?: StringFilter<"SiteSetting"> | string
    value?: JsonNullableFilter<"SiteSetting">
    section?: StringNullableFilter<"SiteSetting"> | string | null
    created_at?: DateTimeFilter<"SiteSetting"> | Date | string
    updated_at?: DateTimeFilter<"SiteSetting"> | Date | string
  }

  export type SiteSettingOrderByWithRelationInput = {
    key?: SortOrder
    value?: SortOrderInput | SortOrder
    section?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SiteSettingWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: SiteSettingWhereInput | SiteSettingWhereInput[]
    OR?: SiteSettingWhereInput[]
    NOT?: SiteSettingWhereInput | SiteSettingWhereInput[]
    value?: JsonNullableFilter<"SiteSetting">
    section?: StringNullableFilter<"SiteSetting"> | string | null
    created_at?: DateTimeFilter<"SiteSetting"> | Date | string
    updated_at?: DateTimeFilter<"SiteSetting"> | Date | string
  }, "key">

  export type SiteSettingOrderByWithAggregationInput = {
    key?: SortOrder
    value?: SortOrderInput | SortOrder
    section?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SiteSettingCountOrderByAggregateInput
    _max?: SiteSettingMaxOrderByAggregateInput
    _min?: SiteSettingMinOrderByAggregateInput
  }

  export type SiteSettingScalarWhereWithAggregatesInput = {
    AND?: SiteSettingScalarWhereWithAggregatesInput | SiteSettingScalarWhereWithAggregatesInput[]
    OR?: SiteSettingScalarWhereWithAggregatesInput[]
    NOT?: SiteSettingScalarWhereWithAggregatesInput | SiteSettingScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"SiteSetting"> | string
    value?: JsonNullableWithAggregatesFilter<"SiteSetting">
    section?: StringNullableWithAggregatesFilter<"SiteSetting"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"SiteSetting"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"SiteSetting"> | Date | string
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: UuidFilter<"ActivityLog"> | string
    action?: StringFilter<"ActivityLog"> | string
    entity?: StringFilter<"ActivityLog"> | string
    details?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    userId?: UuidNullableFilter<"ActivityLog"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    action?: StringFilter<"ActivityLog"> | string
    entity?: StringFilter<"ActivityLog"> | string
    details?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    userId?: UuidNullableFilter<"ActivityLog"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ActivityLog"> | string
    action?: StringWithAggregatesFilter<"ActivityLog"> | string
    entity?: StringWithAggregatesFilter<"ActivityLog"> | string
    details?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
    userId?: UuidNullableWithAggregatesFilter<"ActivityLog"> | string | null
  }

  export type WorkerAttendanceWhereInput = {
    AND?: WorkerAttendanceWhereInput | WorkerAttendanceWhereInput[]
    OR?: WorkerAttendanceWhereInput[]
    NOT?: WorkerAttendanceWhereInput | WorkerAttendanceWhereInput[]
    id?: UuidFilter<"WorkerAttendance"> | string
    workerId?: UuidFilter<"WorkerAttendance"> | string
    date?: DateTimeFilter<"WorkerAttendance"> | Date | string
    status?: Enumattendance_statusNullableFilter<"WorkerAttendance"> | $Enums.attendance_status | null
    checkInTime?: DateTimeNullableFilter<"WorkerAttendance"> | Date | string | null
    checkOutTime?: DateTimeNullableFilter<"WorkerAttendance"> | Date | string | null
    notes?: StringNullableFilter<"WorkerAttendance"> | string | null
    createdAt?: DateTimeNullableFilter<"WorkerAttendance"> | Date | string | null
    worker?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WorkerAttendanceOrderByWithRelationInput = {
    id?: SortOrder
    workerId?: SortOrder
    date?: SortOrder
    status?: SortOrderInput | SortOrder
    checkInTime?: SortOrderInput | SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    worker?: UserOrderByWithRelationInput
  }

  export type WorkerAttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workerId_date?: WorkerAttendanceWorkerIdDateCompoundUniqueInput
    AND?: WorkerAttendanceWhereInput | WorkerAttendanceWhereInput[]
    OR?: WorkerAttendanceWhereInput[]
    NOT?: WorkerAttendanceWhereInput | WorkerAttendanceWhereInput[]
    workerId?: UuidFilter<"WorkerAttendance"> | string
    date?: DateTimeFilter<"WorkerAttendance"> | Date | string
    status?: Enumattendance_statusNullableFilter<"WorkerAttendance"> | $Enums.attendance_status | null
    checkInTime?: DateTimeNullableFilter<"WorkerAttendance"> | Date | string | null
    checkOutTime?: DateTimeNullableFilter<"WorkerAttendance"> | Date | string | null
    notes?: StringNullableFilter<"WorkerAttendance"> | string | null
    createdAt?: DateTimeNullableFilter<"WorkerAttendance"> | Date | string | null
    worker?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "workerId_date">

  export type WorkerAttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    workerId?: SortOrder
    date?: SortOrder
    status?: SortOrderInput | SortOrder
    checkInTime?: SortOrderInput | SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: WorkerAttendanceCountOrderByAggregateInput
    _max?: WorkerAttendanceMaxOrderByAggregateInput
    _min?: WorkerAttendanceMinOrderByAggregateInput
  }

  export type WorkerAttendanceScalarWhereWithAggregatesInput = {
    AND?: WorkerAttendanceScalarWhereWithAggregatesInput | WorkerAttendanceScalarWhereWithAggregatesInput[]
    OR?: WorkerAttendanceScalarWhereWithAggregatesInput[]
    NOT?: WorkerAttendanceScalarWhereWithAggregatesInput | WorkerAttendanceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"WorkerAttendance"> | string
    workerId?: UuidWithAggregatesFilter<"WorkerAttendance"> | string
    date?: DateTimeWithAggregatesFilter<"WorkerAttendance"> | Date | string
    status?: Enumattendance_statusNullableWithAggregatesFilter<"WorkerAttendance"> | $Enums.attendance_status | null
    checkInTime?: DateTimeNullableWithAggregatesFilter<"WorkerAttendance"> | Date | string | null
    checkOutTime?: DateTimeNullableWithAggregatesFilter<"WorkerAttendance"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"WorkerAttendance"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"WorkerAttendance"> | Date | string | null
  }

  export type InventorySyncLogWhereInput = {
    AND?: InventorySyncLogWhereInput | InventorySyncLogWhereInput[]
    OR?: InventorySyncLogWhereInput[]
    NOT?: InventorySyncLogWhereInput | InventorySyncLogWhereInput[]
    id?: UuidFilter<"InventorySyncLog"> | string
    productId?: UuidFilter<"InventorySyncLog"> | string
    oldQuantity?: IntFilter<"InventorySyncLog"> | number
    newQuantity?: IntFilter<"InventorySyncLog"> | number
    updatedBy?: UuidFilter<"InventorySyncLog"> | string
    source?: Enuminventory_sourceFilter<"InventorySyncLog"> | $Enums.inventory_source
    conflict?: BoolNullableFilter<"InventorySyncLog"> | boolean | null
    resolved?: BoolNullableFilter<"InventorySyncLog"> | boolean | null
    resolvedBy?: UuidNullableFilter<"InventorySyncLog"> | string | null
    resolvedAt?: DateTimeNullableFilter<"InventorySyncLog"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"InventorySyncLog"> | Date | string | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    resolvedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InventorySyncLogOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    oldQuantity?: SortOrder
    newQuantity?: SortOrder
    updatedBy?: SortOrder
    source?: SortOrder
    conflict?: SortOrderInput | SortOrder
    resolved?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    product?: ProductOrderByWithRelationInput
    resolvedByUser?: UserOrderByWithRelationInput
    updatedByUser?: UserOrderByWithRelationInput
  }

  export type InventorySyncLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventorySyncLogWhereInput | InventorySyncLogWhereInput[]
    OR?: InventorySyncLogWhereInput[]
    NOT?: InventorySyncLogWhereInput | InventorySyncLogWhereInput[]
    productId?: UuidFilter<"InventorySyncLog"> | string
    oldQuantity?: IntFilter<"InventorySyncLog"> | number
    newQuantity?: IntFilter<"InventorySyncLog"> | number
    updatedBy?: UuidFilter<"InventorySyncLog"> | string
    source?: Enuminventory_sourceFilter<"InventorySyncLog"> | $Enums.inventory_source
    conflict?: BoolNullableFilter<"InventorySyncLog"> | boolean | null
    resolved?: BoolNullableFilter<"InventorySyncLog"> | boolean | null
    resolvedBy?: UuidNullableFilter<"InventorySyncLog"> | string | null
    resolvedAt?: DateTimeNullableFilter<"InventorySyncLog"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"InventorySyncLog"> | Date | string | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    resolvedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type InventorySyncLogOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    oldQuantity?: SortOrder
    newQuantity?: SortOrder
    updatedBy?: SortOrder
    source?: SortOrder
    conflict?: SortOrderInput | SortOrder
    resolved?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: InventorySyncLogCountOrderByAggregateInput
    _avg?: InventorySyncLogAvgOrderByAggregateInput
    _max?: InventorySyncLogMaxOrderByAggregateInput
    _min?: InventorySyncLogMinOrderByAggregateInput
    _sum?: InventorySyncLogSumOrderByAggregateInput
  }

  export type InventorySyncLogScalarWhereWithAggregatesInput = {
    AND?: InventorySyncLogScalarWhereWithAggregatesInput | InventorySyncLogScalarWhereWithAggregatesInput[]
    OR?: InventorySyncLogScalarWhereWithAggregatesInput[]
    NOT?: InventorySyncLogScalarWhereWithAggregatesInput | InventorySyncLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"InventorySyncLog"> | string
    productId?: UuidWithAggregatesFilter<"InventorySyncLog"> | string
    oldQuantity?: IntWithAggregatesFilter<"InventorySyncLog"> | number
    newQuantity?: IntWithAggregatesFilter<"InventorySyncLog"> | number
    updatedBy?: UuidWithAggregatesFilter<"InventorySyncLog"> | string
    source?: Enuminventory_sourceWithAggregatesFilter<"InventorySyncLog"> | $Enums.inventory_source
    conflict?: BoolNullableWithAggregatesFilter<"InventorySyncLog"> | boolean | null
    resolved?: BoolNullableWithAggregatesFilter<"InventorySyncLog"> | boolean | null
    resolvedBy?: UuidNullableWithAggregatesFilter<"InventorySyncLog"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"InventorySyncLog"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"InventorySyncLog"> | Date | string | null
  }

  export type WorkerNotificationWhereInput = {
    AND?: WorkerNotificationWhereInput | WorkerNotificationWhereInput[]
    OR?: WorkerNotificationWhereInput[]
    NOT?: WorkerNotificationWhereInput | WorkerNotificationWhereInput[]
    id?: UuidFilter<"WorkerNotification"> | string
    workerId?: UuidFilter<"WorkerNotification"> | string
    fromAdminId?: UuidNullableFilter<"WorkerNotification"> | string | null
    type?: StringFilter<"WorkerNotification"> | string
    title?: StringFilter<"WorkerNotification"> | string
    message?: StringFilter<"WorkerNotification"> | string
    isRead?: BoolNullableFilter<"WorkerNotification"> | boolean | null
    createdAt?: DateTimeNullableFilter<"WorkerNotification"> | Date | string | null
    fromAdmin?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    worker?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WorkerNotificationOrderByWithRelationInput = {
    id?: SortOrder
    workerId?: SortOrder
    fromAdminId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    fromAdmin?: UserOrderByWithRelationInput
    worker?: UserOrderByWithRelationInput
  }

  export type WorkerNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkerNotificationWhereInput | WorkerNotificationWhereInput[]
    OR?: WorkerNotificationWhereInput[]
    NOT?: WorkerNotificationWhereInput | WorkerNotificationWhereInput[]
    workerId?: UuidFilter<"WorkerNotification"> | string
    fromAdminId?: UuidNullableFilter<"WorkerNotification"> | string | null
    type?: StringFilter<"WorkerNotification"> | string
    title?: StringFilter<"WorkerNotification"> | string
    message?: StringFilter<"WorkerNotification"> | string
    isRead?: BoolNullableFilter<"WorkerNotification"> | boolean | null
    createdAt?: DateTimeNullableFilter<"WorkerNotification"> | Date | string | null
    fromAdmin?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    worker?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type WorkerNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    workerId?: SortOrder
    fromAdminId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: WorkerNotificationCountOrderByAggregateInput
    _max?: WorkerNotificationMaxOrderByAggregateInput
    _min?: WorkerNotificationMinOrderByAggregateInput
  }

  export type WorkerNotificationScalarWhereWithAggregatesInput = {
    AND?: WorkerNotificationScalarWhereWithAggregatesInput | WorkerNotificationScalarWhereWithAggregatesInput[]
    OR?: WorkerNotificationScalarWhereWithAggregatesInput[]
    NOT?: WorkerNotificationScalarWhereWithAggregatesInput | WorkerNotificationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"WorkerNotification"> | string
    workerId?: UuidWithAggregatesFilter<"WorkerNotification"> | string
    fromAdminId?: UuidNullableWithAggregatesFilter<"WorkerNotification"> | string | null
    type?: StringWithAggregatesFilter<"WorkerNotification"> | string
    title?: StringWithAggregatesFilter<"WorkerNotification"> | string
    message?: StringWithAggregatesFilter<"WorkerNotification"> | string
    isRead?: BoolNullableWithAggregatesFilter<"WorkerNotification"> | boolean | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"WorkerNotification"> | Date | string | null
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: UuidFilter<"Message"> | string
    senderId?: UuidFilter<"Message"> | string
    receiverId?: UuidFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    sender?: UserOrderByWithRelationInput
    receiver?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    senderId?: UuidFilter<"Message"> | string
    receiverId?: UuidFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Message"> | string
    senderId?: UuidWithAggregatesFilter<"Message"> | string
    receiverId?: UuidWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    isRead?: BoolWithAggregatesFilter<"Message"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type NotificationDismissalWhereInput = {
    AND?: NotificationDismissalWhereInput | NotificationDismissalWhereInput[]
    OR?: NotificationDismissalWhereInput[]
    NOT?: NotificationDismissalWhereInput | NotificationDismissalWhereInput[]
    id?: UuidFilter<"NotificationDismissal"> | string
    userId?: UuidFilter<"NotificationDismissal"> | string
    entityId?: UuidFilter<"NotificationDismissal"> | string
    entityType?: StringFilter<"NotificationDismissal"> | string
    createdAt?: DateTimeFilter<"NotificationDismissal"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationDismissalOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationDismissalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_entityId_entityType?: NotificationDismissalUserIdEntityIdEntityTypeCompoundUniqueInput
    AND?: NotificationDismissalWhereInput | NotificationDismissalWhereInput[]
    OR?: NotificationDismissalWhereInput[]
    NOT?: NotificationDismissalWhereInput | NotificationDismissalWhereInput[]
    userId?: UuidFilter<"NotificationDismissal"> | string
    entityId?: UuidFilter<"NotificationDismissal"> | string
    entityType?: StringFilter<"NotificationDismissal"> | string
    createdAt?: DateTimeFilter<"NotificationDismissal"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_entityId_entityType">

  export type NotificationDismissalOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationDismissalCountOrderByAggregateInput
    _max?: NotificationDismissalMaxOrderByAggregateInput
    _min?: NotificationDismissalMinOrderByAggregateInput
  }

  export type NotificationDismissalScalarWhereWithAggregatesInput = {
    AND?: NotificationDismissalScalarWhereWithAggregatesInput | NotificationDismissalScalarWhereWithAggregatesInput[]
    OR?: NotificationDismissalScalarWhereWithAggregatesInput[]
    NOT?: NotificationDismissalScalarWhereWithAggregatesInput | NotificationDismissalScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"NotificationDismissal"> | string
    userId?: UuidWithAggregatesFilter<"NotificationDismissal"> | string
    entityId?: UuidWithAggregatesFilter<"NotificationDismissal"> | string
    entityType?: StringWithAggregatesFilter<"NotificationDismissal"> | string
    createdAt?: DateTimeWithAggregatesFilter<"NotificationDismissal"> | Date | string
  }

  export type SystemJobLogWhereInput = {
    AND?: SystemJobLogWhereInput | SystemJobLogWhereInput[]
    OR?: SystemJobLogWhereInput[]
    NOT?: SystemJobLogWhereInput | SystemJobLogWhereInput[]
    id?: UuidFilter<"SystemJobLog"> | string
    jobName?: StringFilter<"SystemJobLog"> | string
    status?: StringFilter<"SystemJobLog"> | string
    message?: StringNullableFilter<"SystemJobLog"> | string | null
    createdAt?: DateTimeFilter<"SystemJobLog"> | Date | string
  }

  export type SystemJobLogOrderByWithRelationInput = {
    id?: SortOrder
    jobName?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type SystemJobLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemJobLogWhereInput | SystemJobLogWhereInput[]
    OR?: SystemJobLogWhereInput[]
    NOT?: SystemJobLogWhereInput | SystemJobLogWhereInput[]
    jobName?: StringFilter<"SystemJobLog"> | string
    status?: StringFilter<"SystemJobLog"> | string
    message?: StringNullableFilter<"SystemJobLog"> | string | null
    createdAt?: DateTimeFilter<"SystemJobLog"> | Date | string
  }, "id">

  export type SystemJobLogOrderByWithAggregationInput = {
    id?: SortOrder
    jobName?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SystemJobLogCountOrderByAggregateInput
    _max?: SystemJobLogMaxOrderByAggregateInput
    _min?: SystemJobLogMinOrderByAggregateInput
  }

  export type SystemJobLogScalarWhereWithAggregatesInput = {
    AND?: SystemJobLogScalarWhereWithAggregatesInput | SystemJobLogScalarWhereWithAggregatesInput[]
    OR?: SystemJobLogScalarWhereWithAggregatesInput[]
    NOT?: SystemJobLogScalarWhereWithAggregatesInput | SystemJobLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SystemJobLog"> | string
    jobName?: StringWithAggregatesFilter<"SystemJobLog"> | string
    status?: StringWithAggregatesFilter<"SystemJobLog"> | string
    message?: StringNullableWithAggregatesFilter<"SystemJobLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemJobLog"> | Date | string
  }

  export type IdempotencyKeyWhereInput = {
    AND?: IdempotencyKeyWhereInput | IdempotencyKeyWhereInput[]
    OR?: IdempotencyKeyWhereInput[]
    NOT?: IdempotencyKeyWhereInput | IdempotencyKeyWhereInput[]
    id?: UuidFilter<"IdempotencyKey"> | string
    key?: StringFilter<"IdempotencyKey"> | string
    createdAt?: DateTimeFilter<"IdempotencyKey"> | Date | string
    response?: JsonNullableFilter<"IdempotencyKey">
  }

  export type IdempotencyKeyOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    response?: SortOrderInput | SortOrder
  }

  export type IdempotencyKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: IdempotencyKeyWhereInput | IdempotencyKeyWhereInput[]
    OR?: IdempotencyKeyWhereInput[]
    NOT?: IdempotencyKeyWhereInput | IdempotencyKeyWhereInput[]
    createdAt?: DateTimeFilter<"IdempotencyKey"> | Date | string
    response?: JsonNullableFilter<"IdempotencyKey">
  }, "id" | "key">

  export type IdempotencyKeyOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    response?: SortOrderInput | SortOrder
    _count?: IdempotencyKeyCountOrderByAggregateInput
    _max?: IdempotencyKeyMaxOrderByAggregateInput
    _min?: IdempotencyKeyMinOrderByAggregateInput
  }

  export type IdempotencyKeyScalarWhereWithAggregatesInput = {
    AND?: IdempotencyKeyScalarWhereWithAggregatesInput | IdempotencyKeyScalarWhereWithAggregatesInput[]
    OR?: IdempotencyKeyScalarWhereWithAggregatesInput[]
    NOT?: IdempotencyKeyScalarWhereWithAggregatesInput | IdempotencyKeyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"IdempotencyKey"> | string
    key?: StringWithAggregatesFilter<"IdempotencyKey"> | string
    createdAt?: DateTimeWithAggregatesFilter<"IdempotencyKey"> | Date | string
    response?: JsonNullableWithAggregatesFilter<"IdempotencyKey">
  }

  export type JobQueueWhereInput = {
    AND?: JobQueueWhereInput | JobQueueWhereInput[]
    OR?: JobQueueWhereInput[]
    NOT?: JobQueueWhereInput | JobQueueWhereInput[]
    id?: UuidFilter<"JobQueue"> | string
    type?: StringFilter<"JobQueue"> | string
    payload?: JsonFilter<"JobQueue">
    status?: StringFilter<"JobQueue"> | string
    retryCount?: IntFilter<"JobQueue"> | number
    runAt?: DateTimeNullableFilter<"JobQueue"> | Date | string | null
    createdAt?: DateTimeFilter<"JobQueue"> | Date | string
    processedAt?: DateTimeNullableFilter<"JobQueue"> | Date | string | null
    error?: StringNullableFilter<"JobQueue"> | string | null
  }

  export type JobQueueOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    retryCount?: SortOrder
    runAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
  }

  export type JobQueueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobQueueWhereInput | JobQueueWhereInput[]
    OR?: JobQueueWhereInput[]
    NOT?: JobQueueWhereInput | JobQueueWhereInput[]
    type?: StringFilter<"JobQueue"> | string
    payload?: JsonFilter<"JobQueue">
    status?: StringFilter<"JobQueue"> | string
    retryCount?: IntFilter<"JobQueue"> | number
    runAt?: DateTimeNullableFilter<"JobQueue"> | Date | string | null
    createdAt?: DateTimeFilter<"JobQueue"> | Date | string
    processedAt?: DateTimeNullableFilter<"JobQueue"> | Date | string | null
    error?: StringNullableFilter<"JobQueue"> | string | null
  }, "id">

  export type JobQueueOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    retryCount?: SortOrder
    runAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    _count?: JobQueueCountOrderByAggregateInput
    _avg?: JobQueueAvgOrderByAggregateInput
    _max?: JobQueueMaxOrderByAggregateInput
    _min?: JobQueueMinOrderByAggregateInput
    _sum?: JobQueueSumOrderByAggregateInput
  }

  export type JobQueueScalarWhereWithAggregatesInput = {
    AND?: JobQueueScalarWhereWithAggregatesInput | JobQueueScalarWhereWithAggregatesInput[]
    OR?: JobQueueScalarWhereWithAggregatesInput[]
    NOT?: JobQueueScalarWhereWithAggregatesInput | JobQueueScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"JobQueue"> | string
    type?: StringWithAggregatesFilter<"JobQueue"> | string
    payload?: JsonWithAggregatesFilter<"JobQueue">
    status?: StringWithAggregatesFilter<"JobQueue"> | string
    retryCount?: IntWithAggregatesFilter<"JobQueue"> | number
    runAt?: DateTimeNullableWithAggregatesFilter<"JobQueue"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"JobQueue"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"JobQueue"> | Date | string | null
    error?: StringNullableWithAggregatesFilter<"JobQueue"> | string | null
  }

  export type CronLockWhereInput = {
    AND?: CronLockWhereInput | CronLockWhereInput[]
    OR?: CronLockWhereInput[]
    NOT?: CronLockWhereInput | CronLockWhereInput[]
    id?: StringFilter<"CronLock"> | string
    lockedAt?: DateTimeFilter<"CronLock"> | Date | string
    lockedBy?: StringNullableFilter<"CronLock"> | string | null
  }

  export type CronLockOrderByWithRelationInput = {
    id?: SortOrder
    lockedAt?: SortOrder
    lockedBy?: SortOrderInput | SortOrder
  }

  export type CronLockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CronLockWhereInput | CronLockWhereInput[]
    OR?: CronLockWhereInput[]
    NOT?: CronLockWhereInput | CronLockWhereInput[]
    lockedAt?: DateTimeFilter<"CronLock"> | Date | string
    lockedBy?: StringNullableFilter<"CronLock"> | string | null
  }, "id">

  export type CronLockOrderByWithAggregationInput = {
    id?: SortOrder
    lockedAt?: SortOrder
    lockedBy?: SortOrderInput | SortOrder
    _count?: CronLockCountOrderByAggregateInput
    _max?: CronLockMaxOrderByAggregateInput
    _min?: CronLockMinOrderByAggregateInput
  }

  export type CronLockScalarWhereWithAggregatesInput = {
    AND?: CronLockScalarWhereWithAggregatesInput | CronLockScalarWhereWithAggregatesInput[]
    OR?: CronLockScalarWhereWithAggregatesInput[]
    NOT?: CronLockScalarWhereWithAggregatesInput | CronLockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CronLock"> | string
    lockedAt?: DateTimeWithAggregatesFilter<"CronLock"> | Date | string
    lockedBy?: StringNullableWithAggregatesFilter<"CronLock"> | string | null
  }

  export type AiAgentWhereInput = {
    AND?: AiAgentWhereInput | AiAgentWhereInput[]
    OR?: AiAgentWhereInput[]
    NOT?: AiAgentWhereInput | AiAgentWhereInput[]
    id?: UuidFilter<"AiAgent"> | string
    systemName?: EnumAiAgentSystemNameFilter<"AiAgent"> | $Enums.AiAgentSystemName
    displayName?: StringFilter<"AiAgent"> | string
    isActive?: BoolFilter<"AiAgent"> | boolean
    canMutateData?: BoolFilter<"AiAgent"> | boolean
    createdAt?: DateTimeFilter<"AiAgent"> | Date | string
    updatedAt?: DateTimeFilter<"AiAgent"> | Date | string
    permissions?: XOR<AiPermissionNullableScalarRelationFilter, AiPermissionWhereInput> | null
    actions?: AiActionListRelationFilter
    trainingData?: AiTrainingDataListRelationFilter
  }

  export type AiAgentOrderByWithRelationInput = {
    id?: SortOrder
    systemName?: SortOrder
    displayName?: SortOrder
    isActive?: SortOrder
    canMutateData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    permissions?: AiPermissionOrderByWithRelationInput
    actions?: AiActionOrderByRelationAggregateInput
    trainingData?: AiTrainingDataOrderByRelationAggregateInput
  }

  export type AiAgentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    systemName?: $Enums.AiAgentSystemName
    AND?: AiAgentWhereInput | AiAgentWhereInput[]
    OR?: AiAgentWhereInput[]
    NOT?: AiAgentWhereInput | AiAgentWhereInput[]
    displayName?: StringFilter<"AiAgent"> | string
    isActive?: BoolFilter<"AiAgent"> | boolean
    canMutateData?: BoolFilter<"AiAgent"> | boolean
    createdAt?: DateTimeFilter<"AiAgent"> | Date | string
    updatedAt?: DateTimeFilter<"AiAgent"> | Date | string
    permissions?: XOR<AiPermissionNullableScalarRelationFilter, AiPermissionWhereInput> | null
    actions?: AiActionListRelationFilter
    trainingData?: AiTrainingDataListRelationFilter
  }, "id" | "systemName">

  export type AiAgentOrderByWithAggregationInput = {
    id?: SortOrder
    systemName?: SortOrder
    displayName?: SortOrder
    isActive?: SortOrder
    canMutateData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AiAgentCountOrderByAggregateInput
    _max?: AiAgentMaxOrderByAggregateInput
    _min?: AiAgentMinOrderByAggregateInput
  }

  export type AiAgentScalarWhereWithAggregatesInput = {
    AND?: AiAgentScalarWhereWithAggregatesInput | AiAgentScalarWhereWithAggregatesInput[]
    OR?: AiAgentScalarWhereWithAggregatesInput[]
    NOT?: AiAgentScalarWhereWithAggregatesInput | AiAgentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AiAgent"> | string
    systemName?: EnumAiAgentSystemNameWithAggregatesFilter<"AiAgent"> | $Enums.AiAgentSystemName
    displayName?: StringWithAggregatesFilter<"AiAgent"> | string
    isActive?: BoolWithAggregatesFilter<"AiAgent"> | boolean
    canMutateData?: BoolWithAggregatesFilter<"AiAgent"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AiAgent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AiAgent"> | Date | string
  }

  export type AiPermissionWhereInput = {
    AND?: AiPermissionWhereInput | AiPermissionWhereInput[]
    OR?: AiPermissionWhereInput[]
    NOT?: AiPermissionWhereInput | AiPermissionWhereInput[]
    id?: UuidFilter<"AiPermission"> | string
    agentId?: UuidFilter<"AiPermission"> | string
    canModifyProducts?: BoolFilter<"AiPermission"> | boolean
    canModifyPackages?: BoolFilter<"AiPermission"> | boolean
    canModifyOrders?: BoolFilter<"AiPermission"> | boolean
    requiresAdminConfirmation?: BoolFilter<"AiPermission"> | boolean
    agent?: XOR<AiAgentScalarRelationFilter, AiAgentWhereInput>
  }

  export type AiPermissionOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    canModifyProducts?: SortOrder
    canModifyPackages?: SortOrder
    canModifyOrders?: SortOrder
    requiresAdminConfirmation?: SortOrder
    agent?: AiAgentOrderByWithRelationInput
  }

  export type AiPermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    agentId?: string
    AND?: AiPermissionWhereInput | AiPermissionWhereInput[]
    OR?: AiPermissionWhereInput[]
    NOT?: AiPermissionWhereInput | AiPermissionWhereInput[]
    canModifyProducts?: BoolFilter<"AiPermission"> | boolean
    canModifyPackages?: BoolFilter<"AiPermission"> | boolean
    canModifyOrders?: BoolFilter<"AiPermission"> | boolean
    requiresAdminConfirmation?: BoolFilter<"AiPermission"> | boolean
    agent?: XOR<AiAgentScalarRelationFilter, AiAgentWhereInput>
  }, "id" | "agentId">

  export type AiPermissionOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    canModifyProducts?: SortOrder
    canModifyPackages?: SortOrder
    canModifyOrders?: SortOrder
    requiresAdminConfirmation?: SortOrder
    _count?: AiPermissionCountOrderByAggregateInput
    _max?: AiPermissionMaxOrderByAggregateInput
    _min?: AiPermissionMinOrderByAggregateInput
  }

  export type AiPermissionScalarWhereWithAggregatesInput = {
    AND?: AiPermissionScalarWhereWithAggregatesInput | AiPermissionScalarWhereWithAggregatesInput[]
    OR?: AiPermissionScalarWhereWithAggregatesInput[]
    NOT?: AiPermissionScalarWhereWithAggregatesInput | AiPermissionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AiPermission"> | string
    agentId?: UuidWithAggregatesFilter<"AiPermission"> | string
    canModifyProducts?: BoolWithAggregatesFilter<"AiPermission"> | boolean
    canModifyPackages?: BoolWithAggregatesFilter<"AiPermission"> | boolean
    canModifyOrders?: BoolWithAggregatesFilter<"AiPermission"> | boolean
    requiresAdminConfirmation?: BoolWithAggregatesFilter<"AiPermission"> | boolean
  }

  export type AiActionWhereInput = {
    AND?: AiActionWhereInput | AiActionWhereInput[]
    OR?: AiActionWhereInput[]
    NOT?: AiActionWhereInput | AiActionWhereInput[]
    id?: UuidFilter<"AiAction"> | string
    agentId?: UuidFilter<"AiAction"> | string
    actionType?: StringFilter<"AiAction"> | string
    payloadBefore?: JsonNullableFilter<"AiAction">
    payloadAfter?: JsonFilter<"AiAction">
    status?: EnumAiActionStatusFilter<"AiAction"> | $Enums.AiActionStatus
    approvedBy?: UuidNullableFilter<"AiAction"> | string | null
    createdAt?: DateTimeFilter<"AiAction"> | Date | string
    executedAt?: DateTimeNullableFilter<"AiAction"> | Date | string | null
    agent?: XOR<AiAgentScalarRelationFilter, AiAgentWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AiActionOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    actionType?: SortOrder
    payloadBefore?: SortOrderInput | SortOrder
    payloadAfter?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    executedAt?: SortOrderInput | SortOrder
    agent?: AiAgentOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
  }

  export type AiActionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiActionWhereInput | AiActionWhereInput[]
    OR?: AiActionWhereInput[]
    NOT?: AiActionWhereInput | AiActionWhereInput[]
    agentId?: UuidFilter<"AiAction"> | string
    actionType?: StringFilter<"AiAction"> | string
    payloadBefore?: JsonNullableFilter<"AiAction">
    payloadAfter?: JsonFilter<"AiAction">
    status?: EnumAiActionStatusFilter<"AiAction"> | $Enums.AiActionStatus
    approvedBy?: UuidNullableFilter<"AiAction"> | string | null
    createdAt?: DateTimeFilter<"AiAction"> | Date | string
    executedAt?: DateTimeNullableFilter<"AiAction"> | Date | string | null
    agent?: XOR<AiAgentScalarRelationFilter, AiAgentWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AiActionOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    actionType?: SortOrder
    payloadBefore?: SortOrderInput | SortOrder
    payloadAfter?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    executedAt?: SortOrderInput | SortOrder
    _count?: AiActionCountOrderByAggregateInput
    _max?: AiActionMaxOrderByAggregateInput
    _min?: AiActionMinOrderByAggregateInput
  }

  export type AiActionScalarWhereWithAggregatesInput = {
    AND?: AiActionScalarWhereWithAggregatesInput | AiActionScalarWhereWithAggregatesInput[]
    OR?: AiActionScalarWhereWithAggregatesInput[]
    NOT?: AiActionScalarWhereWithAggregatesInput | AiActionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AiAction"> | string
    agentId?: UuidWithAggregatesFilter<"AiAction"> | string
    actionType?: StringWithAggregatesFilter<"AiAction"> | string
    payloadBefore?: JsonNullableWithAggregatesFilter<"AiAction">
    payloadAfter?: JsonWithAggregatesFilter<"AiAction">
    status?: EnumAiActionStatusWithAggregatesFilter<"AiAction"> | $Enums.AiActionStatus
    approvedBy?: UuidNullableWithAggregatesFilter<"AiAction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AiAction"> | Date | string
    executedAt?: DateTimeNullableWithAggregatesFilter<"AiAction"> | Date | string | null
  }

  export type AiTrainingDataWhereInput = {
    AND?: AiTrainingDataWhereInput | AiTrainingDataWhereInput[]
    OR?: AiTrainingDataWhereInput[]
    NOT?: AiTrainingDataWhereInput | AiTrainingDataWhereInput[]
    id?: UuidFilter<"AiTrainingData"> | string
    agentId?: UuidFilter<"AiTrainingData"> | string
    suggestion?: StringFilter<"AiTrainingData"> | string
    adminDecision?: StringFilter<"AiTrainingData"> | string
    feedbackScore?: IntNullableFilter<"AiTrainingData"> | number | null
    createdAt?: DateTimeFilter<"AiTrainingData"> | Date | string
    agent?: XOR<AiAgentScalarRelationFilter, AiAgentWhereInput>
  }

  export type AiTrainingDataOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    suggestion?: SortOrder
    adminDecision?: SortOrder
    feedbackScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    agent?: AiAgentOrderByWithRelationInput
  }

  export type AiTrainingDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiTrainingDataWhereInput | AiTrainingDataWhereInput[]
    OR?: AiTrainingDataWhereInput[]
    NOT?: AiTrainingDataWhereInput | AiTrainingDataWhereInput[]
    agentId?: UuidFilter<"AiTrainingData"> | string
    suggestion?: StringFilter<"AiTrainingData"> | string
    adminDecision?: StringFilter<"AiTrainingData"> | string
    feedbackScore?: IntNullableFilter<"AiTrainingData"> | number | null
    createdAt?: DateTimeFilter<"AiTrainingData"> | Date | string
    agent?: XOR<AiAgentScalarRelationFilter, AiAgentWhereInput>
  }, "id">

  export type AiTrainingDataOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    suggestion?: SortOrder
    adminDecision?: SortOrder
    feedbackScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AiTrainingDataCountOrderByAggregateInput
    _avg?: AiTrainingDataAvgOrderByAggregateInput
    _max?: AiTrainingDataMaxOrderByAggregateInput
    _min?: AiTrainingDataMinOrderByAggregateInput
    _sum?: AiTrainingDataSumOrderByAggregateInput
  }

  export type AiTrainingDataScalarWhereWithAggregatesInput = {
    AND?: AiTrainingDataScalarWhereWithAggregatesInput | AiTrainingDataScalarWhereWithAggregatesInput[]
    OR?: AiTrainingDataScalarWhereWithAggregatesInput[]
    NOT?: AiTrainingDataScalarWhereWithAggregatesInput | AiTrainingDataScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AiTrainingData"> | string
    agentId?: UuidWithAggregatesFilter<"AiTrainingData"> | string
    suggestion?: StringWithAggregatesFilter<"AiTrainingData"> | string
    adminDecision?: StringWithAggregatesFilter<"AiTrainingData"> | string
    feedbackScore?: IntNullableWithAggregatesFilter<"AiTrainingData"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"AiTrainingData"> | Date | string
  }

  export type VehicleWhereInput = {
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    id?: UuidFilter<"Vehicle"> | string
    name?: StringFilter<"Vehicle"> | string
    type?: EnumVehicleTypeFilter<"Vehicle"> | $Enums.VehicleType
    status?: EnumVehicleStatusFilter<"Vehicle"> | $Enums.VehicleStatus
    currentDeliveryId?: UuidNullableFilter<"Vehicle"> | string | null
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeFilter<"Vehicle"> | Date | string
    deliveries?: DeliveryListRelationFilter
  }

  export type VehicleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    currentDeliveryId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deliveries?: DeliveryOrderByRelationAggregateInput
  }

  export type VehicleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    name?: StringFilter<"Vehicle"> | string
    type?: EnumVehicleTypeFilter<"Vehicle"> | $Enums.VehicleType
    status?: EnumVehicleStatusFilter<"Vehicle"> | $Enums.VehicleStatus
    currentDeliveryId?: UuidNullableFilter<"Vehicle"> | string | null
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeFilter<"Vehicle"> | Date | string
    deliveries?: DeliveryListRelationFilter
  }, "id">

  export type VehicleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    currentDeliveryId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VehicleCountOrderByAggregateInput
    _max?: VehicleMaxOrderByAggregateInput
    _min?: VehicleMinOrderByAggregateInput
  }

  export type VehicleScalarWhereWithAggregatesInput = {
    AND?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    OR?: VehicleScalarWhereWithAggregatesInput[]
    NOT?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Vehicle"> | string
    name?: StringWithAggregatesFilter<"Vehicle"> | string
    type?: EnumVehicleTypeWithAggregatesFilter<"Vehicle"> | $Enums.VehicleType
    status?: EnumVehicleStatusWithAggregatesFilter<"Vehicle"> | $Enums.VehicleStatus
    currentDeliveryId?: UuidNullableWithAggregatesFilter<"Vehicle"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
  }

  export type DeliveryWhereInput = {
    AND?: DeliveryWhereInput | DeliveryWhereInput[]
    OR?: DeliveryWhereInput[]
    NOT?: DeliveryWhereInput | DeliveryWhereInput[]
    id?: UuidFilter<"Delivery"> | string
    invoiceId?: UuidNullableFilter<"Delivery"> | string | null
    deliveryMethod?: EnumDeliveryMethodFilter<"Delivery"> | $Enums.DeliveryMethod
    deliveryType?: EnumDeliveryTypeFilter<"Delivery"> | $Enums.DeliveryType
    vehicleId?: UuidNullableFilter<"Delivery"> | string | null
    status?: EnumDeliveryStatusFilter<"Delivery"> | $Enums.DeliveryStatus
    claimedByWorkerId?: UuidNullableFilter<"Delivery"> | string | null
    claimedAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    eta?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    etaOverrideCount?: IntFilter<"Delivery"> | number
    delayMinutes?: IntFilter<"Delivery"> | number
    latitude?: FloatNullableFilter<"Delivery"> | number | null
    longitude?: FloatNullableFilter<"Delivery"> | number | null
    lastLocationUpdate?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    trackingCode?: StringNullableFilter<"Delivery"> | string | null
    createdAt?: DateTimeFilter<"Delivery"> | Date | string
    updatedAt?: DateTimeFilter<"Delivery"> | Date | string
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    vehicle?: XOR<VehicleNullableScalarRelationFilter, VehicleWhereInput> | null
    claimedByWorker?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: DeliveryItemListRelationFilter
    logs?: DeliveryLogListRelationFilter
    editLogs?: DeliveryEditLogListRelationFilter
  }

  export type DeliveryOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    deliveryMethod?: SortOrder
    deliveryType?: SortOrder
    vehicleId?: SortOrderInput | SortOrder
    status?: SortOrder
    claimedByWorkerId?: SortOrderInput | SortOrder
    claimedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    eta?: SortOrderInput | SortOrder
    etaOverrideCount?: SortOrder
    delayMinutes?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    lastLocationUpdate?: SortOrderInput | SortOrder
    trackingCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
    claimedByWorker?: UserOrderByWithRelationInput
    items?: DeliveryItemOrderByRelationAggregateInput
    logs?: DeliveryLogOrderByRelationAggregateInput
    editLogs?: DeliveryEditLogOrderByRelationAggregateInput
  }

  export type DeliveryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    trackingCode?: string
    AND?: DeliveryWhereInput | DeliveryWhereInput[]
    OR?: DeliveryWhereInput[]
    NOT?: DeliveryWhereInput | DeliveryWhereInput[]
    invoiceId?: UuidNullableFilter<"Delivery"> | string | null
    deliveryMethod?: EnumDeliveryMethodFilter<"Delivery"> | $Enums.DeliveryMethod
    deliveryType?: EnumDeliveryTypeFilter<"Delivery"> | $Enums.DeliveryType
    vehicleId?: UuidNullableFilter<"Delivery"> | string | null
    status?: EnumDeliveryStatusFilter<"Delivery"> | $Enums.DeliveryStatus
    claimedByWorkerId?: UuidNullableFilter<"Delivery"> | string | null
    claimedAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    eta?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    etaOverrideCount?: IntFilter<"Delivery"> | number
    delayMinutes?: IntFilter<"Delivery"> | number
    latitude?: FloatNullableFilter<"Delivery"> | number | null
    longitude?: FloatNullableFilter<"Delivery"> | number | null
    lastLocationUpdate?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    createdAt?: DateTimeFilter<"Delivery"> | Date | string
    updatedAt?: DateTimeFilter<"Delivery"> | Date | string
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    vehicle?: XOR<VehicleNullableScalarRelationFilter, VehicleWhereInput> | null
    claimedByWorker?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: DeliveryItemListRelationFilter
    logs?: DeliveryLogListRelationFilter
    editLogs?: DeliveryEditLogListRelationFilter
  }, "id" | "trackingCode">

  export type DeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    deliveryMethod?: SortOrder
    deliveryType?: SortOrder
    vehicleId?: SortOrderInput | SortOrder
    status?: SortOrder
    claimedByWorkerId?: SortOrderInput | SortOrder
    claimedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    eta?: SortOrderInput | SortOrder
    etaOverrideCount?: SortOrder
    delayMinutes?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    lastLocationUpdate?: SortOrderInput | SortOrder
    trackingCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeliveryCountOrderByAggregateInput
    _avg?: DeliveryAvgOrderByAggregateInput
    _max?: DeliveryMaxOrderByAggregateInput
    _min?: DeliveryMinOrderByAggregateInput
    _sum?: DeliverySumOrderByAggregateInput
  }

  export type DeliveryScalarWhereWithAggregatesInput = {
    AND?: DeliveryScalarWhereWithAggregatesInput | DeliveryScalarWhereWithAggregatesInput[]
    OR?: DeliveryScalarWhereWithAggregatesInput[]
    NOT?: DeliveryScalarWhereWithAggregatesInput | DeliveryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Delivery"> | string
    invoiceId?: UuidNullableWithAggregatesFilter<"Delivery"> | string | null
    deliveryMethod?: EnumDeliveryMethodWithAggregatesFilter<"Delivery"> | $Enums.DeliveryMethod
    deliveryType?: EnumDeliveryTypeWithAggregatesFilter<"Delivery"> | $Enums.DeliveryType
    vehicleId?: UuidNullableWithAggregatesFilter<"Delivery"> | string | null
    status?: EnumDeliveryStatusWithAggregatesFilter<"Delivery"> | $Enums.DeliveryStatus
    claimedByWorkerId?: UuidNullableWithAggregatesFilter<"Delivery"> | string | null
    claimedAt?: DateTimeNullableWithAggregatesFilter<"Delivery"> | Date | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"Delivery"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Delivery"> | Date | string | null
    eta?: DateTimeNullableWithAggregatesFilter<"Delivery"> | Date | string | null
    etaOverrideCount?: IntWithAggregatesFilter<"Delivery"> | number
    delayMinutes?: IntWithAggregatesFilter<"Delivery"> | number
    latitude?: FloatNullableWithAggregatesFilter<"Delivery"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Delivery"> | number | null
    lastLocationUpdate?: DateTimeNullableWithAggregatesFilter<"Delivery"> | Date | string | null
    trackingCode?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Delivery"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Delivery"> | Date | string
  }

  export type DeliveryItemWhereInput = {
    AND?: DeliveryItemWhereInput | DeliveryItemWhereInput[]
    OR?: DeliveryItemWhereInput[]
    NOT?: DeliveryItemWhereInput | DeliveryItemWhereInput[]
    id?: UuidFilter<"DeliveryItem"> | string
    deliveryId?: UuidFilter<"DeliveryItem"> | string
    rentalItemId?: UuidFilter<"DeliveryItem"> | string
    quantity?: IntFilter<"DeliveryItem"> | number
    delivery?: XOR<DeliveryScalarRelationFilter, DeliveryWhereInput>
    rentalItem?: XOR<RentalItemScalarRelationFilter, RentalItemWhereInput>
  }

  export type DeliveryItemOrderByWithRelationInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    rentalItemId?: SortOrder
    quantity?: SortOrder
    delivery?: DeliveryOrderByWithRelationInput
    rentalItem?: RentalItemOrderByWithRelationInput
  }

  export type DeliveryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeliveryItemWhereInput | DeliveryItemWhereInput[]
    OR?: DeliveryItemWhereInput[]
    NOT?: DeliveryItemWhereInput | DeliveryItemWhereInput[]
    deliveryId?: UuidFilter<"DeliveryItem"> | string
    rentalItemId?: UuidFilter<"DeliveryItem"> | string
    quantity?: IntFilter<"DeliveryItem"> | number
    delivery?: XOR<DeliveryScalarRelationFilter, DeliveryWhereInput>
    rentalItem?: XOR<RentalItemScalarRelationFilter, RentalItemWhereInput>
  }, "id">

  export type DeliveryItemOrderByWithAggregationInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    rentalItemId?: SortOrder
    quantity?: SortOrder
    _count?: DeliveryItemCountOrderByAggregateInput
    _avg?: DeliveryItemAvgOrderByAggregateInput
    _max?: DeliveryItemMaxOrderByAggregateInput
    _min?: DeliveryItemMinOrderByAggregateInput
    _sum?: DeliveryItemSumOrderByAggregateInput
  }

  export type DeliveryItemScalarWhereWithAggregatesInput = {
    AND?: DeliveryItemScalarWhereWithAggregatesInput | DeliveryItemScalarWhereWithAggregatesInput[]
    OR?: DeliveryItemScalarWhereWithAggregatesInput[]
    NOT?: DeliveryItemScalarWhereWithAggregatesInput | DeliveryItemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"DeliveryItem"> | string
    deliveryId?: UuidWithAggregatesFilter<"DeliveryItem"> | string
    rentalItemId?: UuidWithAggregatesFilter<"DeliveryItem"> | string
    quantity?: IntWithAggregatesFilter<"DeliveryItem"> | number
  }

  export type DeliveryLogWhereInput = {
    AND?: DeliveryLogWhereInput | DeliveryLogWhereInput[]
    OR?: DeliveryLogWhereInput[]
    NOT?: DeliveryLogWhereInput | DeliveryLogWhereInput[]
    id?: UuidFilter<"DeliveryLog"> | string
    deliveryId?: UuidFilter<"DeliveryLog"> | string
    eventType?: StringFilter<"DeliveryLog"> | string
    oldValue?: JsonNullableFilter<"DeliveryLog">
    newValue?: JsonNullableFilter<"DeliveryLog">
    createdByUserId?: UuidNullableFilter<"DeliveryLog"> | string | null
    role?: EnumDeliveryRoleFilter<"DeliveryLog"> | $Enums.DeliveryRole
    createdAt?: DateTimeFilter<"DeliveryLog"> | Date | string
    delivery?: XOR<DeliveryScalarRelationFilter, DeliveryWhereInput>
    createdByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type DeliveryLogOrderByWithRelationInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    eventType?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    delivery?: DeliveryOrderByWithRelationInput
    createdByUser?: UserOrderByWithRelationInput
  }

  export type DeliveryLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeliveryLogWhereInput | DeliveryLogWhereInput[]
    OR?: DeliveryLogWhereInput[]
    NOT?: DeliveryLogWhereInput | DeliveryLogWhereInput[]
    deliveryId?: UuidFilter<"DeliveryLog"> | string
    eventType?: StringFilter<"DeliveryLog"> | string
    oldValue?: JsonNullableFilter<"DeliveryLog">
    newValue?: JsonNullableFilter<"DeliveryLog">
    createdByUserId?: UuidNullableFilter<"DeliveryLog"> | string | null
    role?: EnumDeliveryRoleFilter<"DeliveryLog"> | $Enums.DeliveryRole
    createdAt?: DateTimeFilter<"DeliveryLog"> | Date | string
    delivery?: XOR<DeliveryScalarRelationFilter, DeliveryWhereInput>
    createdByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type DeliveryLogOrderByWithAggregationInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    eventType?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    _count?: DeliveryLogCountOrderByAggregateInput
    _max?: DeliveryLogMaxOrderByAggregateInput
    _min?: DeliveryLogMinOrderByAggregateInput
  }

  export type DeliveryLogScalarWhereWithAggregatesInput = {
    AND?: DeliveryLogScalarWhereWithAggregatesInput | DeliveryLogScalarWhereWithAggregatesInput[]
    OR?: DeliveryLogScalarWhereWithAggregatesInput[]
    NOT?: DeliveryLogScalarWhereWithAggregatesInput | DeliveryLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"DeliveryLog"> | string
    deliveryId?: UuidWithAggregatesFilter<"DeliveryLog"> | string
    eventType?: StringWithAggregatesFilter<"DeliveryLog"> | string
    oldValue?: JsonNullableWithAggregatesFilter<"DeliveryLog">
    newValue?: JsonNullableWithAggregatesFilter<"DeliveryLog">
    createdByUserId?: UuidNullableWithAggregatesFilter<"DeliveryLog"> | string | null
    role?: EnumDeliveryRoleWithAggregatesFilter<"DeliveryLog"> | $Enums.DeliveryRole
    createdAt?: DateTimeWithAggregatesFilter<"DeliveryLog"> | Date | string
  }

  export type DeliveryEditLogWhereInput = {
    AND?: DeliveryEditLogWhereInput | DeliveryEditLogWhereInput[]
    OR?: DeliveryEditLogWhereInput[]
    NOT?: DeliveryEditLogWhereInput | DeliveryEditLogWhereInput[]
    id?: UuidFilter<"DeliveryEditLog"> | string
    deliveryId?: UuidFilter<"DeliveryEditLog"> | string
    editedByUserId?: UuidFilter<"DeliveryEditLog"> | string
    role?: EnumDeliveryRoleFilter<"DeliveryEditLog"> | $Enums.DeliveryRole
    fieldChanged?: StringFilter<"DeliveryEditLog"> | string
    oldValue?: StringNullableFilter<"DeliveryEditLog"> | string | null
    newValue?: StringNullableFilter<"DeliveryEditLog"> | string | null
    reason?: StringNullableFilter<"DeliveryEditLog"> | string | null
    createdAt?: DateTimeFilter<"DeliveryEditLog"> | Date | string
    delivery?: XOR<DeliveryScalarRelationFilter, DeliveryWhereInput>
    editedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DeliveryEditLogOrderByWithRelationInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    editedByUserId?: SortOrder
    role?: SortOrder
    fieldChanged?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    delivery?: DeliveryOrderByWithRelationInput
    editedByUser?: UserOrderByWithRelationInput
  }

  export type DeliveryEditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeliveryEditLogWhereInput | DeliveryEditLogWhereInput[]
    OR?: DeliveryEditLogWhereInput[]
    NOT?: DeliveryEditLogWhereInput | DeliveryEditLogWhereInput[]
    deliveryId?: UuidFilter<"DeliveryEditLog"> | string
    editedByUserId?: UuidFilter<"DeliveryEditLog"> | string
    role?: EnumDeliveryRoleFilter<"DeliveryEditLog"> | $Enums.DeliveryRole
    fieldChanged?: StringFilter<"DeliveryEditLog"> | string
    oldValue?: StringNullableFilter<"DeliveryEditLog"> | string | null
    newValue?: StringNullableFilter<"DeliveryEditLog"> | string | null
    reason?: StringNullableFilter<"DeliveryEditLog"> | string | null
    createdAt?: DateTimeFilter<"DeliveryEditLog"> | Date | string
    delivery?: XOR<DeliveryScalarRelationFilter, DeliveryWhereInput>
    editedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DeliveryEditLogOrderByWithAggregationInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    editedByUserId?: SortOrder
    role?: SortOrder
    fieldChanged?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DeliveryEditLogCountOrderByAggregateInput
    _max?: DeliveryEditLogMaxOrderByAggregateInput
    _min?: DeliveryEditLogMinOrderByAggregateInput
  }

  export type DeliveryEditLogScalarWhereWithAggregatesInput = {
    AND?: DeliveryEditLogScalarWhereWithAggregatesInput | DeliveryEditLogScalarWhereWithAggregatesInput[]
    OR?: DeliveryEditLogScalarWhereWithAggregatesInput[]
    NOT?: DeliveryEditLogScalarWhereWithAggregatesInput | DeliveryEditLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"DeliveryEditLog"> | string
    deliveryId?: UuidWithAggregatesFilter<"DeliveryEditLog"> | string
    editedByUserId?: UuidWithAggregatesFilter<"DeliveryEditLog"> | string
    role?: EnumDeliveryRoleWithAggregatesFilter<"DeliveryEditLog"> | $Enums.DeliveryRole
    fieldChanged?: StringWithAggregatesFilter<"DeliveryEditLog"> | string
    oldValue?: StringNullableWithAggregatesFilter<"DeliveryEditLog"> | string | null
    newValue?: StringNullableWithAggregatesFilter<"DeliveryEditLog"> | string | null
    reason?: StringNullableWithAggregatesFilter<"DeliveryEditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DeliveryEditLog"> | Date | string
  }

  export type SpecialOfferWhereInput = {
    AND?: SpecialOfferWhereInput | SpecialOfferWhereInput[]
    OR?: SpecialOfferWhereInput[]
    NOT?: SpecialOfferWhereInput | SpecialOfferWhereInput[]
    id?: UuidFilter<"SpecialOffer"> | string
    title?: StringFilter<"SpecialOffer"> | string
    description?: StringFilter<"SpecialOffer"> | string
    badgeText?: StringNullableFilter<"SpecialOffer"> | string | null
    discountPercentage?: IntFilter<"SpecialOffer"> | number
    originalPrice?: DecimalFilter<"SpecialOffer"> | Decimal | DecimalJsLike | number | string
    finalPrice?: DecimalFilter<"SpecialOffer"> | Decimal | DecimalJsLike | number | string
    images?: StringNullableListFilter<"SpecialOffer">
    isActive?: BoolFilter<"SpecialOffer"> | boolean
    createdAt?: DateTimeFilter<"SpecialOffer"> | Date | string
  }

  export type SpecialOfferOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    badgeText?: SortOrderInput | SortOrder
    discountPercentage?: SortOrder
    originalPrice?: SortOrder
    finalPrice?: SortOrder
    images?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type SpecialOfferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpecialOfferWhereInput | SpecialOfferWhereInput[]
    OR?: SpecialOfferWhereInput[]
    NOT?: SpecialOfferWhereInput | SpecialOfferWhereInput[]
    title?: StringFilter<"SpecialOffer"> | string
    description?: StringFilter<"SpecialOffer"> | string
    badgeText?: StringNullableFilter<"SpecialOffer"> | string | null
    discountPercentage?: IntFilter<"SpecialOffer"> | number
    originalPrice?: DecimalFilter<"SpecialOffer"> | Decimal | DecimalJsLike | number | string
    finalPrice?: DecimalFilter<"SpecialOffer"> | Decimal | DecimalJsLike | number | string
    images?: StringNullableListFilter<"SpecialOffer">
    isActive?: BoolFilter<"SpecialOffer"> | boolean
    createdAt?: DateTimeFilter<"SpecialOffer"> | Date | string
  }, "id">

  export type SpecialOfferOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    badgeText?: SortOrderInput | SortOrder
    discountPercentage?: SortOrder
    originalPrice?: SortOrder
    finalPrice?: SortOrder
    images?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: SpecialOfferCountOrderByAggregateInput
    _avg?: SpecialOfferAvgOrderByAggregateInput
    _max?: SpecialOfferMaxOrderByAggregateInput
    _min?: SpecialOfferMinOrderByAggregateInput
    _sum?: SpecialOfferSumOrderByAggregateInput
  }

  export type SpecialOfferScalarWhereWithAggregatesInput = {
    AND?: SpecialOfferScalarWhereWithAggregatesInput | SpecialOfferScalarWhereWithAggregatesInput[]
    OR?: SpecialOfferScalarWhereWithAggregatesInput[]
    NOT?: SpecialOfferScalarWhereWithAggregatesInput | SpecialOfferScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SpecialOffer"> | string
    title?: StringWithAggregatesFilter<"SpecialOffer"> | string
    description?: StringWithAggregatesFilter<"SpecialOffer"> | string
    badgeText?: StringNullableWithAggregatesFilter<"SpecialOffer"> | string | null
    discountPercentage?: IntWithAggregatesFilter<"SpecialOffer"> | number
    originalPrice?: DecimalWithAggregatesFilter<"SpecialOffer"> | Decimal | DecimalJsLike | number | string
    finalPrice?: DecimalWithAggregatesFilter<"SpecialOffer"> | Decimal | DecimalJsLike | number | string
    images?: StringNullableListFilter<"SpecialOffer">
    isActive?: BoolWithAggregatesFilter<"SpecialOffer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SpecialOffer"> | Date | string
  }

  export type ContactMessageWhereInput = {
    AND?: ContactMessageWhereInput | ContactMessageWhereInput[]
    OR?: ContactMessageWhereInput[]
    NOT?: ContactMessageWhereInput | ContactMessageWhereInput[]
    id?: UuidFilter<"ContactMessage"> | string
    name?: StringFilter<"ContactMessage"> | string
    email?: StringFilter<"ContactMessage"> | string
    phone?: StringNullableFilter<"ContactMessage"> | string | null
    subject?: StringNullableFilter<"ContactMessage"> | string | null
    message?: StringFilter<"ContactMessage"> | string
    source?: StringFilter<"ContactMessage"> | string
    createdAt?: DateTimeFilter<"ContactMessage"> | Date | string
  }

  export type ContactMessageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactMessageWhereInput | ContactMessageWhereInput[]
    OR?: ContactMessageWhereInput[]
    NOT?: ContactMessageWhereInput | ContactMessageWhereInput[]
    name?: StringFilter<"ContactMessage"> | string
    email?: StringFilter<"ContactMessage"> | string
    phone?: StringNullableFilter<"ContactMessage"> | string | null
    subject?: StringNullableFilter<"ContactMessage"> | string | null
    message?: StringFilter<"ContactMessage"> | string
    source?: StringFilter<"ContactMessage"> | string
    createdAt?: DateTimeFilter<"ContactMessage"> | Date | string
  }, "id">

  export type ContactMessageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    _count?: ContactMessageCountOrderByAggregateInput
    _max?: ContactMessageMaxOrderByAggregateInput
    _min?: ContactMessageMinOrderByAggregateInput
  }

  export type ContactMessageScalarWhereWithAggregatesInput = {
    AND?: ContactMessageScalarWhereWithAggregatesInput | ContactMessageScalarWhereWithAggregatesInput[]
    OR?: ContactMessageScalarWhereWithAggregatesInput[]
    NOT?: ContactMessageScalarWhereWithAggregatesInput | ContactMessageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ContactMessage"> | string
    name?: StringWithAggregatesFilter<"ContactMessage"> | string
    email?: StringWithAggregatesFilter<"ContactMessage"> | string
    phone?: StringNullableWithAggregatesFilter<"ContactMessage"> | string | null
    subject?: StringNullableWithAggregatesFilter<"ContactMessage"> | string | null
    message?: StringWithAggregatesFilter<"ContactMessage"> | string
    source?: StringWithAggregatesFilter<"ContactMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContactMessage"> | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string | null
    createdAt?: Date | string | null
    status?: string
    guestEmail?: string | null
    guestName?: string | null
    guestWhatsapp?: string | null
    guestAddress?: string | null
    deliveryFeeOverride?: Decimal | DecimalJsLike | number | string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    shareableToken?: string | null
    emailSent?: boolean | null
    emailSentAt?: Date | string | null
    order?: OrderCreateNestedOneWithoutInvoicesInput
    deliveries?: DeliveryCreateNestedManyWithoutInvoiceInput
    user?: UserCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    invoiceNumber: string
    orderId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string | null
    createdAt?: Date | string | null
    userId?: string | null
    status?: string
    guestEmail?: string | null
    guestName?: string | null
    guestWhatsapp?: string | null
    guestAddress?: string | null
    deliveryFeeOverride?: Decimal | DecimalJsLike | number | string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    shareableToken?: string | null
    emailSent?: boolean | null
    emailSentAt?: Date | string | null
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    guestAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryFeeOverride?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shareableToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderUpdateOneWithoutInvoicesNestedInput
    deliveries?: DeliveryUpdateManyWithoutInvoiceNestedInput
    user?: UserUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    guestAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryFeeOverride?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shareableToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveries?: DeliveryUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    invoiceNumber: string
    orderId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string | null
    createdAt?: Date | string | null
    userId?: string | null
    status?: string
    guestEmail?: string | null
    guestName?: string | null
    guestWhatsapp?: string | null
    guestAddress?: string | null
    deliveryFeeOverride?: Decimal | DecimalJsLike | number | string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    shareableToken?: string | null
    emailSent?: boolean | null
    emailSentAt?: Date | string | null
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    guestAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryFeeOverride?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shareableToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    guestAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryFeeOverride?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shareableToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderCreateInput = {
    id?: string
    orderNumber: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    totalAmount: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    paymentMethod?: string | null
    createdAt?: Date | string | null
    paymentStatus?: string | null
    paymentConfirmedAt?: Date | string | null
    deliveryAddress?: string | null
    invoices?: InvoiceCreateNestedManyWithoutOrderInput
    assignedUnits?: ProductUnitCreateNestedManyWithoutAssignedOrderInput
    users_orders_payment_confirmed_byTousers?: UserCreateNestedOneWithoutOrders_orders_payment_confirmed_byTousersInput
    user: UserCreateNestedOneWithoutOrdersInput
    rentalItems?: RentalItemCreateNestedManyWithoutOrderInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    orderNumber: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    totalAmount: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    paymentMethod?: string | null
    createdAt?: Date | string | null
    userId: string
    paymentStatus?: string | null
    paymentConfirmedBy?: string | null
    paymentConfirmedAt?: Date | string | null
    deliveryAddress?: string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
    assignedUnits?: ProductUnitUncheckedCreateNestedManyWithoutAssignedOrderInput
    rentalItems?: RentalItemUncheckedCreateNestedManyWithoutOrderInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUpdateManyWithoutOrderNestedInput
    assignedUnits?: ProductUnitUpdateManyWithoutAssignedOrderNestedInput
    users_orders_payment_confirmed_byTousers?: UserUpdateOneWithoutOrders_orders_payment_confirmed_byTousersNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    rentalItems?: RentalItemUpdateManyWithoutOrderNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
    assignedUnits?: ProductUnitUncheckedUpdateManyWithoutAssignedOrderNestedInput
    rentalItems?: RentalItemUncheckedUpdateManyWithoutOrderNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    orderNumber: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    totalAmount: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    paymentMethod?: string | null
    createdAt?: Date | string | null
    userId: string
    paymentStatus?: string | null
    paymentConfirmedBy?: string | null
    paymentConfirmedAt?: Date | string | null
    deliveryAddress?: string | null
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentTransactionCreateInput = {
    id?: string
    provider: $Enums.PaymentProvider
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.TransactionStatus
    externalReferenceId?: string | null
    proofUrl?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutPaymentTransactionsInput
    verifiedBy?: UserCreateNestedOneWithoutVerifiedTransactionsInput
  }

  export type PaymentTransactionUncheckedCreateInput = {
    id?: string
    orderId: string
    provider: $Enums.PaymentProvider
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.TransactionStatus
    externalReferenceId?: string | null
    proofUrl?: string | null
    verifiedByAdminId?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    externalReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutPaymentTransactionsNestedInput
    verifiedBy?: UserUpdateOneWithoutVerifiedTransactionsNestedInput
  }

  export type PaymentTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    externalReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTransactionCreateManyInput = {
    id?: string
    orderId: string
    provider: $Enums.PaymentProvider
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.TransactionStatus
    externalReferenceId?: string | null
    proofUrl?: string | null
    verifiedByAdminId?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    externalReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    externalReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductRelationCreateInput = {
    id?: string
    relationType?: $Enums.RelationType
    priority?: number
    aiScore?: number | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutProductRelationsInput
    relatedProduct: ProductCreateNestedOneWithoutRelatedToInput
  }

  export type ProductRelationUncheckedCreateInput = {
    id?: string
    productId: string
    relatedProductId: string
    relationType?: $Enums.RelationType
    priority?: number
    aiScore?: number | null
    createdAt?: Date | string
  }

  export type ProductRelationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    priority?: IntFieldUpdateOperationsInput | number
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductRelationsNestedInput
    relatedProduct?: ProductUpdateOneRequiredWithoutRelatedToNestedInput
  }

  export type ProductRelationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    relatedProductId?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    priority?: IntFieldUpdateOperationsInput | number
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductRelationCreateManyInput = {
    id?: string
    productId: string
    relatedProductId: string
    relationType?: $Enums.RelationType
    priority?: number
    aiScore?: number | null
    createdAt?: Date | string
  }

  export type ProductRelationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    priority?: IntFieldUpdateOperationsInput | number
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductRelationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    relatedProductId?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    priority?: IntFieldUpdateOperationsInput | number
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalPackageItemCreateInput = {
    id?: string
    quantity?: number | null
    createdAt?: Date | string | null
    rentalPackage: RentalPackageCreateNestedOneWithoutRentalPackageItemsInput
    product: ProductCreateNestedOneWithoutRentalPackageItemsInput
  }

  export type RentalPackageItemUncheckedCreateInput = {
    id?: string
    rentalPackageId: string
    productId: string
    quantity?: number | null
    createdAt?: Date | string | null
  }

  export type RentalPackageItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rentalPackage?: RentalPackageUpdateOneRequiredWithoutRentalPackageItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutRentalPackageItemsNestedInput
  }

  export type RentalPackageItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rentalPackageId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RentalPackageItemCreateManyInput = {
    id?: string
    rentalPackageId: string
    productId: string
    quantity?: number | null
    createdAt?: Date | string | null
  }

  export type RentalPackageItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RentalPackageItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rentalPackageId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RentalPackageCreateInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    price: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    duration: number
    createdAt?: Date | string | null
    images?: RentalPackageCreateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    rentalPackageItems?: RentalPackageItemCreateNestedManyWithoutRentalPackageInput
    rentalItems?: RentalItemCreateNestedManyWithoutRentalPackageInput
  }

  export type RentalPackageUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    price: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    duration: number
    createdAt?: Date | string | null
    images?: RentalPackageCreateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    rentalPackageItems?: RentalPackageItemUncheckedCreateNestedManyWithoutRentalPackageInput
    rentalItems?: RentalItemUncheckedCreateNestedManyWithoutRentalPackageInput
  }

  export type RentalPackageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: RentalPackageUpdateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    rentalPackageItems?: RentalPackageItemUpdateManyWithoutRentalPackageNestedInput
    rentalItems?: RentalItemUpdateManyWithoutRentalPackageNestedInput
  }

  export type RentalPackageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: RentalPackageUpdateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    rentalPackageItems?: RentalPackageItemUncheckedUpdateManyWithoutRentalPackageNestedInput
    rentalItems?: RentalItemUncheckedUpdateManyWithoutRentalPackageNestedInput
  }

  export type RentalPackageCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    price: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    duration: number
    createdAt?: Date | string | null
    images?: RentalPackageCreateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RentalPackageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: RentalPackageUpdateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RentalPackageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: RentalPackageUpdateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    monthlyPrice: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    imageUrl?: string | null
    createdAt?: Date | string | null
    images?: ProductCreateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    inventorySyncLogs?: InventorySyncLogCreateNestedManyWithoutProductInput
    rentalPackageItems?: RentalPackageItemCreateNestedManyWithoutProductInput
    productRelations?: ProductRelationCreateNestedManyWithoutProductInput
    relatedTo?: ProductRelationCreateNestedManyWithoutRelatedProductInput
    variants?: ProductVariantCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    monthlyPrice: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    imageUrl?: string | null
    createdAt?: Date | string | null
    images?: ProductCreateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    inventorySyncLogs?: InventorySyncLogUncheckedCreateNestedManyWithoutProductInput
    rentalPackageItems?: RentalPackageItemUncheckedCreateNestedManyWithoutProductInput
    productRelations?: ProductRelationUncheckedCreateNestedManyWithoutProductInput
    relatedTo?: ProductRelationUncheckedCreateNestedManyWithoutRelatedProductInput
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: ProductUpdateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    inventorySyncLogs?: InventorySyncLogUpdateManyWithoutProductNestedInput
    rentalPackageItems?: RentalPackageItemUpdateManyWithoutProductNestedInput
    productRelations?: ProductRelationUpdateManyWithoutProductNestedInput
    relatedTo?: ProductRelationUpdateManyWithoutRelatedProductNestedInput
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: ProductUpdateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    inventorySyncLogs?: InventorySyncLogUncheckedUpdateManyWithoutProductNestedInput
    rentalPackageItems?: RentalPackageItemUncheckedUpdateManyWithoutProductNestedInput
    productRelations?: ProductRelationUncheckedUpdateManyWithoutProductNestedInput
    relatedTo?: ProductRelationUncheckedUpdateManyWithoutRelatedProductNestedInput
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    monthlyPrice: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    imageUrl?: string | null
    createdAt?: Date | string | null
    images?: ProductCreateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: ProductUpdateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: ProductUpdateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProductVariantCreateInput = {
    id?: string
    color?: string
    sku: string
    monthlyPrice?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
    rentalItems?: RentalItemCreateNestedManyWithoutVariantInput
    units?: ProductUnitCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUncheckedCreateInput = {
    id?: string
    productId: string
    color?: string
    sku: string
    monthlyPrice?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rentalItems?: RentalItemUncheckedCreateNestedManyWithoutVariantInput
    units?: ProductUnitUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    rentalItems?: RentalItemUpdateManyWithoutVariantNestedInput
    units?: ProductUnitUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentalItems?: RentalItemUncheckedUpdateManyWithoutVariantNestedInput
    units?: ProductUnitUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantCreateManyInput = {
    id?: string
    productId: string
    color?: string
    sku: string
    monthlyPrice?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUnitCreateInput = {
    id?: string
    serialNumber: string
    status?: $Enums.UnitStatus
    condition?: $Enums.UnitCondition
    purchaseDate?: Date | string | null
    lastServiceDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variant: ProductVariantCreateNestedOneWithoutUnitsInput
    assignedOrder?: OrderCreateNestedOneWithoutAssignedUnitsInput
    rentalItems?: RentalItemCreateNestedManyWithoutUnitInput
    history?: UnitHistoryCreateNestedManyWithoutUnitInput
  }

  export type ProductUnitUncheckedCreateInput = {
    id?: string
    variantId: string
    serialNumber: string
    status?: $Enums.UnitStatus
    condition?: $Enums.UnitCondition
    assignedOrderId?: string | null
    purchaseDate?: Date | string | null
    lastServiceDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rentalItems?: RentalItemUncheckedCreateNestedManyWithoutUnitInput
    history?: UnitHistoryUncheckedCreateNestedManyWithoutUnitInput
  }

  export type ProductUnitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    condition?: EnumUnitConditionFieldUpdateOperationsInput | $Enums.UnitCondition
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastServiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variant?: ProductVariantUpdateOneRequiredWithoutUnitsNestedInput
    assignedOrder?: OrderUpdateOneWithoutAssignedUnitsNestedInput
    rentalItems?: RentalItemUpdateManyWithoutUnitNestedInput
    history?: UnitHistoryUpdateManyWithoutUnitNestedInput
  }

  export type ProductUnitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    condition?: EnumUnitConditionFieldUpdateOperationsInput | $Enums.UnitCondition
    assignedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastServiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentalItems?: RentalItemUncheckedUpdateManyWithoutUnitNestedInput
    history?: UnitHistoryUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type ProductUnitCreateManyInput = {
    id?: string
    variantId: string
    serialNumber: string
    status?: $Enums.UnitStatus
    condition?: $Enums.UnitCondition
    assignedOrderId?: string | null
    purchaseDate?: Date | string | null
    lastServiceDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUnitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    condition?: EnumUnitConditionFieldUpdateOperationsInput | $Enums.UnitCondition
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastServiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUnitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    condition?: EnumUnitConditionFieldUpdateOperationsInput | $Enums.UnitCondition
    assignedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastServiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitHistoryCreateInput = {
    id?: string
    oldStatus?: string | null
    newStatus: string
    oldCondition?: string | null
    newCondition?: string | null
    details?: string | null
    createdAt?: Date | string
    unit: ProductUnitCreateNestedOneWithoutHistoryInput
    user?: UserCreateNestedOneWithoutUnitActionsInput
  }

  export type UnitHistoryUncheckedCreateInput = {
    id?: string
    unitId: string
    oldStatus?: string | null
    newStatus: string
    oldCondition?: string | null
    newCondition?: string | null
    details?: string | null
    createdAt?: Date | string
    userId?: string | null
  }

  export type UnitHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    oldCondition?: NullableStringFieldUpdateOperationsInput | string | null
    newCondition?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: ProductUnitUpdateOneRequiredWithoutHistoryNestedInput
    user?: UserUpdateOneWithoutUnitActionsNestedInput
  }

  export type UnitHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    oldCondition?: NullableStringFieldUpdateOperationsInput | string | null
    newCondition?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UnitHistoryCreateManyInput = {
    id?: string
    unitId: string
    oldStatus?: string | null
    newStatus: string
    oldCondition?: string | null
    newCondition?: string | null
    details?: string | null
    createdAt?: Date | string
    userId?: string | null
  }

  export type UnitHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    oldCondition?: NullableStringFieldUpdateOperationsInput | string | null
    newCondition?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    oldCondition?: NullableStringFieldUpdateOperationsInput | string | null
    newCondition?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemNotificationCreateInput = {
    id?: string
    type: string
    title: string
    message: string
    isRead?: boolean
    entityId?: string | null
    entityType?: string | null
    relatedType?: string | null
    createdAt?: Date | string | null
    user?: UserCreateNestedOneWithoutSystemNotificationsInput
  }

  export type SystemNotificationUncheckedCreateInput = {
    id?: string
    type: string
    title: string
    message: string
    isRead?: boolean
    userId?: string | null
    entityId?: string | null
    entityType?: string | null
    relatedType?: string | null
    createdAt?: Date | string | null
  }

  export type SystemNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    relatedType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutSystemNotificationsNestedInput
  }

  export type SystemNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    relatedType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemNotificationCreateManyInput = {
    id?: string
    type: string
    title: string
    message: string
    isRead?: boolean
    userId?: string | null
    entityId?: string | null
    entityType?: string | null
    relatedType?: string | null
    createdAt?: Date | string | null
  }

  export type SystemNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    relatedType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    relatedType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RentalItemCreateInput = {
    id?: string
    quantity?: number | null
    createdAt?: Date | string | null
    order: OrderCreateNestedOneWithoutRentalItemsInput
    rentalPackage?: RentalPackageCreateNestedOneWithoutRentalItemsInput
    variant?: ProductVariantCreateNestedOneWithoutRentalItemsInput
    unit?: ProductUnitCreateNestedOneWithoutRentalItemsInput
    deliveryItems?: DeliveryItemCreateNestedManyWithoutRentalItemInput
  }

  export type RentalItemUncheckedCreateInput = {
    id?: string
    orderId: string
    variantId?: string | null
    packageId?: string | null
    quantity?: number | null
    createdAt?: Date | string | null
    unitId?: string | null
    deliveryItems?: DeliveryItemUncheckedCreateNestedManyWithoutRentalItemInput
  }

  export type RentalItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderUpdateOneRequiredWithoutRentalItemsNestedInput
    rentalPackage?: RentalPackageUpdateOneWithoutRentalItemsNestedInput
    variant?: ProductVariantUpdateOneWithoutRentalItemsNestedInput
    unit?: ProductUnitUpdateOneWithoutRentalItemsNestedInput
    deliveryItems?: DeliveryItemUpdateManyWithoutRentalItemNestedInput
  }

  export type RentalItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryItems?: DeliveryItemUncheckedUpdateManyWithoutRentalItemNestedInput
  }

  export type RentalItemCreateManyInput = {
    id?: string
    orderId: string
    variantId?: string | null
    packageId?: string | null
    quantity?: number | null
    createdAt?: Date | string | null
    unitId?: string | null
  }

  export type RentalItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RentalItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogUncheckedCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogUncheckedCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceUncheckedCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryUncheckedCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageUncheckedCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalUncheckedCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryUncheckedCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUncheckedUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUncheckedUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUncheckedUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUncheckedUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUncheckedUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUncheckedUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUncheckedUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUncheckedUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatGroupCreateInput = {
    id?: string
    name: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ChatGroupMemberCreateNestedManyWithoutGroupInput
    messages?: GroupMessageCreateNestedManyWithoutGroupInput
  }

  export type ChatGroupUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ChatGroupMemberUncheckedCreateNestedManyWithoutGroupInput
    messages?: GroupMessageUncheckedCreateNestedManyWithoutGroupInput
  }

  export type ChatGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ChatGroupMemberUpdateManyWithoutGroupNestedInput
    messages?: GroupMessageUpdateManyWithoutGroupNestedInput
  }

  export type ChatGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ChatGroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    messages?: GroupMessageUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type ChatGroupCreateManyInput = {
    id?: string
    name: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatGroupMemberCreateInput = {
    id?: string
    role?: string
    joinedAt?: Date | string
    group: ChatGroupCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutChatGroupMembershipsInput
  }

  export type ChatGroupMemberUncheckedCreateInput = {
    id?: string
    groupId: string
    userId: string
    role?: string
    joinedAt?: Date | string
  }

  export type ChatGroupMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: ChatGroupUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutChatGroupMembershipsNestedInput
  }

  export type ChatGroupMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatGroupMemberCreateManyInput = {
    id?: string
    groupId: string
    userId: string
    role?: string
    joinedAt?: Date | string
  }

  export type ChatGroupMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatGroupMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMessageCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    group: ChatGroupCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSentGroupMessagesInput
  }

  export type GroupMessageUncheckedCreateInput = {
    id?: string
    groupId: string
    senderId: string
    content: string
    createdAt?: Date | string
  }

  export type GroupMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: ChatGroupUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentGroupMessagesNestedInput
  }

  export type GroupMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMessageCreateManyInput = {
    id?: string
    groupId: string
    senderId: string
    content: string
    createdAt?: Date | string
  }

  export type GroupMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingCreateInput = {
    key: string
    value?: NullableJsonNullValueInput | InputJsonValue
    section?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SiteSettingUncheckedCreateInput = {
    key: string
    value?: NullableJsonNullValueInput | InputJsonValue
    section?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SiteSettingUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    section?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    section?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingCreateManyInput = {
    key: string
    value?: NullableJsonNullValueInput | InputJsonValue
    section?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SiteSettingUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    section?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    section?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateInput = {
    id?: string
    action: string
    entity: string
    details?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: string
    action: string
    entity: string
    details?: string | null
    createdAt?: Date | string
    userId?: string | null
  }

  export type ActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityLogCreateManyInput = {
    id?: string
    action: string
    entity: string
    details?: string | null
    createdAt?: Date | string
    userId?: string | null
  }

  export type ActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkerAttendanceCreateInput = {
    id?: string
    date: Date | string
    status?: $Enums.attendance_status | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    notes?: string | null
    createdAt?: Date | string | null
    worker: UserCreateNestedOneWithoutWorkerAttendanceInput
  }

  export type WorkerAttendanceUncheckedCreateInput = {
    id?: string
    workerId: string
    date: Date | string
    status?: $Enums.attendance_status | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    notes?: string | null
    createdAt?: Date | string | null
  }

  export type WorkerAttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumattendance_statusFieldUpdateOperationsInput | $Enums.attendance_status | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    worker?: UserUpdateOneRequiredWithoutWorkerAttendanceNestedInput
  }

  export type WorkerAttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workerId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumattendance_statusFieldUpdateOperationsInput | $Enums.attendance_status | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkerAttendanceCreateManyInput = {
    id?: string
    workerId: string
    date: Date | string
    status?: $Enums.attendance_status | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    notes?: string | null
    createdAt?: Date | string | null
  }

  export type WorkerAttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumattendance_statusFieldUpdateOperationsInput | $Enums.attendance_status | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkerAttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workerId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumattendance_statusFieldUpdateOperationsInput | $Enums.attendance_status | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InventorySyncLogCreateInput = {
    id?: string
    oldQuantity: number
    newQuantity: number
    source: $Enums.inventory_source
    conflict?: boolean | null
    resolved?: boolean | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string | null
    product: ProductCreateNestedOneWithoutInventorySyncLogsInput
    resolvedByUser?: UserCreateNestedOneWithoutInventoryResolutionsInput
    updatedByUser: UserCreateNestedOneWithoutInventoryUpdatesInput
  }

  export type InventorySyncLogUncheckedCreateInput = {
    id?: string
    productId: string
    oldQuantity: number
    newQuantity: number
    updatedBy: string
    source: $Enums.inventory_source
    conflict?: boolean | null
    resolved?: boolean | null
    resolvedBy?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string | null
  }

  export type InventorySyncLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    source?: Enuminventory_sourceFieldUpdateOperationsInput | $Enums.inventory_source
    conflict?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutInventorySyncLogsNestedInput
    resolvedByUser?: UserUpdateOneWithoutInventoryResolutionsNestedInput
    updatedByUser?: UserUpdateOneRequiredWithoutInventoryUpdatesNestedInput
  }

  export type InventorySyncLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    oldQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    updatedBy?: StringFieldUpdateOperationsInput | string
    source?: Enuminventory_sourceFieldUpdateOperationsInput | $Enums.inventory_source
    conflict?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InventorySyncLogCreateManyInput = {
    id?: string
    productId: string
    oldQuantity: number
    newQuantity: number
    updatedBy: string
    source: $Enums.inventory_source
    conflict?: boolean | null
    resolved?: boolean | null
    resolvedBy?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string | null
  }

  export type InventorySyncLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    source?: Enuminventory_sourceFieldUpdateOperationsInput | $Enums.inventory_source
    conflict?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InventorySyncLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    oldQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    updatedBy?: StringFieldUpdateOperationsInput | string
    source?: Enuminventory_sourceFieldUpdateOperationsInput | $Enums.inventory_source
    conflict?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkerNotificationCreateInput = {
    id?: string
    type: string
    title: string
    message: string
    isRead?: boolean | null
    createdAt?: Date | string | null
    fromAdmin?: UserCreateNestedOneWithoutSentNotificationsInput
    worker: UserCreateNestedOneWithoutReceivedNotificationsInput
  }

  export type WorkerNotificationUncheckedCreateInput = {
    id?: string
    workerId: string
    fromAdminId?: string | null
    type: string
    title: string
    message: string
    isRead?: boolean | null
    createdAt?: Date | string | null
  }

  export type WorkerNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fromAdmin?: UserUpdateOneWithoutSentNotificationsNestedInput
    worker?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
  }

  export type WorkerNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workerId?: StringFieldUpdateOperationsInput | string
    fromAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkerNotificationCreateManyInput = {
    id?: string
    workerId: string
    fromAdminId?: string | null
    type: string
    title: string
    message: string
    isRead?: boolean | null
    createdAt?: Date | string | null
  }

  export type WorkerNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkerNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workerId?: StringFieldUpdateOperationsInput | string
    fromAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    senderId: string
    receiverId: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    senderId: string
    receiverId: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationDismissalCreateInput = {
    id?: string
    entityId: string
    entityType: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationDismissalsInput
  }

  export type NotificationDismissalUncheckedCreateInput = {
    id?: string
    userId: string
    entityId: string
    entityType: string
    createdAt?: Date | string
  }

  export type NotificationDismissalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationDismissalsNestedInput
  }

  export type NotificationDismissalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationDismissalCreateManyInput = {
    id?: string
    userId: string
    entityId: string
    entityType: string
    createdAt?: Date | string
  }

  export type NotificationDismissalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationDismissalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemJobLogCreateInput = {
    id?: string
    jobName: string
    status: string
    message?: string | null
    createdAt?: Date | string
  }

  export type SystemJobLogUncheckedCreateInput = {
    id?: string
    jobName: string
    status: string
    message?: string | null
    createdAt?: Date | string
  }

  export type SystemJobLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemJobLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemJobLogCreateManyInput = {
    id?: string
    jobName: string
    status: string
    message?: string | null
    createdAt?: Date | string
  }

  export type SystemJobLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemJobLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdempotencyKeyCreateInput = {
    id?: string
    key: string
    createdAt?: Date | string
    response?: NullableJsonNullValueInput | InputJsonValue
  }

  export type IdempotencyKeyUncheckedCreateInput = {
    id?: string
    key: string
    createdAt?: Date | string
    response?: NullableJsonNullValueInput | InputJsonValue
  }

  export type IdempotencyKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    response?: NullableJsonNullValueInput | InputJsonValue
  }

  export type IdempotencyKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    response?: NullableJsonNullValueInput | InputJsonValue
  }

  export type IdempotencyKeyCreateManyInput = {
    id?: string
    key: string
    createdAt?: Date | string
    response?: NullableJsonNullValueInput | InputJsonValue
  }

  export type IdempotencyKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    response?: NullableJsonNullValueInput | InputJsonValue
  }

  export type IdempotencyKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    response?: NullableJsonNullValueInput | InputJsonValue
  }

  export type JobQueueCreateInput = {
    id?: string
    type: string
    payload: JsonNullValueInput | InputJsonValue
    status?: string
    retryCount?: number
    runAt?: Date | string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
    error?: string | null
  }

  export type JobQueueUncheckedCreateInput = {
    id?: string
    type: string
    payload: JsonNullValueInput | InputJsonValue
    status?: string
    retryCount?: number
    runAt?: Date | string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
    error?: string | null
  }

  export type JobQueueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    retryCount?: IntFieldUpdateOperationsInput | number
    runAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobQueueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    retryCount?: IntFieldUpdateOperationsInput | number
    runAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobQueueCreateManyInput = {
    id?: string
    type: string
    payload: JsonNullValueInput | InputJsonValue
    status?: string
    retryCount?: number
    runAt?: Date | string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
    error?: string | null
  }

  export type JobQueueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    retryCount?: IntFieldUpdateOperationsInput | number
    runAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobQueueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    retryCount?: IntFieldUpdateOperationsInput | number
    runAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CronLockCreateInput = {
    id?: string
    lockedAt?: Date | string
    lockedBy?: string | null
  }

  export type CronLockUncheckedCreateInput = {
    id?: string
    lockedAt?: Date | string
    lockedBy?: string | null
  }

  export type CronLockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CronLockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CronLockCreateManyInput = {
    id?: string
    lockedAt?: Date | string
    lockedBy?: string | null
  }

  export type CronLockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CronLockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AiAgentCreateInput = {
    id?: string
    systemName: $Enums.AiAgentSystemName
    displayName: string
    isActive?: boolean
    canMutateData?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: AiPermissionCreateNestedOneWithoutAgentInput
    actions?: AiActionCreateNestedManyWithoutAgentInput
    trainingData?: AiTrainingDataCreateNestedManyWithoutAgentInput
  }

  export type AiAgentUncheckedCreateInput = {
    id?: string
    systemName: $Enums.AiAgentSystemName
    displayName: string
    isActive?: boolean
    canMutateData?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: AiPermissionUncheckedCreateNestedOneWithoutAgentInput
    actions?: AiActionUncheckedCreateNestedManyWithoutAgentInput
    trainingData?: AiTrainingDataUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AiAgentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemName?: EnumAiAgentSystemNameFieldUpdateOperationsInput | $Enums.AiAgentSystemName
    displayName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    canMutateData?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: AiPermissionUpdateOneWithoutAgentNestedInput
    actions?: AiActionUpdateManyWithoutAgentNestedInput
    trainingData?: AiTrainingDataUpdateManyWithoutAgentNestedInput
  }

  export type AiAgentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemName?: EnumAiAgentSystemNameFieldUpdateOperationsInput | $Enums.AiAgentSystemName
    displayName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    canMutateData?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: AiPermissionUncheckedUpdateOneWithoutAgentNestedInput
    actions?: AiActionUncheckedUpdateManyWithoutAgentNestedInput
    trainingData?: AiTrainingDataUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AiAgentCreateManyInput = {
    id?: string
    systemName: $Enums.AiAgentSystemName
    displayName: string
    isActive?: boolean
    canMutateData?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiAgentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemName?: EnumAiAgentSystemNameFieldUpdateOperationsInput | $Enums.AiAgentSystemName
    displayName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    canMutateData?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiAgentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemName?: EnumAiAgentSystemNameFieldUpdateOperationsInput | $Enums.AiAgentSystemName
    displayName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    canMutateData?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiPermissionCreateInput = {
    id?: string
    canModifyProducts?: boolean
    canModifyPackages?: boolean
    canModifyOrders?: boolean
    requiresAdminConfirmation?: boolean
    agent: AiAgentCreateNestedOneWithoutPermissionsInput
  }

  export type AiPermissionUncheckedCreateInput = {
    id?: string
    agentId: string
    canModifyProducts?: boolean
    canModifyPackages?: boolean
    canModifyOrders?: boolean
    requiresAdminConfirmation?: boolean
  }

  export type AiPermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    canModifyProducts?: BoolFieldUpdateOperationsInput | boolean
    canModifyPackages?: BoolFieldUpdateOperationsInput | boolean
    canModifyOrders?: BoolFieldUpdateOperationsInput | boolean
    requiresAdminConfirmation?: BoolFieldUpdateOperationsInput | boolean
    agent?: AiAgentUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type AiPermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    canModifyProducts?: BoolFieldUpdateOperationsInput | boolean
    canModifyPackages?: BoolFieldUpdateOperationsInput | boolean
    canModifyOrders?: BoolFieldUpdateOperationsInput | boolean
    requiresAdminConfirmation?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AiPermissionCreateManyInput = {
    id?: string
    agentId: string
    canModifyProducts?: boolean
    canModifyPackages?: boolean
    canModifyOrders?: boolean
    requiresAdminConfirmation?: boolean
  }

  export type AiPermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    canModifyProducts?: BoolFieldUpdateOperationsInput | boolean
    canModifyPackages?: BoolFieldUpdateOperationsInput | boolean
    canModifyOrders?: BoolFieldUpdateOperationsInput | boolean
    requiresAdminConfirmation?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AiPermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    canModifyProducts?: BoolFieldUpdateOperationsInput | boolean
    canModifyPackages?: BoolFieldUpdateOperationsInput | boolean
    canModifyOrders?: BoolFieldUpdateOperationsInput | boolean
    requiresAdminConfirmation?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AiActionCreateInput = {
    id?: string
    actionType: string
    payloadBefore?: NullableJsonNullValueInput | InputJsonValue
    payloadAfter: JsonNullValueInput | InputJsonValue
    status?: $Enums.AiActionStatus
    createdAt?: Date | string
    executedAt?: Date | string | null
    agent: AiAgentCreateNestedOneWithoutActionsInput
    approver?: UserCreateNestedOneWithoutAiActionApprovalsInput
  }

  export type AiActionUncheckedCreateInput = {
    id?: string
    agentId: string
    actionType: string
    payloadBefore?: NullableJsonNullValueInput | InputJsonValue
    payloadAfter: JsonNullValueInput | InputJsonValue
    status?: $Enums.AiActionStatus
    approvedBy?: string | null
    createdAt?: Date | string
    executedAt?: Date | string | null
  }

  export type AiActionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    payloadBefore?: NullableJsonNullValueInput | InputJsonValue
    payloadAfter?: JsonNullValueInput | InputJsonValue
    status?: EnumAiActionStatusFieldUpdateOperationsInput | $Enums.AiActionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agent?: AiAgentUpdateOneRequiredWithoutActionsNestedInput
    approver?: UserUpdateOneWithoutAiActionApprovalsNestedInput
  }

  export type AiActionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    payloadBefore?: NullableJsonNullValueInput | InputJsonValue
    payloadAfter?: JsonNullValueInput | InputJsonValue
    status?: EnumAiActionStatusFieldUpdateOperationsInput | $Enums.AiActionStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiActionCreateManyInput = {
    id?: string
    agentId: string
    actionType: string
    payloadBefore?: NullableJsonNullValueInput | InputJsonValue
    payloadAfter: JsonNullValueInput | InputJsonValue
    status?: $Enums.AiActionStatus
    approvedBy?: string | null
    createdAt?: Date | string
    executedAt?: Date | string | null
  }

  export type AiActionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    payloadBefore?: NullableJsonNullValueInput | InputJsonValue
    payloadAfter?: JsonNullValueInput | InputJsonValue
    status?: EnumAiActionStatusFieldUpdateOperationsInput | $Enums.AiActionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiActionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    payloadBefore?: NullableJsonNullValueInput | InputJsonValue
    payloadAfter?: JsonNullValueInput | InputJsonValue
    status?: EnumAiActionStatusFieldUpdateOperationsInput | $Enums.AiActionStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiTrainingDataCreateInput = {
    id?: string
    suggestion: string
    adminDecision: string
    feedbackScore?: number | null
    createdAt?: Date | string
    agent: AiAgentCreateNestedOneWithoutTrainingDataInput
  }

  export type AiTrainingDataUncheckedCreateInput = {
    id?: string
    agentId: string
    suggestion: string
    adminDecision: string
    feedbackScore?: number | null
    createdAt?: Date | string
  }

  export type AiTrainingDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    suggestion?: StringFieldUpdateOperationsInput | string
    adminDecision?: StringFieldUpdateOperationsInput | string
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AiAgentUpdateOneRequiredWithoutTrainingDataNestedInput
  }

  export type AiTrainingDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    suggestion?: StringFieldUpdateOperationsInput | string
    adminDecision?: StringFieldUpdateOperationsInput | string
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiTrainingDataCreateManyInput = {
    id?: string
    agentId: string
    suggestion: string
    adminDecision: string
    feedbackScore?: number | null
    createdAt?: Date | string
  }

  export type AiTrainingDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    suggestion?: StringFieldUpdateOperationsInput | string
    adminDecision?: StringFieldUpdateOperationsInput | string
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiTrainingDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    suggestion?: StringFieldUpdateOperationsInput | string
    adminDecision?: StringFieldUpdateOperationsInput | string
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleCreateInput = {
    id?: string
    name: string
    type: $Enums.VehicleType
    status?: $Enums.VehicleStatus
    currentDeliveryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: DeliveryCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.VehicleType
    status?: $Enums.VehicleStatus
    currentDeliveryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    currentDeliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: DeliveryUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    currentDeliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: DeliveryUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleCreateManyInput = {
    id?: string
    name: string
    type: $Enums.VehicleType
    status?: $Enums.VehicleStatus
    currentDeliveryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    currentDeliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    currentDeliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryCreateInput = {
    id?: string
    deliveryMethod: $Enums.DeliveryMethod
    deliveryType: $Enums.DeliveryType
    status?: $Enums.DeliveryStatus
    claimedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    eta?: Date | string | null
    etaOverrideCount?: number
    delayMinutes?: number
    latitude?: number | null
    longitude?: number | null
    lastLocationUpdate?: Date | string | null
    trackingCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutDeliveriesInput
    vehicle?: VehicleCreateNestedOneWithoutDeliveriesInput
    claimedByWorker?: UserCreateNestedOneWithoutClaimedDeliveriesInput
    items?: DeliveryItemCreateNestedManyWithoutDeliveryInput
    logs?: DeliveryLogCreateNestedManyWithoutDeliveryInput
    editLogs?: DeliveryEditLogCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateInput = {
    id?: string
    invoiceId?: string | null
    deliveryMethod: $Enums.DeliveryMethod
    deliveryType: $Enums.DeliveryType
    vehicleId?: string | null
    status?: $Enums.DeliveryStatus
    claimedByWorkerId?: string | null
    claimedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    eta?: Date | string | null
    etaOverrideCount?: number
    delayMinutes?: number
    latitude?: number | null
    longitude?: number | null
    lastLocationUpdate?: Date | string | null
    trackingCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: DeliveryItemUncheckedCreateNestedManyWithoutDeliveryInput
    logs?: DeliveryLogUncheckedCreateNestedManyWithoutDeliveryInput
    editLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etaOverrideCount?: IntFieldUpdateOperationsInput | number
    delayMinutes?: IntFieldUpdateOperationsInput | number
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutDeliveriesNestedInput
    vehicle?: VehicleUpdateOneWithoutDeliveriesNestedInput
    claimedByWorker?: UserUpdateOneWithoutClaimedDeliveriesNestedInput
    items?: DeliveryItemUpdateManyWithoutDeliveryNestedInput
    logs?: DeliveryLogUpdateManyWithoutDeliveryNestedInput
    editLogs?: DeliveryEditLogUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    claimedByWorkerId?: NullableStringFieldUpdateOperationsInput | string | null
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etaOverrideCount?: IntFieldUpdateOperationsInput | number
    delayMinutes?: IntFieldUpdateOperationsInput | number
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: DeliveryItemUncheckedUpdateManyWithoutDeliveryNestedInput
    logs?: DeliveryLogUncheckedUpdateManyWithoutDeliveryNestedInput
    editLogs?: DeliveryEditLogUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryCreateManyInput = {
    id?: string
    invoiceId?: string | null
    deliveryMethod: $Enums.DeliveryMethod
    deliveryType: $Enums.DeliveryType
    vehicleId?: string | null
    status?: $Enums.DeliveryStatus
    claimedByWorkerId?: string | null
    claimedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    eta?: Date | string | null
    etaOverrideCount?: number
    delayMinutes?: number
    latitude?: number | null
    longitude?: number | null
    lastLocationUpdate?: Date | string | null
    trackingCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etaOverrideCount?: IntFieldUpdateOperationsInput | number
    delayMinutes?: IntFieldUpdateOperationsInput | number
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    claimedByWorkerId?: NullableStringFieldUpdateOperationsInput | string | null
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etaOverrideCount?: IntFieldUpdateOperationsInput | number
    delayMinutes?: IntFieldUpdateOperationsInput | number
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryItemCreateInput = {
    id?: string
    quantity: number
    delivery: DeliveryCreateNestedOneWithoutItemsInput
    rentalItem: RentalItemCreateNestedOneWithoutDeliveryItemsInput
  }

  export type DeliveryItemUncheckedCreateInput = {
    id?: string
    deliveryId: string
    rentalItemId: string
    quantity: number
  }

  export type DeliveryItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    delivery?: DeliveryUpdateOneRequiredWithoutItemsNestedInput
    rentalItem?: RentalItemUpdateOneRequiredWithoutDeliveryItemsNestedInput
  }

  export type DeliveryItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryId?: StringFieldUpdateOperationsInput | string
    rentalItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type DeliveryItemCreateManyInput = {
    id?: string
    deliveryId: string
    rentalItemId: string
    quantity: number
  }

  export type DeliveryItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type DeliveryItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryId?: StringFieldUpdateOperationsInput | string
    rentalItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type DeliveryLogCreateInput = {
    id?: string
    eventType: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    role: $Enums.DeliveryRole
    createdAt?: Date | string
    delivery: DeliveryCreateNestedOneWithoutLogsInput
    createdByUser?: UserCreateNestedOneWithoutDeliveryLogsInput
  }

  export type DeliveryLogUncheckedCreateInput = {
    id?: string
    deliveryId: string
    eventType: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdByUserId?: string | null
    role: $Enums.DeliveryRole
    createdAt?: Date | string
  }

  export type DeliveryLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumDeliveryRoleFieldUpdateOperationsInput | $Enums.DeliveryRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delivery?: DeliveryUpdateOneRequiredWithoutLogsNestedInput
    createdByUser?: UserUpdateOneWithoutDeliveryLogsNestedInput
  }

  export type DeliveryLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumDeliveryRoleFieldUpdateOperationsInput | $Enums.DeliveryRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryLogCreateManyInput = {
    id?: string
    deliveryId: string
    eventType: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdByUserId?: string | null
    role: $Enums.DeliveryRole
    createdAt?: Date | string
  }

  export type DeliveryLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumDeliveryRoleFieldUpdateOperationsInput | $Enums.DeliveryRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumDeliveryRoleFieldUpdateOperationsInput | $Enums.DeliveryRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryEditLogCreateInput = {
    id?: string
    role: $Enums.DeliveryRole
    fieldChanged: string
    oldValue?: string | null
    newValue?: string | null
    reason?: string | null
    createdAt?: Date | string
    delivery: DeliveryCreateNestedOneWithoutEditLogsInput
    editedByUser: UserCreateNestedOneWithoutDeliveryEditLogsInput
  }

  export type DeliveryEditLogUncheckedCreateInput = {
    id?: string
    deliveryId: string
    editedByUserId: string
    role: $Enums.DeliveryRole
    fieldChanged: string
    oldValue?: string | null
    newValue?: string | null
    reason?: string | null
    createdAt?: Date | string
  }

  export type DeliveryEditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumDeliveryRoleFieldUpdateOperationsInput | $Enums.DeliveryRole
    fieldChanged?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delivery?: DeliveryUpdateOneRequiredWithoutEditLogsNestedInput
    editedByUser?: UserUpdateOneRequiredWithoutDeliveryEditLogsNestedInput
  }

  export type DeliveryEditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryId?: StringFieldUpdateOperationsInput | string
    editedByUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumDeliveryRoleFieldUpdateOperationsInput | $Enums.DeliveryRole
    fieldChanged?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryEditLogCreateManyInput = {
    id?: string
    deliveryId: string
    editedByUserId: string
    role: $Enums.DeliveryRole
    fieldChanged: string
    oldValue?: string | null
    newValue?: string | null
    reason?: string | null
    createdAt?: Date | string
  }

  export type DeliveryEditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumDeliveryRoleFieldUpdateOperationsInput | $Enums.DeliveryRole
    fieldChanged?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryEditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryId?: StringFieldUpdateOperationsInput | string
    editedByUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumDeliveryRoleFieldUpdateOperationsInput | $Enums.DeliveryRole
    fieldChanged?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialOfferCreateInput = {
    id?: string
    title: string
    description: string
    badgeText?: string | null
    discountPercentage: number
    originalPrice: Decimal | DecimalJsLike | number | string
    finalPrice: Decimal | DecimalJsLike | number | string
    images?: SpecialOfferCreateimagesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
  }

  export type SpecialOfferUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    badgeText?: string | null
    discountPercentage: number
    originalPrice: Decimal | DecimalJsLike | number | string
    finalPrice: Decimal | DecimalJsLike | number | string
    images?: SpecialOfferCreateimagesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
  }

  export type SpecialOfferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    badgeText?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercentage?: IntFieldUpdateOperationsInput | number
    originalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    images?: SpecialOfferUpdateimagesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialOfferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    badgeText?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercentage?: IntFieldUpdateOperationsInput | number
    originalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    images?: SpecialOfferUpdateimagesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialOfferCreateManyInput = {
    id?: string
    title: string
    description: string
    badgeText?: string | null
    discountPercentage: number
    originalPrice: Decimal | DecimalJsLike | number | string
    finalPrice: Decimal | DecimalJsLike | number | string
    images?: SpecialOfferCreateimagesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
  }

  export type SpecialOfferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    badgeText?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercentage?: IntFieldUpdateOperationsInput | number
    originalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    images?: SpecialOfferUpdateimagesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialOfferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    badgeText?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercentage?: IntFieldUpdateOperationsInput | number
    originalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    images?: SpecialOfferUpdateimagesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactMessageCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    subject?: string | null
    message: string
    source: string
    createdAt?: Date | string
  }

  export type ContactMessageUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    subject?: string | null
    message: string
    source: string
    createdAt?: Date | string
  }

  export type ContactMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactMessageCreateManyInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    subject?: string | null
    message: string
    source: string
    createdAt?: Date | string
  }

  export type ContactMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type OrderNullableScalarRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type DeliveryListRelationFilter = {
    every?: DeliveryWhereInput
    some?: DeliveryWhereInput
    none?: DeliveryWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type DeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    orderId?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    deliveryFee?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    guestEmail?: SortOrder
    guestName?: SortOrder
    guestWhatsapp?: SortOrder
    guestAddress?: SortOrder
    deliveryFeeOverride?: SortOrder
    taxRate?: SortOrder
    discountPercentage?: SortOrder
    discountAmount?: SortOrder
    shareableToken?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    deliveryFee?: SortOrder
    total?: SortOrder
    deliveryFeeOverride?: SortOrder
    taxRate?: SortOrder
    discountPercentage?: SortOrder
    discountAmount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    orderId?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    deliveryFee?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    guestEmail?: SortOrder
    guestName?: SortOrder
    guestWhatsapp?: SortOrder
    guestAddress?: SortOrder
    deliveryFeeOverride?: SortOrder
    taxRate?: SortOrder
    discountPercentage?: SortOrder
    discountAmount?: SortOrder
    shareableToken?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    orderId?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    deliveryFee?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    guestEmail?: SortOrder
    guestName?: SortOrder
    guestWhatsapp?: SortOrder
    guestAddress?: SortOrder
    deliveryFeeOverride?: SortOrder
    taxRate?: SortOrder
    discountPercentage?: SortOrder
    discountAmount?: SortOrder
    shareableToken?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    deliveryFee?: SortOrder
    total?: SortOrder
    deliveryFeeOverride?: SortOrder
    taxRate?: SortOrder
    discountPercentage?: SortOrder
    discountAmount?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type ProductUnitListRelationFilter = {
    every?: ProductUnitWhereInput
    some?: ProductUnitWhereInput
    none?: ProductUnitWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RentalItemListRelationFilter = {
    every?: RentalItemWhereInput
    some?: RentalItemWhereInput
    none?: RentalItemWhereInput
  }

  export type PaymentTransactionListRelationFilter = {
    every?: PaymentTransactionWhereInput
    some?: PaymentTransactionWhereInput
    none?: PaymentTransactionWhereInput
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductUnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RentalItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    totalAmount?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    deliveryFee?: SortOrder
    discountPercentage?: SortOrder
    discountAmount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    paymentStatus?: SortOrder
    paymentConfirmedBy?: SortOrder
    paymentConfirmedAt?: SortOrder
    deliveryAddress?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    duration?: SortOrder
    totalAmount?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    deliveryFee?: SortOrder
    discountPercentage?: SortOrder
    discountAmount?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    totalAmount?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    deliveryFee?: SortOrder
    discountPercentage?: SortOrder
    discountAmount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    paymentStatus?: SortOrder
    paymentConfirmedBy?: SortOrder
    paymentConfirmedAt?: SortOrder
    deliveryAddress?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    totalAmount?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    deliveryFee?: SortOrder
    discountPercentage?: SortOrder
    discountAmount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    paymentStatus?: SortOrder
    paymentConfirmedBy?: SortOrder
    paymentConfirmedAt?: SortOrder
    deliveryAddress?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    duration?: SortOrder
    totalAmount?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    deliveryFee?: SortOrder
    discountPercentage?: SortOrder
    discountAmount?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumPaymentProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentProviderFilter<$PrismaModel> | $Enums.PaymentProvider
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type PaymentTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    externalReferenceId?: SortOrder
    proofUrl?: SortOrder
    verifiedByAdminId?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    externalReferenceId?: SortOrder
    proofUrl?: SortOrder
    verifiedByAdminId?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    externalReferenceId?: SortOrder
    proofUrl?: SortOrder
    verifiedByAdminId?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentProviderWithAggregatesFilter<$PrismaModel> | $Enums.PaymentProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentProviderFilter<$PrismaModel>
    _max?: NestedEnumPaymentProviderFilter<$PrismaModel>
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type EnumRelationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationType | EnumRelationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationType[] | ListEnumRelationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationType[] | ListEnumRelationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationTypeFilter<$PrismaModel> | $Enums.RelationType
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ProductRelationProductIdRelatedProductIdCompoundUniqueInput = {
    productId: string
    relatedProductId: string
  }

  export type ProductRelationCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    relatedProductId?: SortOrder
    relationType?: SortOrder
    priority?: SortOrder
    aiScore?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductRelationAvgOrderByAggregateInput = {
    priority?: SortOrder
    aiScore?: SortOrder
  }

  export type ProductRelationMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    relatedProductId?: SortOrder
    relationType?: SortOrder
    priority?: SortOrder
    aiScore?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductRelationMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    relatedProductId?: SortOrder
    relationType?: SortOrder
    priority?: SortOrder
    aiScore?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductRelationSumOrderByAggregateInput = {
    priority?: SortOrder
    aiScore?: SortOrder
  }

  export type EnumRelationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationType | EnumRelationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationType[] | ListEnumRelationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationType[] | ListEnumRelationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationTypeWithAggregatesFilter<$PrismaModel> | $Enums.RelationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRelationTypeFilter<$PrismaModel>
    _max?: NestedEnumRelationTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type RentalPackageScalarRelationFilter = {
    is?: RentalPackageWhereInput
    isNot?: RentalPackageWhereInput
  }

  export type RentalPackageItemCountOrderByAggregateInput = {
    id?: SortOrder
    rentalPackageId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
  }

  export type RentalPackageItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type RentalPackageItemMaxOrderByAggregateInput = {
    id?: SortOrder
    rentalPackageId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
  }

  export type RentalPackageItemMinOrderByAggregateInput = {
    id?: SortOrder
    rentalPackageId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
  }

  export type RentalPackageItemSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type RentalPackageItemListRelationFilter = {
    every?: RentalPackageItemWhereInput
    some?: RentalPackageItemWhereInput
    none?: RentalPackageItemWhereInput
  }

  export type RentalPackageItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RentalPackageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    price?: SortOrder
    discountPercentage?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    images?: SortOrder
    specs?: SortOrder
  }

  export type RentalPackageAvgOrderByAggregateInput = {
    price?: SortOrder
    discountPercentage?: SortOrder
    duration?: SortOrder
  }

  export type RentalPackageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    price?: SortOrder
    discountPercentage?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
  }

  export type RentalPackageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    price?: SortOrder
    discountPercentage?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
  }

  export type RentalPackageSumOrderByAggregateInput = {
    price?: SortOrder
    discountPercentage?: SortOrder
    duration?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type InventorySyncLogListRelationFilter = {
    every?: InventorySyncLogWhereInput
    some?: InventorySyncLogWhereInput
    none?: InventorySyncLogWhereInput
  }

  export type ProductRelationListRelationFilter = {
    every?: ProductRelationWhereInput
    some?: ProductRelationWhereInput
    none?: ProductRelationWhereInput
  }

  export type ProductVariantListRelationFilter = {
    every?: ProductVariantWhereInput
    some?: ProductVariantWhereInput
    none?: ProductVariantWhereInput
  }

  export type InventorySyncLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductRelationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductVariantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    monthlyPrice?: SortOrder
    discountPercentage?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    images?: SortOrder
    specs?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    monthlyPrice?: SortOrder
    discountPercentage?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    monthlyPrice?: SortOrder
    discountPercentage?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    monthlyPrice?: SortOrder
    discountPercentage?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    monthlyPrice?: SortOrder
    discountPercentage?: SortOrder
  }

  export type ProductVariantCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    color?: SortOrder
    sku?: SortOrder
    monthlyPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantAvgOrderByAggregateInput = {
    monthlyPrice?: SortOrder
  }

  export type ProductVariantMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    color?: SortOrder
    sku?: SortOrder
    monthlyPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    color?: SortOrder
    sku?: SortOrder
    monthlyPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantSumOrderByAggregateInput = {
    monthlyPrice?: SortOrder
  }

  export type EnumUnitStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitStatus | EnumUnitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitStatusFilter<$PrismaModel> | $Enums.UnitStatus
  }

  export type EnumUnitConditionFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitCondition | EnumUnitConditionFieldRefInput<$PrismaModel>
    in?: $Enums.UnitCondition[] | ListEnumUnitConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitCondition[] | ListEnumUnitConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitConditionFilter<$PrismaModel> | $Enums.UnitCondition
  }

  export type ProductVariantScalarRelationFilter = {
    is?: ProductVariantWhereInput
    isNot?: ProductVariantWhereInput
  }

  export type UnitHistoryListRelationFilter = {
    every?: UnitHistoryWhereInput
    some?: UnitHistoryWhereInput
    none?: UnitHistoryWhereInput
  }

  export type UnitHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductUnitCountOrderByAggregateInput = {
    id?: SortOrder
    variantId?: SortOrder
    serialNumber?: SortOrder
    status?: SortOrder
    condition?: SortOrder
    assignedOrderId?: SortOrder
    purchaseDate?: SortOrder
    lastServiceDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductUnitMaxOrderByAggregateInput = {
    id?: SortOrder
    variantId?: SortOrder
    serialNumber?: SortOrder
    status?: SortOrder
    condition?: SortOrder
    assignedOrderId?: SortOrder
    purchaseDate?: SortOrder
    lastServiceDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductUnitMinOrderByAggregateInput = {
    id?: SortOrder
    variantId?: SortOrder
    serialNumber?: SortOrder
    status?: SortOrder
    condition?: SortOrder
    assignedOrderId?: SortOrder
    purchaseDate?: SortOrder
    lastServiceDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUnitStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitStatus | EnumUnitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitStatusWithAggregatesFilter<$PrismaModel> | $Enums.UnitStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUnitStatusFilter<$PrismaModel>
    _max?: NestedEnumUnitStatusFilter<$PrismaModel>
  }

  export type EnumUnitConditionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitCondition | EnumUnitConditionFieldRefInput<$PrismaModel>
    in?: $Enums.UnitCondition[] | ListEnumUnitConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitCondition[] | ListEnumUnitConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitConditionWithAggregatesFilter<$PrismaModel> | $Enums.UnitCondition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUnitConditionFilter<$PrismaModel>
    _max?: NestedEnumUnitConditionFilter<$PrismaModel>
  }

  export type ProductUnitScalarRelationFilter = {
    is?: ProductUnitWhereInput
    isNot?: ProductUnitWhereInput
  }

  export type UnitHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    oldStatus?: SortOrder
    newStatus?: SortOrder
    oldCondition?: SortOrder
    newCondition?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type UnitHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    oldStatus?: SortOrder
    newStatus?: SortOrder
    oldCondition?: SortOrder
    newCondition?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type UnitHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    oldStatus?: SortOrder
    newStatus?: SortOrder
    oldCondition?: SortOrder
    newCondition?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type SystemNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    relatedType?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    relatedType?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    relatedType?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type RentalPackageNullableScalarRelationFilter = {
    is?: RentalPackageWhereInput | null
    isNot?: RentalPackageWhereInput | null
  }

  export type ProductVariantNullableScalarRelationFilter = {
    is?: ProductVariantWhereInput | null
    isNot?: ProductVariantWhereInput | null
  }

  export type ProductUnitNullableScalarRelationFilter = {
    is?: ProductUnitWhereInput | null
    isNot?: ProductUnitWhereInput | null
  }

  export type DeliveryItemListRelationFilter = {
    every?: DeliveryItemWhereInput
    some?: DeliveryItemWhereInput
    none?: DeliveryItemWhereInput
  }

  export type DeliveryItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RentalItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    variantId?: SortOrder
    packageId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    unitId?: SortOrder
  }

  export type RentalItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type RentalItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    variantId?: SortOrder
    packageId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    unitId?: SortOrder
  }

  export type RentalItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    variantId?: SortOrder
    packageId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    unitId?: SortOrder
  }

  export type RentalItemSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type WorkerAttendanceListRelationFilter = {
    every?: WorkerAttendanceWhereInput
    some?: WorkerAttendanceWhereInput
    none?: WorkerAttendanceWhereInput
  }

  export type DeliveryLogListRelationFilter = {
    every?: DeliveryLogWhereInput
    some?: DeliveryLogWhereInput
    none?: DeliveryLogWhereInput
  }

  export type DeliveryEditLogListRelationFilter = {
    every?: DeliveryEditLogWhereInput
    some?: DeliveryEditLogWhereInput
    none?: DeliveryEditLogWhereInput
  }

  export type WorkerNotificationListRelationFilter = {
    every?: WorkerNotificationWhereInput
    some?: WorkerNotificationWhereInput
    none?: WorkerNotificationWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ChatGroupMemberListRelationFilter = {
    every?: ChatGroupMemberWhereInput
    some?: ChatGroupMemberWhereInput
    none?: ChatGroupMemberWhereInput
  }

  export type GroupMessageListRelationFilter = {
    every?: GroupMessageWhereInput
    some?: GroupMessageWhereInput
    none?: GroupMessageWhereInput
  }

  export type NotificationDismissalListRelationFilter = {
    every?: NotificationDismissalWhereInput
    some?: NotificationDismissalWhereInput
    none?: NotificationDismissalWhereInput
  }

  export type SystemNotificationListRelationFilter = {
    every?: SystemNotificationWhereInput
    some?: SystemNotificationWhereInput
    none?: SystemNotificationWhereInput
  }

  export type AiActionListRelationFilter = {
    every?: AiActionWhereInput
    some?: AiActionWhereInput
    none?: AiActionWhereInput
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkerAttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryEditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkerNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatGroupMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationDismissalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SystemNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    plainPassword?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    whatsapp?: SortOrder
    baliAddress?: SortOrder
    mapsAddressLink?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    isVerified?: SortOrder
    resetPasswordExpires?: SortOrder
    resetPasswordToken?: SortOrder
    isActive?: SortOrder
    profileImage?: SortOrder
    identityFile?: SortOrder
    identityType?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    plainPassword?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    whatsapp?: SortOrder
    baliAddress?: SortOrder
    mapsAddressLink?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    isVerified?: SortOrder
    resetPasswordExpires?: SortOrder
    resetPasswordToken?: SortOrder
    isActive?: SortOrder
    profileImage?: SortOrder
    identityFile?: SortOrder
    identityType?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    plainPassword?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    whatsapp?: SortOrder
    baliAddress?: SortOrder
    mapsAddressLink?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    isVerified?: SortOrder
    resetPasswordExpires?: SortOrder
    resetPasswordToken?: SortOrder
    isActive?: SortOrder
    profileImage?: SortOrder
    identityFile?: SortOrder
    identityType?: SortOrder
  }

  export type ChatGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatGroupScalarRelationFilter = {
    is?: ChatGroupWhereInput
    isNot?: ChatGroupWhereInput
  }

  export type ChatGroupMemberGroupIdUserIdCompoundUniqueInput = {
    groupId: string
    userId: string
  }

  export type ChatGroupMemberCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type ChatGroupMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type ChatGroupMemberMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type GroupMessageCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type GroupMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type GroupMessageMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type SiteSettingCountOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    section?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SiteSettingMaxOrderByAggregateInput = {
    key?: SortOrder
    section?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SiteSettingMinOrderByAggregateInput = {
    key?: SortOrder
    section?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type Enumattendance_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.attendance_status | Enumattendance_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.attendance_status[] | ListEnumattendance_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.attendance_status[] | ListEnumattendance_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumattendance_statusNullableFilter<$PrismaModel> | $Enums.attendance_status | null
  }

  export type WorkerAttendanceWorkerIdDateCompoundUniqueInput = {
    workerId: string
    date: Date | string
  }

  export type WorkerAttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    workerId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkerAttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    workerId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkerAttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    workerId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type Enumattendance_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.attendance_status | Enumattendance_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.attendance_status[] | ListEnumattendance_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.attendance_status[] | ListEnumattendance_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumattendance_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.attendance_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumattendance_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumattendance_statusNullableFilter<$PrismaModel>
  }

  export type Enuminventory_sourceFilter<$PrismaModel = never> = {
    equals?: $Enums.inventory_source | Enuminventory_sourceFieldRefInput<$PrismaModel>
    in?: $Enums.inventory_source[] | ListEnuminventory_sourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.inventory_source[] | ListEnuminventory_sourceFieldRefInput<$PrismaModel>
    not?: NestedEnuminventory_sourceFilter<$PrismaModel> | $Enums.inventory_source
  }

  export type InventorySyncLogCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    oldQuantity?: SortOrder
    newQuantity?: SortOrder
    updatedBy?: SortOrder
    source?: SortOrder
    conflict?: SortOrder
    resolved?: SortOrder
    resolvedBy?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type InventorySyncLogAvgOrderByAggregateInput = {
    oldQuantity?: SortOrder
    newQuantity?: SortOrder
  }

  export type InventorySyncLogMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    oldQuantity?: SortOrder
    newQuantity?: SortOrder
    updatedBy?: SortOrder
    source?: SortOrder
    conflict?: SortOrder
    resolved?: SortOrder
    resolvedBy?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type InventorySyncLogMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    oldQuantity?: SortOrder
    newQuantity?: SortOrder
    updatedBy?: SortOrder
    source?: SortOrder
    conflict?: SortOrder
    resolved?: SortOrder
    resolvedBy?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type InventorySyncLogSumOrderByAggregateInput = {
    oldQuantity?: SortOrder
    newQuantity?: SortOrder
  }

  export type Enuminventory_sourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inventory_source | Enuminventory_sourceFieldRefInput<$PrismaModel>
    in?: $Enums.inventory_source[] | ListEnuminventory_sourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.inventory_source[] | ListEnuminventory_sourceFieldRefInput<$PrismaModel>
    not?: NestedEnuminventory_sourceWithAggregatesFilter<$PrismaModel> | $Enums.inventory_source
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminventory_sourceFilter<$PrismaModel>
    _max?: NestedEnuminventory_sourceFilter<$PrismaModel>
  }

  export type WorkerNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    workerId?: SortOrder
    fromAdminId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkerNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    workerId?: SortOrder
    fromAdminId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkerNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    workerId?: SortOrder
    fromAdminId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationDismissalUserIdEntityIdEntityTypeCompoundUniqueInput = {
    userId: string
    entityId: string
    entityType: string
  }

  export type NotificationDismissalCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationDismissalMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationDismissalMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemJobLogCountOrderByAggregateInput = {
    id?: SortOrder
    jobName?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemJobLogMaxOrderByAggregateInput = {
    id?: SortOrder
    jobName?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemJobLogMinOrderByAggregateInput = {
    id?: SortOrder
    jobName?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type IdempotencyKeyCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    response?: SortOrder
  }

  export type IdempotencyKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
  }

  export type IdempotencyKeyMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type JobQueueCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    retryCount?: SortOrder
    runAt?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
    error?: SortOrder
  }

  export type JobQueueAvgOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type JobQueueMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    retryCount?: SortOrder
    runAt?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
    error?: SortOrder
  }

  export type JobQueueMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    retryCount?: SortOrder
    runAt?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
    error?: SortOrder
  }

  export type JobQueueSumOrderByAggregateInput = {
    retryCount?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type CronLockCountOrderByAggregateInput = {
    id?: SortOrder
    lockedAt?: SortOrder
    lockedBy?: SortOrder
  }

  export type CronLockMaxOrderByAggregateInput = {
    id?: SortOrder
    lockedAt?: SortOrder
    lockedBy?: SortOrder
  }

  export type CronLockMinOrderByAggregateInput = {
    id?: SortOrder
    lockedAt?: SortOrder
    lockedBy?: SortOrder
  }

  export type EnumAiAgentSystemNameFilter<$PrismaModel = never> = {
    equals?: $Enums.AiAgentSystemName | EnumAiAgentSystemNameFieldRefInput<$PrismaModel>
    in?: $Enums.AiAgentSystemName[] | ListEnumAiAgentSystemNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiAgentSystemName[] | ListEnumAiAgentSystemNameFieldRefInput<$PrismaModel>
    not?: NestedEnumAiAgentSystemNameFilter<$PrismaModel> | $Enums.AiAgentSystemName
  }

  export type AiPermissionNullableScalarRelationFilter = {
    is?: AiPermissionWhereInput | null
    isNot?: AiPermissionWhereInput | null
  }

  export type AiTrainingDataListRelationFilter = {
    every?: AiTrainingDataWhereInput
    some?: AiTrainingDataWhereInput
    none?: AiTrainingDataWhereInput
  }

  export type AiTrainingDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiAgentCountOrderByAggregateInput = {
    id?: SortOrder
    systemName?: SortOrder
    displayName?: SortOrder
    isActive?: SortOrder
    canMutateData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiAgentMaxOrderByAggregateInput = {
    id?: SortOrder
    systemName?: SortOrder
    displayName?: SortOrder
    isActive?: SortOrder
    canMutateData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiAgentMinOrderByAggregateInput = {
    id?: SortOrder
    systemName?: SortOrder
    displayName?: SortOrder
    isActive?: SortOrder
    canMutateData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAiAgentSystemNameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AiAgentSystemName | EnumAiAgentSystemNameFieldRefInput<$PrismaModel>
    in?: $Enums.AiAgentSystemName[] | ListEnumAiAgentSystemNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiAgentSystemName[] | ListEnumAiAgentSystemNameFieldRefInput<$PrismaModel>
    not?: NestedEnumAiAgentSystemNameWithAggregatesFilter<$PrismaModel> | $Enums.AiAgentSystemName
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAiAgentSystemNameFilter<$PrismaModel>
    _max?: NestedEnumAiAgentSystemNameFilter<$PrismaModel>
  }

  export type AiAgentScalarRelationFilter = {
    is?: AiAgentWhereInput
    isNot?: AiAgentWhereInput
  }

  export type AiPermissionCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    canModifyProducts?: SortOrder
    canModifyPackages?: SortOrder
    canModifyOrders?: SortOrder
    requiresAdminConfirmation?: SortOrder
  }

  export type AiPermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    canModifyProducts?: SortOrder
    canModifyPackages?: SortOrder
    canModifyOrders?: SortOrder
    requiresAdminConfirmation?: SortOrder
  }

  export type AiPermissionMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    canModifyProducts?: SortOrder
    canModifyPackages?: SortOrder
    canModifyOrders?: SortOrder
    requiresAdminConfirmation?: SortOrder
  }

  export type EnumAiActionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AiActionStatus | EnumAiActionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AiActionStatus[] | ListEnumAiActionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiActionStatus[] | ListEnumAiActionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAiActionStatusFilter<$PrismaModel> | $Enums.AiActionStatus
  }

  export type AiActionCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    actionType?: SortOrder
    payloadBefore?: SortOrder
    payloadAfter?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    executedAt?: SortOrder
  }

  export type AiActionMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    actionType?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    executedAt?: SortOrder
  }

  export type AiActionMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    actionType?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    executedAt?: SortOrder
  }

  export type EnumAiActionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AiActionStatus | EnumAiActionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AiActionStatus[] | ListEnumAiActionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiActionStatus[] | ListEnumAiActionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAiActionStatusWithAggregatesFilter<$PrismaModel> | $Enums.AiActionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAiActionStatusFilter<$PrismaModel>
    _max?: NestedEnumAiActionStatusFilter<$PrismaModel>
  }

  export type AiTrainingDataCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    suggestion?: SortOrder
    adminDecision?: SortOrder
    feedbackScore?: SortOrder
    createdAt?: SortOrder
  }

  export type AiTrainingDataAvgOrderByAggregateInput = {
    feedbackScore?: SortOrder
  }

  export type AiTrainingDataMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    suggestion?: SortOrder
    adminDecision?: SortOrder
    feedbackScore?: SortOrder
    createdAt?: SortOrder
  }

  export type AiTrainingDataMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    suggestion?: SortOrder
    adminDecision?: SortOrder
    feedbackScore?: SortOrder
    createdAt?: SortOrder
  }

  export type AiTrainingDataSumOrderByAggregateInput = {
    feedbackScore?: SortOrder
  }

  export type EnumVehicleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleType | EnumVehicleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVehicleTypeFilter<$PrismaModel> | $Enums.VehicleType
  }

  export type EnumVehicleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleStatus | EnumVehicleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleStatus[] | ListEnumVehicleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VehicleStatus[] | ListEnumVehicleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVehicleStatusFilter<$PrismaModel> | $Enums.VehicleStatus
  }

  export type VehicleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    currentDeliveryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    currentDeliveryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    currentDeliveryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumVehicleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleType | EnumVehicleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVehicleTypeWithAggregatesFilter<$PrismaModel> | $Enums.VehicleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVehicleTypeFilter<$PrismaModel>
    _max?: NestedEnumVehicleTypeFilter<$PrismaModel>
  }

  export type EnumVehicleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleStatus | EnumVehicleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleStatus[] | ListEnumVehicleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VehicleStatus[] | ListEnumVehicleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVehicleStatusWithAggregatesFilter<$PrismaModel> | $Enums.VehicleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVehicleStatusFilter<$PrismaModel>
    _max?: NestedEnumVehicleStatusFilter<$PrismaModel>
  }

  export type EnumDeliveryMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryMethod | EnumDeliveryMethodFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryMethod[] | ListEnumDeliveryMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryMethod[] | ListEnumDeliveryMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryMethodFilter<$PrismaModel> | $Enums.DeliveryMethod
  }

  export type EnumDeliveryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryType | EnumDeliveryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryType[] | ListEnumDeliveryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryType[] | ListEnumDeliveryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryTypeFilter<$PrismaModel> | $Enums.DeliveryType
  }

  export type EnumDeliveryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryStatus | EnumDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryStatusFilter<$PrismaModel> | $Enums.DeliveryStatus
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type VehicleNullableScalarRelationFilter = {
    is?: VehicleWhereInput | null
    isNot?: VehicleWhereInput | null
  }

  export type DeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    deliveryMethod?: SortOrder
    deliveryType?: SortOrder
    vehicleId?: SortOrder
    status?: SortOrder
    claimedByWorkerId?: SortOrder
    claimedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    eta?: SortOrder
    etaOverrideCount?: SortOrder
    delayMinutes?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    lastLocationUpdate?: SortOrder
    trackingCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryAvgOrderByAggregateInput = {
    etaOverrideCount?: SortOrder
    delayMinutes?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type DeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    deliveryMethod?: SortOrder
    deliveryType?: SortOrder
    vehicleId?: SortOrder
    status?: SortOrder
    claimedByWorkerId?: SortOrder
    claimedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    eta?: SortOrder
    etaOverrideCount?: SortOrder
    delayMinutes?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    lastLocationUpdate?: SortOrder
    trackingCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    deliveryMethod?: SortOrder
    deliveryType?: SortOrder
    vehicleId?: SortOrder
    status?: SortOrder
    claimedByWorkerId?: SortOrder
    claimedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    eta?: SortOrder
    etaOverrideCount?: SortOrder
    delayMinutes?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    lastLocationUpdate?: SortOrder
    trackingCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliverySumOrderByAggregateInput = {
    etaOverrideCount?: SortOrder
    delayMinutes?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type EnumDeliveryMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryMethod | EnumDeliveryMethodFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryMethod[] | ListEnumDeliveryMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryMethod[] | ListEnumDeliveryMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryMethodWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryMethodFilter<$PrismaModel>
    _max?: NestedEnumDeliveryMethodFilter<$PrismaModel>
  }

  export type EnumDeliveryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryType | EnumDeliveryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryType[] | ListEnumDeliveryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryType[] | ListEnumDeliveryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryTypeWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryTypeFilter<$PrismaModel>
    _max?: NestedEnumDeliveryTypeFilter<$PrismaModel>
  }

  export type EnumDeliveryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryStatus | EnumDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryStatusFilter<$PrismaModel>
    _max?: NestedEnumDeliveryStatusFilter<$PrismaModel>
  }

  export type DeliveryScalarRelationFilter = {
    is?: DeliveryWhereInput
    isNot?: DeliveryWhereInput
  }

  export type RentalItemScalarRelationFilter = {
    is?: RentalItemWhereInput
    isNot?: RentalItemWhereInput
  }

  export type DeliveryItemCountOrderByAggregateInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    rentalItemId?: SortOrder
    quantity?: SortOrder
  }

  export type DeliveryItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type DeliveryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    rentalItemId?: SortOrder
    quantity?: SortOrder
  }

  export type DeliveryItemMinOrderByAggregateInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    rentalItemId?: SortOrder
    quantity?: SortOrder
  }

  export type DeliveryItemSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumDeliveryRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryRole | EnumDeliveryRoleFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryRole[] | ListEnumDeliveryRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryRole[] | ListEnumDeliveryRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryRoleFilter<$PrismaModel> | $Enums.DeliveryRole
  }

  export type DeliveryLogCountOrderByAggregateInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    eventType?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    createdByUserId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type DeliveryLogMaxOrderByAggregateInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    eventType?: SortOrder
    createdByUserId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type DeliveryLogMinOrderByAggregateInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    eventType?: SortOrder
    createdByUserId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumDeliveryRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryRole | EnumDeliveryRoleFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryRole[] | ListEnumDeliveryRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryRole[] | ListEnumDeliveryRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryRoleWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryRoleFilter<$PrismaModel>
    _max?: NestedEnumDeliveryRoleFilter<$PrismaModel>
  }

  export type DeliveryEditLogCountOrderByAggregateInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    editedByUserId?: SortOrder
    role?: SortOrder
    fieldChanged?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type DeliveryEditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    editedByUserId?: SortOrder
    role?: SortOrder
    fieldChanged?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type DeliveryEditLogMinOrderByAggregateInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    editedByUserId?: SortOrder
    role?: SortOrder
    fieldChanged?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type SpecialOfferCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    badgeText?: SortOrder
    discountPercentage?: SortOrder
    originalPrice?: SortOrder
    finalPrice?: SortOrder
    images?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type SpecialOfferAvgOrderByAggregateInput = {
    discountPercentage?: SortOrder
    originalPrice?: SortOrder
    finalPrice?: SortOrder
  }

  export type SpecialOfferMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    badgeText?: SortOrder
    discountPercentage?: SortOrder
    originalPrice?: SortOrder
    finalPrice?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type SpecialOfferMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    badgeText?: SortOrder
    discountPercentage?: SortOrder
    originalPrice?: SortOrder
    finalPrice?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type SpecialOfferSumOrderByAggregateInput = {
    discountPercentage?: SortOrder
    originalPrice?: SortOrder
    finalPrice?: SortOrder
  }

  export type ContactMessageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactMessageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<OrderCreateWithoutInvoicesInput, OrderUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInvoicesInput
    connect?: OrderWhereUniqueInput
  }

  export type DeliveryCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<DeliveryCreateWithoutInvoiceInput, DeliveryUncheckedCreateWithoutInvoiceInput> | DeliveryCreateWithoutInvoiceInput[] | DeliveryUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutInvoiceInput | DeliveryCreateOrConnectWithoutInvoiceInput[]
    createMany?: DeliveryCreateManyInvoiceInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    connect?: UserWhereUniqueInput
  }

  export type DeliveryUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<DeliveryCreateWithoutInvoiceInput, DeliveryUncheckedCreateWithoutInvoiceInput> | DeliveryCreateWithoutInvoiceInput[] | DeliveryUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutInvoiceInput | DeliveryCreateOrConnectWithoutInvoiceInput[]
    createMany?: DeliveryCreateManyInvoiceInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type OrderUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<OrderCreateWithoutInvoicesInput, OrderUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInvoicesInput
    upsert?: OrderUpsertWithoutInvoicesInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutInvoicesInput, OrderUpdateWithoutInvoicesInput>, OrderUncheckedUpdateWithoutInvoicesInput>
  }

  export type DeliveryUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<DeliveryCreateWithoutInvoiceInput, DeliveryUncheckedCreateWithoutInvoiceInput> | DeliveryCreateWithoutInvoiceInput[] | DeliveryUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutInvoiceInput | DeliveryCreateOrConnectWithoutInvoiceInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutInvoiceInput | DeliveryUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: DeliveryCreateManyInvoiceInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutInvoiceInput | DeliveryUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutInvoiceInput | DeliveryUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type UserUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    upsert?: UserUpsertWithoutInvoicesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoicesInput, UserUpdateWithoutInvoicesInput>, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type DeliveryUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<DeliveryCreateWithoutInvoiceInput, DeliveryUncheckedCreateWithoutInvoiceInput> | DeliveryCreateWithoutInvoiceInput[] | DeliveryUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutInvoiceInput | DeliveryCreateOrConnectWithoutInvoiceInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutInvoiceInput | DeliveryUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: DeliveryCreateManyInvoiceInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutInvoiceInput | DeliveryUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutInvoiceInput | DeliveryUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type InvoiceCreateNestedManyWithoutOrderInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput> | InvoiceCreateWithoutOrderInput[] | InvoiceUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput | InvoiceCreateOrConnectWithoutOrderInput[]
    createMany?: InvoiceCreateManyOrderInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type ProductUnitCreateNestedManyWithoutAssignedOrderInput = {
    create?: XOR<ProductUnitCreateWithoutAssignedOrderInput, ProductUnitUncheckedCreateWithoutAssignedOrderInput> | ProductUnitCreateWithoutAssignedOrderInput[] | ProductUnitUncheckedCreateWithoutAssignedOrderInput[]
    connectOrCreate?: ProductUnitCreateOrConnectWithoutAssignedOrderInput | ProductUnitCreateOrConnectWithoutAssignedOrderInput[]
    createMany?: ProductUnitCreateManyAssignedOrderInputEnvelope
    connect?: ProductUnitWhereUniqueInput | ProductUnitWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutOrders_orders_payment_confirmed_byTousersInput = {
    create?: XOR<UserCreateWithoutOrders_orders_payment_confirmed_byTousersInput, UserUncheckedCreateWithoutOrders_orders_payment_confirmed_byTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrders_orders_payment_confirmed_byTousersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type RentalItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<RentalItemCreateWithoutOrderInput, RentalItemUncheckedCreateWithoutOrderInput> | RentalItemCreateWithoutOrderInput[] | RentalItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: RentalItemCreateOrConnectWithoutOrderInput | RentalItemCreateOrConnectWithoutOrderInput[]
    createMany?: RentalItemCreateManyOrderInputEnvelope
    connect?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
  }

  export type PaymentTransactionCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentTransactionCreateWithoutOrderInput, PaymentTransactionUncheckedCreateWithoutOrderInput> | PaymentTransactionCreateWithoutOrderInput[] | PaymentTransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutOrderInput | PaymentTransactionCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentTransactionCreateManyOrderInputEnvelope
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput> | InvoiceCreateWithoutOrderInput[] | InvoiceUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput | InvoiceCreateOrConnectWithoutOrderInput[]
    createMany?: InvoiceCreateManyOrderInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type ProductUnitUncheckedCreateNestedManyWithoutAssignedOrderInput = {
    create?: XOR<ProductUnitCreateWithoutAssignedOrderInput, ProductUnitUncheckedCreateWithoutAssignedOrderInput> | ProductUnitCreateWithoutAssignedOrderInput[] | ProductUnitUncheckedCreateWithoutAssignedOrderInput[]
    connectOrCreate?: ProductUnitCreateOrConnectWithoutAssignedOrderInput | ProductUnitCreateOrConnectWithoutAssignedOrderInput[]
    createMany?: ProductUnitCreateManyAssignedOrderInputEnvelope
    connect?: ProductUnitWhereUniqueInput | ProductUnitWhereUniqueInput[]
  }

  export type RentalItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<RentalItemCreateWithoutOrderInput, RentalItemUncheckedCreateWithoutOrderInput> | RentalItemCreateWithoutOrderInput[] | RentalItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: RentalItemCreateOrConnectWithoutOrderInput | RentalItemCreateOrConnectWithoutOrderInput[]
    createMany?: RentalItemCreateManyOrderInputEnvelope
    connect?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
  }

  export type PaymentTransactionUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentTransactionCreateWithoutOrderInput, PaymentTransactionUncheckedCreateWithoutOrderInput> | PaymentTransactionCreateWithoutOrderInput[] | PaymentTransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutOrderInput | PaymentTransactionCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentTransactionCreateManyOrderInputEnvelope
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InvoiceUpdateManyWithoutOrderNestedInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput> | InvoiceCreateWithoutOrderInput[] | InvoiceUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput | InvoiceCreateOrConnectWithoutOrderInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutOrderInput | InvoiceUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: InvoiceCreateManyOrderInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutOrderInput | InvoiceUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutOrderInput | InvoiceUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type ProductUnitUpdateManyWithoutAssignedOrderNestedInput = {
    create?: XOR<ProductUnitCreateWithoutAssignedOrderInput, ProductUnitUncheckedCreateWithoutAssignedOrderInput> | ProductUnitCreateWithoutAssignedOrderInput[] | ProductUnitUncheckedCreateWithoutAssignedOrderInput[]
    connectOrCreate?: ProductUnitCreateOrConnectWithoutAssignedOrderInput | ProductUnitCreateOrConnectWithoutAssignedOrderInput[]
    upsert?: ProductUnitUpsertWithWhereUniqueWithoutAssignedOrderInput | ProductUnitUpsertWithWhereUniqueWithoutAssignedOrderInput[]
    createMany?: ProductUnitCreateManyAssignedOrderInputEnvelope
    set?: ProductUnitWhereUniqueInput | ProductUnitWhereUniqueInput[]
    disconnect?: ProductUnitWhereUniqueInput | ProductUnitWhereUniqueInput[]
    delete?: ProductUnitWhereUniqueInput | ProductUnitWhereUniqueInput[]
    connect?: ProductUnitWhereUniqueInput | ProductUnitWhereUniqueInput[]
    update?: ProductUnitUpdateWithWhereUniqueWithoutAssignedOrderInput | ProductUnitUpdateWithWhereUniqueWithoutAssignedOrderInput[]
    updateMany?: ProductUnitUpdateManyWithWhereWithoutAssignedOrderInput | ProductUnitUpdateManyWithWhereWithoutAssignedOrderInput[]
    deleteMany?: ProductUnitScalarWhereInput | ProductUnitScalarWhereInput[]
  }

  export type UserUpdateOneWithoutOrders_orders_payment_confirmed_byTousersNestedInput = {
    create?: XOR<UserCreateWithoutOrders_orders_payment_confirmed_byTousersInput, UserUncheckedCreateWithoutOrders_orders_payment_confirmed_byTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrders_orders_payment_confirmed_byTousersInput
    upsert?: UserUpsertWithoutOrders_orders_payment_confirmed_byTousersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrders_orders_payment_confirmed_byTousersInput, UserUpdateWithoutOrders_orders_payment_confirmed_byTousersInput>, UserUncheckedUpdateWithoutOrders_orders_payment_confirmed_byTousersInput>
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type RentalItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<RentalItemCreateWithoutOrderInput, RentalItemUncheckedCreateWithoutOrderInput> | RentalItemCreateWithoutOrderInput[] | RentalItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: RentalItemCreateOrConnectWithoutOrderInput | RentalItemCreateOrConnectWithoutOrderInput[]
    upsert?: RentalItemUpsertWithWhereUniqueWithoutOrderInput | RentalItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: RentalItemCreateManyOrderInputEnvelope
    set?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    disconnect?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    delete?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    connect?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    update?: RentalItemUpdateWithWhereUniqueWithoutOrderInput | RentalItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: RentalItemUpdateManyWithWhereWithoutOrderInput | RentalItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: RentalItemScalarWhereInput | RentalItemScalarWhereInput[]
  }

  export type PaymentTransactionUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentTransactionCreateWithoutOrderInput, PaymentTransactionUncheckedCreateWithoutOrderInput> | PaymentTransactionCreateWithoutOrderInput[] | PaymentTransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutOrderInput | PaymentTransactionCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentTransactionUpsertWithWhereUniqueWithoutOrderInput | PaymentTransactionUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentTransactionCreateManyOrderInputEnvelope
    set?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    disconnect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    delete?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    update?: PaymentTransactionUpdateWithWhereUniqueWithoutOrderInput | PaymentTransactionUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentTransactionUpdateManyWithWhereWithoutOrderInput | PaymentTransactionUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentTransactionScalarWhereInput | PaymentTransactionScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput> | InvoiceCreateWithoutOrderInput[] | InvoiceUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput | InvoiceCreateOrConnectWithoutOrderInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutOrderInput | InvoiceUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: InvoiceCreateManyOrderInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutOrderInput | InvoiceUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutOrderInput | InvoiceUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type ProductUnitUncheckedUpdateManyWithoutAssignedOrderNestedInput = {
    create?: XOR<ProductUnitCreateWithoutAssignedOrderInput, ProductUnitUncheckedCreateWithoutAssignedOrderInput> | ProductUnitCreateWithoutAssignedOrderInput[] | ProductUnitUncheckedCreateWithoutAssignedOrderInput[]
    connectOrCreate?: ProductUnitCreateOrConnectWithoutAssignedOrderInput | ProductUnitCreateOrConnectWithoutAssignedOrderInput[]
    upsert?: ProductUnitUpsertWithWhereUniqueWithoutAssignedOrderInput | ProductUnitUpsertWithWhereUniqueWithoutAssignedOrderInput[]
    createMany?: ProductUnitCreateManyAssignedOrderInputEnvelope
    set?: ProductUnitWhereUniqueInput | ProductUnitWhereUniqueInput[]
    disconnect?: ProductUnitWhereUniqueInput | ProductUnitWhereUniqueInput[]
    delete?: ProductUnitWhereUniqueInput | ProductUnitWhereUniqueInput[]
    connect?: ProductUnitWhereUniqueInput | ProductUnitWhereUniqueInput[]
    update?: ProductUnitUpdateWithWhereUniqueWithoutAssignedOrderInput | ProductUnitUpdateWithWhereUniqueWithoutAssignedOrderInput[]
    updateMany?: ProductUnitUpdateManyWithWhereWithoutAssignedOrderInput | ProductUnitUpdateManyWithWhereWithoutAssignedOrderInput[]
    deleteMany?: ProductUnitScalarWhereInput | ProductUnitScalarWhereInput[]
  }

  export type RentalItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<RentalItemCreateWithoutOrderInput, RentalItemUncheckedCreateWithoutOrderInput> | RentalItemCreateWithoutOrderInput[] | RentalItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: RentalItemCreateOrConnectWithoutOrderInput | RentalItemCreateOrConnectWithoutOrderInput[]
    upsert?: RentalItemUpsertWithWhereUniqueWithoutOrderInput | RentalItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: RentalItemCreateManyOrderInputEnvelope
    set?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    disconnect?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    delete?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    connect?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    update?: RentalItemUpdateWithWhereUniqueWithoutOrderInput | RentalItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: RentalItemUpdateManyWithWhereWithoutOrderInput | RentalItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: RentalItemScalarWhereInput | RentalItemScalarWhereInput[]
  }

  export type PaymentTransactionUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentTransactionCreateWithoutOrderInput, PaymentTransactionUncheckedCreateWithoutOrderInput> | PaymentTransactionCreateWithoutOrderInput[] | PaymentTransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutOrderInput | PaymentTransactionCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentTransactionUpsertWithWhereUniqueWithoutOrderInput | PaymentTransactionUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentTransactionCreateManyOrderInputEnvelope
    set?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    disconnect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    delete?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    update?: PaymentTransactionUpdateWithWhereUniqueWithoutOrderInput | PaymentTransactionUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentTransactionUpdateManyWithWhereWithoutOrderInput | PaymentTransactionUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentTransactionScalarWhereInput | PaymentTransactionScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutPaymentTransactionsInput = {
    create?: XOR<OrderCreateWithoutPaymentTransactionsInput, OrderUncheckedCreateWithoutPaymentTransactionsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentTransactionsInput
    connect?: OrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVerifiedTransactionsInput = {
    create?: XOR<UserCreateWithoutVerifiedTransactionsInput, UserUncheckedCreateWithoutVerifiedTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerifiedTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPaymentProviderFieldUpdateOperationsInput = {
    set?: $Enums.PaymentProvider
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type OrderUpdateOneRequiredWithoutPaymentTransactionsNestedInput = {
    create?: XOR<OrderCreateWithoutPaymentTransactionsInput, OrderUncheckedCreateWithoutPaymentTransactionsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentTransactionsInput
    upsert?: OrderUpsertWithoutPaymentTransactionsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPaymentTransactionsInput, OrderUpdateWithoutPaymentTransactionsInput>, OrderUncheckedUpdateWithoutPaymentTransactionsInput>
  }

  export type UserUpdateOneWithoutVerifiedTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutVerifiedTransactionsInput, UserUncheckedCreateWithoutVerifiedTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerifiedTransactionsInput
    upsert?: UserUpsertWithoutVerifiedTransactionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVerifiedTransactionsInput, UserUpdateWithoutVerifiedTransactionsInput>, UserUncheckedUpdateWithoutVerifiedTransactionsInput>
  }

  export type ProductCreateNestedOneWithoutProductRelationsInput = {
    create?: XOR<ProductCreateWithoutProductRelationsInput, ProductUncheckedCreateWithoutProductRelationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductRelationsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutRelatedToInput = {
    create?: XOR<ProductCreateWithoutRelatedToInput, ProductUncheckedCreateWithoutRelatedToInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRelatedToInput
    connect?: ProductWhereUniqueInput
  }

  export type EnumRelationTypeFieldUpdateOperationsInput = {
    set?: $Enums.RelationType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductUpdateOneRequiredWithoutProductRelationsNestedInput = {
    create?: XOR<ProductCreateWithoutProductRelationsInput, ProductUncheckedCreateWithoutProductRelationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductRelationsInput
    upsert?: ProductUpsertWithoutProductRelationsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductRelationsInput, ProductUpdateWithoutProductRelationsInput>, ProductUncheckedUpdateWithoutProductRelationsInput>
  }

  export type ProductUpdateOneRequiredWithoutRelatedToNestedInput = {
    create?: XOR<ProductCreateWithoutRelatedToInput, ProductUncheckedCreateWithoutRelatedToInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRelatedToInput
    upsert?: ProductUpsertWithoutRelatedToInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutRelatedToInput, ProductUpdateWithoutRelatedToInput>, ProductUncheckedUpdateWithoutRelatedToInput>
  }

  export type RentalPackageCreateNestedOneWithoutRentalPackageItemsInput = {
    create?: XOR<RentalPackageCreateWithoutRentalPackageItemsInput, RentalPackageUncheckedCreateWithoutRentalPackageItemsInput>
    connectOrCreate?: RentalPackageCreateOrConnectWithoutRentalPackageItemsInput
    connect?: RentalPackageWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutRentalPackageItemsInput = {
    create?: XOR<ProductCreateWithoutRentalPackageItemsInput, ProductUncheckedCreateWithoutRentalPackageItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRentalPackageItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type RentalPackageUpdateOneRequiredWithoutRentalPackageItemsNestedInput = {
    create?: XOR<RentalPackageCreateWithoutRentalPackageItemsInput, RentalPackageUncheckedCreateWithoutRentalPackageItemsInput>
    connectOrCreate?: RentalPackageCreateOrConnectWithoutRentalPackageItemsInput
    upsert?: RentalPackageUpsertWithoutRentalPackageItemsInput
    connect?: RentalPackageWhereUniqueInput
    update?: XOR<XOR<RentalPackageUpdateToOneWithWhereWithoutRentalPackageItemsInput, RentalPackageUpdateWithoutRentalPackageItemsInput>, RentalPackageUncheckedUpdateWithoutRentalPackageItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutRentalPackageItemsNestedInput = {
    create?: XOR<ProductCreateWithoutRentalPackageItemsInput, ProductUncheckedCreateWithoutRentalPackageItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRentalPackageItemsInput
    upsert?: ProductUpsertWithoutRentalPackageItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutRentalPackageItemsInput, ProductUpdateWithoutRentalPackageItemsInput>, ProductUncheckedUpdateWithoutRentalPackageItemsInput>
  }

  export type RentalPackageCreateimagesInput = {
    set: string[]
  }

  export type RentalPackageItemCreateNestedManyWithoutRentalPackageInput = {
    create?: XOR<RentalPackageItemCreateWithoutRentalPackageInput, RentalPackageItemUncheckedCreateWithoutRentalPackageInput> | RentalPackageItemCreateWithoutRentalPackageInput[] | RentalPackageItemUncheckedCreateWithoutRentalPackageInput[]
    connectOrCreate?: RentalPackageItemCreateOrConnectWithoutRentalPackageInput | RentalPackageItemCreateOrConnectWithoutRentalPackageInput[]
    createMany?: RentalPackageItemCreateManyRentalPackageInputEnvelope
    connect?: RentalPackageItemWhereUniqueInput | RentalPackageItemWhereUniqueInput[]
  }

  export type RentalItemCreateNestedManyWithoutRentalPackageInput = {
    create?: XOR<RentalItemCreateWithoutRentalPackageInput, RentalItemUncheckedCreateWithoutRentalPackageInput> | RentalItemCreateWithoutRentalPackageInput[] | RentalItemUncheckedCreateWithoutRentalPackageInput[]
    connectOrCreate?: RentalItemCreateOrConnectWithoutRentalPackageInput | RentalItemCreateOrConnectWithoutRentalPackageInput[]
    createMany?: RentalItemCreateManyRentalPackageInputEnvelope
    connect?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
  }

  export type RentalPackageItemUncheckedCreateNestedManyWithoutRentalPackageInput = {
    create?: XOR<RentalPackageItemCreateWithoutRentalPackageInput, RentalPackageItemUncheckedCreateWithoutRentalPackageInput> | RentalPackageItemCreateWithoutRentalPackageInput[] | RentalPackageItemUncheckedCreateWithoutRentalPackageInput[]
    connectOrCreate?: RentalPackageItemCreateOrConnectWithoutRentalPackageInput | RentalPackageItemCreateOrConnectWithoutRentalPackageInput[]
    createMany?: RentalPackageItemCreateManyRentalPackageInputEnvelope
    connect?: RentalPackageItemWhereUniqueInput | RentalPackageItemWhereUniqueInput[]
  }

  export type RentalItemUncheckedCreateNestedManyWithoutRentalPackageInput = {
    create?: XOR<RentalItemCreateWithoutRentalPackageInput, RentalItemUncheckedCreateWithoutRentalPackageInput> | RentalItemCreateWithoutRentalPackageInput[] | RentalItemUncheckedCreateWithoutRentalPackageInput[]
    connectOrCreate?: RentalItemCreateOrConnectWithoutRentalPackageInput | RentalItemCreateOrConnectWithoutRentalPackageInput[]
    createMany?: RentalItemCreateManyRentalPackageInputEnvelope
    connect?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
  }

  export type RentalPackageUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RentalPackageItemUpdateManyWithoutRentalPackageNestedInput = {
    create?: XOR<RentalPackageItemCreateWithoutRentalPackageInput, RentalPackageItemUncheckedCreateWithoutRentalPackageInput> | RentalPackageItemCreateWithoutRentalPackageInput[] | RentalPackageItemUncheckedCreateWithoutRentalPackageInput[]
    connectOrCreate?: RentalPackageItemCreateOrConnectWithoutRentalPackageInput | RentalPackageItemCreateOrConnectWithoutRentalPackageInput[]
    upsert?: RentalPackageItemUpsertWithWhereUniqueWithoutRentalPackageInput | RentalPackageItemUpsertWithWhereUniqueWithoutRentalPackageInput[]
    createMany?: RentalPackageItemCreateManyRentalPackageInputEnvelope
    set?: RentalPackageItemWhereUniqueInput | RentalPackageItemWhereUniqueInput[]
    disconnect?: RentalPackageItemWhereUniqueInput | RentalPackageItemWhereUniqueInput[]
    delete?: RentalPackageItemWhereUniqueInput | RentalPackageItemWhereUniqueInput[]
    connect?: RentalPackageItemWhereUniqueInput | RentalPackageItemWhereUniqueInput[]
    update?: RentalPackageItemUpdateWithWhereUniqueWithoutRentalPackageInput | RentalPackageItemUpdateWithWhereUniqueWithoutRentalPackageInput[]
    updateMany?: RentalPackageItemUpdateManyWithWhereWithoutRentalPackageInput | RentalPackageItemUpdateManyWithWhereWithoutRentalPackageInput[]
    deleteMany?: RentalPackageItemScalarWhereInput | RentalPackageItemScalarWhereInput[]
  }

  export type RentalItemUpdateManyWithoutRentalPackageNestedInput = {
    create?: XOR<RentalItemCreateWithoutRentalPackageInput, RentalItemUncheckedCreateWithoutRentalPackageInput> | RentalItemCreateWithoutRentalPackageInput[] | RentalItemUncheckedCreateWithoutRentalPackageInput[]
    connectOrCreate?: RentalItemCreateOrConnectWithoutRentalPackageInput | RentalItemCreateOrConnectWithoutRentalPackageInput[]
    upsert?: RentalItemUpsertWithWhereUniqueWithoutRentalPackageInput | RentalItemUpsertWithWhereUniqueWithoutRentalPackageInput[]
    createMany?: RentalItemCreateManyRentalPackageInputEnvelope
    set?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    disconnect?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    delete?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    connect?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    update?: RentalItemUpdateWithWhereUniqueWithoutRentalPackageInput | RentalItemUpdateWithWhereUniqueWithoutRentalPackageInput[]
    updateMany?: RentalItemUpdateManyWithWhereWithoutRentalPackageInput | RentalItemUpdateManyWithWhereWithoutRentalPackageInput[]
    deleteMany?: RentalItemScalarWhereInput | RentalItemScalarWhereInput[]
  }

  export type RentalPackageItemUncheckedUpdateManyWithoutRentalPackageNestedInput = {
    create?: XOR<RentalPackageItemCreateWithoutRentalPackageInput, RentalPackageItemUncheckedCreateWithoutRentalPackageInput> | RentalPackageItemCreateWithoutRentalPackageInput[] | RentalPackageItemUncheckedCreateWithoutRentalPackageInput[]
    connectOrCreate?: RentalPackageItemCreateOrConnectWithoutRentalPackageInput | RentalPackageItemCreateOrConnectWithoutRentalPackageInput[]
    upsert?: RentalPackageItemUpsertWithWhereUniqueWithoutRentalPackageInput | RentalPackageItemUpsertWithWhereUniqueWithoutRentalPackageInput[]
    createMany?: RentalPackageItemCreateManyRentalPackageInputEnvelope
    set?: RentalPackageItemWhereUniqueInput | RentalPackageItemWhereUniqueInput[]
    disconnect?: RentalPackageItemWhereUniqueInput | RentalPackageItemWhereUniqueInput[]
    delete?: RentalPackageItemWhereUniqueInput | RentalPackageItemWhereUniqueInput[]
    connect?: RentalPackageItemWhereUniqueInput | RentalPackageItemWhereUniqueInput[]
    update?: RentalPackageItemUpdateWithWhereUniqueWithoutRentalPackageInput | RentalPackageItemUpdateWithWhereUniqueWithoutRentalPackageInput[]
    updateMany?: RentalPackageItemUpdateManyWithWhereWithoutRentalPackageInput | RentalPackageItemUpdateManyWithWhereWithoutRentalPackageInput[]
    deleteMany?: RentalPackageItemScalarWhereInput | RentalPackageItemScalarWhereInput[]
  }

  export type RentalItemUncheckedUpdateManyWithoutRentalPackageNestedInput = {
    create?: XOR<RentalItemCreateWithoutRentalPackageInput, RentalItemUncheckedCreateWithoutRentalPackageInput> | RentalItemCreateWithoutRentalPackageInput[] | RentalItemUncheckedCreateWithoutRentalPackageInput[]
    connectOrCreate?: RentalItemCreateOrConnectWithoutRentalPackageInput | RentalItemCreateOrConnectWithoutRentalPackageInput[]
    upsert?: RentalItemUpsertWithWhereUniqueWithoutRentalPackageInput | RentalItemUpsertWithWhereUniqueWithoutRentalPackageInput[]
    createMany?: RentalItemCreateManyRentalPackageInputEnvelope
    set?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    disconnect?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    delete?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    connect?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    update?: RentalItemUpdateWithWhereUniqueWithoutRentalPackageInput | RentalItemUpdateWithWhereUniqueWithoutRentalPackageInput[]
    updateMany?: RentalItemUpdateManyWithWhereWithoutRentalPackageInput | RentalItemUpdateManyWithWhereWithoutRentalPackageInput[]
    deleteMany?: RentalItemScalarWhereInput | RentalItemScalarWhereInput[]
  }

  export type ProductCreateimagesInput = {
    set: string[]
  }

  export type InventorySyncLogCreateNestedManyWithoutProductInput = {
    create?: XOR<InventorySyncLogCreateWithoutProductInput, InventorySyncLogUncheckedCreateWithoutProductInput> | InventorySyncLogCreateWithoutProductInput[] | InventorySyncLogUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventorySyncLogCreateOrConnectWithoutProductInput | InventorySyncLogCreateOrConnectWithoutProductInput[]
    createMany?: InventorySyncLogCreateManyProductInputEnvelope
    connect?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
  }

  export type RentalPackageItemCreateNestedManyWithoutProductInput = {
    create?: XOR<RentalPackageItemCreateWithoutProductInput, RentalPackageItemUncheckedCreateWithoutProductInput> | RentalPackageItemCreateWithoutProductInput[] | RentalPackageItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RentalPackageItemCreateOrConnectWithoutProductInput | RentalPackageItemCreateOrConnectWithoutProductInput[]
    createMany?: RentalPackageItemCreateManyProductInputEnvelope
    connect?: RentalPackageItemWhereUniqueInput | RentalPackageItemWhereUniqueInput[]
  }

  export type ProductRelationCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductRelationCreateWithoutProductInput, ProductRelationUncheckedCreateWithoutProductInput> | ProductRelationCreateWithoutProductInput[] | ProductRelationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductRelationCreateOrConnectWithoutProductInput | ProductRelationCreateOrConnectWithoutProductInput[]
    createMany?: ProductRelationCreateManyProductInputEnvelope
    connect?: ProductRelationWhereUniqueInput | ProductRelationWhereUniqueInput[]
  }

  export type ProductRelationCreateNestedManyWithoutRelatedProductInput = {
    create?: XOR<ProductRelationCreateWithoutRelatedProductInput, ProductRelationUncheckedCreateWithoutRelatedProductInput> | ProductRelationCreateWithoutRelatedProductInput[] | ProductRelationUncheckedCreateWithoutRelatedProductInput[]
    connectOrCreate?: ProductRelationCreateOrConnectWithoutRelatedProductInput | ProductRelationCreateOrConnectWithoutRelatedProductInput[]
    createMany?: ProductRelationCreateManyRelatedProductInputEnvelope
    connect?: ProductRelationWhereUniqueInput | ProductRelationWhereUniqueInput[]
  }

  export type ProductVariantCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
  }

  export type InventorySyncLogUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<InventorySyncLogCreateWithoutProductInput, InventorySyncLogUncheckedCreateWithoutProductInput> | InventorySyncLogCreateWithoutProductInput[] | InventorySyncLogUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventorySyncLogCreateOrConnectWithoutProductInput | InventorySyncLogCreateOrConnectWithoutProductInput[]
    createMany?: InventorySyncLogCreateManyProductInputEnvelope
    connect?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
  }

  export type RentalPackageItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<RentalPackageItemCreateWithoutProductInput, RentalPackageItemUncheckedCreateWithoutProductInput> | RentalPackageItemCreateWithoutProductInput[] | RentalPackageItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RentalPackageItemCreateOrConnectWithoutProductInput | RentalPackageItemCreateOrConnectWithoutProductInput[]
    createMany?: RentalPackageItemCreateManyProductInputEnvelope
    connect?: RentalPackageItemWhereUniqueInput | RentalPackageItemWhereUniqueInput[]
  }

  export type ProductRelationUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductRelationCreateWithoutProductInput, ProductRelationUncheckedCreateWithoutProductInput> | ProductRelationCreateWithoutProductInput[] | ProductRelationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductRelationCreateOrConnectWithoutProductInput | ProductRelationCreateOrConnectWithoutProductInput[]
    createMany?: ProductRelationCreateManyProductInputEnvelope
    connect?: ProductRelationWhereUniqueInput | ProductRelationWhereUniqueInput[]
  }

  export type ProductRelationUncheckedCreateNestedManyWithoutRelatedProductInput = {
    create?: XOR<ProductRelationCreateWithoutRelatedProductInput, ProductRelationUncheckedCreateWithoutRelatedProductInput> | ProductRelationCreateWithoutRelatedProductInput[] | ProductRelationUncheckedCreateWithoutRelatedProductInput[]
    connectOrCreate?: ProductRelationCreateOrConnectWithoutRelatedProductInput | ProductRelationCreateOrConnectWithoutRelatedProductInput[]
    createMany?: ProductRelationCreateManyRelatedProductInputEnvelope
    connect?: ProductRelationWhereUniqueInput | ProductRelationWhereUniqueInput[]
  }

  export type ProductVariantUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
  }

  export type ProductUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InventorySyncLogUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventorySyncLogCreateWithoutProductInput, InventorySyncLogUncheckedCreateWithoutProductInput> | InventorySyncLogCreateWithoutProductInput[] | InventorySyncLogUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventorySyncLogCreateOrConnectWithoutProductInput | InventorySyncLogCreateOrConnectWithoutProductInput[]
    upsert?: InventorySyncLogUpsertWithWhereUniqueWithoutProductInput | InventorySyncLogUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventorySyncLogCreateManyProductInputEnvelope
    set?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
    disconnect?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
    delete?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
    connect?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
    update?: InventorySyncLogUpdateWithWhereUniqueWithoutProductInput | InventorySyncLogUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventorySyncLogUpdateManyWithWhereWithoutProductInput | InventorySyncLogUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventorySyncLogScalarWhereInput | InventorySyncLogScalarWhereInput[]
  }

  export type RentalPackageItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<RentalPackageItemCreateWithoutProductInput, RentalPackageItemUncheckedCreateWithoutProductInput> | RentalPackageItemCreateWithoutProductInput[] | RentalPackageItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RentalPackageItemCreateOrConnectWithoutProductInput | RentalPackageItemCreateOrConnectWithoutProductInput[]
    upsert?: RentalPackageItemUpsertWithWhereUniqueWithoutProductInput | RentalPackageItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: RentalPackageItemCreateManyProductInputEnvelope
    set?: RentalPackageItemWhereUniqueInput | RentalPackageItemWhereUniqueInput[]
    disconnect?: RentalPackageItemWhereUniqueInput | RentalPackageItemWhereUniqueInput[]
    delete?: RentalPackageItemWhereUniqueInput | RentalPackageItemWhereUniqueInput[]
    connect?: RentalPackageItemWhereUniqueInput | RentalPackageItemWhereUniqueInput[]
    update?: RentalPackageItemUpdateWithWhereUniqueWithoutProductInput | RentalPackageItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: RentalPackageItemUpdateManyWithWhereWithoutProductInput | RentalPackageItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: RentalPackageItemScalarWhereInput | RentalPackageItemScalarWhereInput[]
  }

  export type ProductRelationUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductRelationCreateWithoutProductInput, ProductRelationUncheckedCreateWithoutProductInput> | ProductRelationCreateWithoutProductInput[] | ProductRelationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductRelationCreateOrConnectWithoutProductInput | ProductRelationCreateOrConnectWithoutProductInput[]
    upsert?: ProductRelationUpsertWithWhereUniqueWithoutProductInput | ProductRelationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductRelationCreateManyProductInputEnvelope
    set?: ProductRelationWhereUniqueInput | ProductRelationWhereUniqueInput[]
    disconnect?: ProductRelationWhereUniqueInput | ProductRelationWhereUniqueInput[]
    delete?: ProductRelationWhereUniqueInput | ProductRelationWhereUniqueInput[]
    connect?: ProductRelationWhereUniqueInput | ProductRelationWhereUniqueInput[]
    update?: ProductRelationUpdateWithWhereUniqueWithoutProductInput | ProductRelationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductRelationUpdateManyWithWhereWithoutProductInput | ProductRelationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductRelationScalarWhereInput | ProductRelationScalarWhereInput[]
  }

  export type ProductRelationUpdateManyWithoutRelatedProductNestedInput = {
    create?: XOR<ProductRelationCreateWithoutRelatedProductInput, ProductRelationUncheckedCreateWithoutRelatedProductInput> | ProductRelationCreateWithoutRelatedProductInput[] | ProductRelationUncheckedCreateWithoutRelatedProductInput[]
    connectOrCreate?: ProductRelationCreateOrConnectWithoutRelatedProductInput | ProductRelationCreateOrConnectWithoutRelatedProductInput[]
    upsert?: ProductRelationUpsertWithWhereUniqueWithoutRelatedProductInput | ProductRelationUpsertWithWhereUniqueWithoutRelatedProductInput[]
    createMany?: ProductRelationCreateManyRelatedProductInputEnvelope
    set?: ProductRelationWhereUniqueInput | ProductRelationWhereUniqueInput[]
    disconnect?: ProductRelationWhereUniqueInput | ProductRelationWhereUniqueInput[]
    delete?: ProductRelationWhereUniqueInput | ProductRelationWhereUniqueInput[]
    connect?: ProductRelationWhereUniqueInput | ProductRelationWhereUniqueInput[]
    update?: ProductRelationUpdateWithWhereUniqueWithoutRelatedProductInput | ProductRelationUpdateWithWhereUniqueWithoutRelatedProductInput[]
    updateMany?: ProductRelationUpdateManyWithWhereWithoutRelatedProductInput | ProductRelationUpdateManyWithWhereWithoutRelatedProductInput[]
    deleteMany?: ProductRelationScalarWhereInput | ProductRelationScalarWhereInput[]
  }

  export type ProductVariantUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    upsert?: ProductVariantUpsertWithWhereUniqueWithoutProductInput | ProductVariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    set?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    disconnect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    delete?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    update?: ProductVariantUpdateWithWhereUniqueWithoutProductInput | ProductVariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductVariantUpdateManyWithWhereWithoutProductInput | ProductVariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
  }

  export type InventorySyncLogUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventorySyncLogCreateWithoutProductInput, InventorySyncLogUncheckedCreateWithoutProductInput> | InventorySyncLogCreateWithoutProductInput[] | InventorySyncLogUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventorySyncLogCreateOrConnectWithoutProductInput | InventorySyncLogCreateOrConnectWithoutProductInput[]
    upsert?: InventorySyncLogUpsertWithWhereUniqueWithoutProductInput | InventorySyncLogUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventorySyncLogCreateManyProductInputEnvelope
    set?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
    disconnect?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
    delete?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
    connect?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
    update?: InventorySyncLogUpdateWithWhereUniqueWithoutProductInput | InventorySyncLogUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventorySyncLogUpdateManyWithWhereWithoutProductInput | InventorySyncLogUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventorySyncLogScalarWhereInput | InventorySyncLogScalarWhereInput[]
  }

  export type RentalPackageItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<RentalPackageItemCreateWithoutProductInput, RentalPackageItemUncheckedCreateWithoutProductInput> | RentalPackageItemCreateWithoutProductInput[] | RentalPackageItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RentalPackageItemCreateOrConnectWithoutProductInput | RentalPackageItemCreateOrConnectWithoutProductInput[]
    upsert?: RentalPackageItemUpsertWithWhereUniqueWithoutProductInput | RentalPackageItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: RentalPackageItemCreateManyProductInputEnvelope
    set?: RentalPackageItemWhereUniqueInput | RentalPackageItemWhereUniqueInput[]
    disconnect?: RentalPackageItemWhereUniqueInput | RentalPackageItemWhereUniqueInput[]
    delete?: RentalPackageItemWhereUniqueInput | RentalPackageItemWhereUniqueInput[]
    connect?: RentalPackageItemWhereUniqueInput | RentalPackageItemWhereUniqueInput[]
    update?: RentalPackageItemUpdateWithWhereUniqueWithoutProductInput | RentalPackageItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: RentalPackageItemUpdateManyWithWhereWithoutProductInput | RentalPackageItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: RentalPackageItemScalarWhereInput | RentalPackageItemScalarWhereInput[]
  }

  export type ProductRelationUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductRelationCreateWithoutProductInput, ProductRelationUncheckedCreateWithoutProductInput> | ProductRelationCreateWithoutProductInput[] | ProductRelationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductRelationCreateOrConnectWithoutProductInput | ProductRelationCreateOrConnectWithoutProductInput[]
    upsert?: ProductRelationUpsertWithWhereUniqueWithoutProductInput | ProductRelationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductRelationCreateManyProductInputEnvelope
    set?: ProductRelationWhereUniqueInput | ProductRelationWhereUniqueInput[]
    disconnect?: ProductRelationWhereUniqueInput | ProductRelationWhereUniqueInput[]
    delete?: ProductRelationWhereUniqueInput | ProductRelationWhereUniqueInput[]
    connect?: ProductRelationWhereUniqueInput | ProductRelationWhereUniqueInput[]
    update?: ProductRelationUpdateWithWhereUniqueWithoutProductInput | ProductRelationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductRelationUpdateManyWithWhereWithoutProductInput | ProductRelationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductRelationScalarWhereInput | ProductRelationScalarWhereInput[]
  }

  export type ProductRelationUncheckedUpdateManyWithoutRelatedProductNestedInput = {
    create?: XOR<ProductRelationCreateWithoutRelatedProductInput, ProductRelationUncheckedCreateWithoutRelatedProductInput> | ProductRelationCreateWithoutRelatedProductInput[] | ProductRelationUncheckedCreateWithoutRelatedProductInput[]
    connectOrCreate?: ProductRelationCreateOrConnectWithoutRelatedProductInput | ProductRelationCreateOrConnectWithoutRelatedProductInput[]
    upsert?: ProductRelationUpsertWithWhereUniqueWithoutRelatedProductInput | ProductRelationUpsertWithWhereUniqueWithoutRelatedProductInput[]
    createMany?: ProductRelationCreateManyRelatedProductInputEnvelope
    set?: ProductRelationWhereUniqueInput | ProductRelationWhereUniqueInput[]
    disconnect?: ProductRelationWhereUniqueInput | ProductRelationWhereUniqueInput[]
    delete?: ProductRelationWhereUniqueInput | ProductRelationWhereUniqueInput[]
    connect?: ProductRelationWhereUniqueInput | ProductRelationWhereUniqueInput[]
    update?: ProductRelationUpdateWithWhereUniqueWithoutRelatedProductInput | ProductRelationUpdateWithWhereUniqueWithoutRelatedProductInput[]
    updateMany?: ProductRelationUpdateManyWithWhereWithoutRelatedProductInput | ProductRelationUpdateManyWithWhereWithoutRelatedProductInput[]
    deleteMany?: ProductRelationScalarWhereInput | ProductRelationScalarWhereInput[]
  }

  export type ProductVariantUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    upsert?: ProductVariantUpsertWithWhereUniqueWithoutProductInput | ProductVariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    set?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    disconnect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    delete?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    update?: ProductVariantUpdateWithWhereUniqueWithoutProductInput | ProductVariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductVariantUpdateManyWithWhereWithoutProductInput | ProductVariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutVariantsInput = {
    create?: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariantsInput
    connect?: ProductWhereUniqueInput
  }

  export type RentalItemCreateNestedManyWithoutVariantInput = {
    create?: XOR<RentalItemCreateWithoutVariantInput, RentalItemUncheckedCreateWithoutVariantInput> | RentalItemCreateWithoutVariantInput[] | RentalItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: RentalItemCreateOrConnectWithoutVariantInput | RentalItemCreateOrConnectWithoutVariantInput[]
    createMany?: RentalItemCreateManyVariantInputEnvelope
    connect?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
  }

  export type ProductUnitCreateNestedManyWithoutVariantInput = {
    create?: XOR<ProductUnitCreateWithoutVariantInput, ProductUnitUncheckedCreateWithoutVariantInput> | ProductUnitCreateWithoutVariantInput[] | ProductUnitUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: ProductUnitCreateOrConnectWithoutVariantInput | ProductUnitCreateOrConnectWithoutVariantInput[]
    createMany?: ProductUnitCreateManyVariantInputEnvelope
    connect?: ProductUnitWhereUniqueInput | ProductUnitWhereUniqueInput[]
  }

  export type RentalItemUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<RentalItemCreateWithoutVariantInput, RentalItemUncheckedCreateWithoutVariantInput> | RentalItemCreateWithoutVariantInput[] | RentalItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: RentalItemCreateOrConnectWithoutVariantInput | RentalItemCreateOrConnectWithoutVariantInput[]
    createMany?: RentalItemCreateManyVariantInputEnvelope
    connect?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
  }

  export type ProductUnitUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<ProductUnitCreateWithoutVariantInput, ProductUnitUncheckedCreateWithoutVariantInput> | ProductUnitCreateWithoutVariantInput[] | ProductUnitUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: ProductUnitCreateOrConnectWithoutVariantInput | ProductUnitCreateOrConnectWithoutVariantInput[]
    createMany?: ProductUnitCreateManyVariantInputEnvelope
    connect?: ProductUnitWhereUniqueInput | ProductUnitWhereUniqueInput[]
  }

  export type ProductUpdateOneRequiredWithoutVariantsNestedInput = {
    create?: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariantsInput
    upsert?: ProductUpsertWithoutVariantsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutVariantsInput, ProductUpdateWithoutVariantsInput>, ProductUncheckedUpdateWithoutVariantsInput>
  }

  export type RentalItemUpdateManyWithoutVariantNestedInput = {
    create?: XOR<RentalItemCreateWithoutVariantInput, RentalItemUncheckedCreateWithoutVariantInput> | RentalItemCreateWithoutVariantInput[] | RentalItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: RentalItemCreateOrConnectWithoutVariantInput | RentalItemCreateOrConnectWithoutVariantInput[]
    upsert?: RentalItemUpsertWithWhereUniqueWithoutVariantInput | RentalItemUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: RentalItemCreateManyVariantInputEnvelope
    set?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    disconnect?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    delete?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    connect?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    update?: RentalItemUpdateWithWhereUniqueWithoutVariantInput | RentalItemUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: RentalItemUpdateManyWithWhereWithoutVariantInput | RentalItemUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: RentalItemScalarWhereInput | RentalItemScalarWhereInput[]
  }

  export type ProductUnitUpdateManyWithoutVariantNestedInput = {
    create?: XOR<ProductUnitCreateWithoutVariantInput, ProductUnitUncheckedCreateWithoutVariantInput> | ProductUnitCreateWithoutVariantInput[] | ProductUnitUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: ProductUnitCreateOrConnectWithoutVariantInput | ProductUnitCreateOrConnectWithoutVariantInput[]
    upsert?: ProductUnitUpsertWithWhereUniqueWithoutVariantInput | ProductUnitUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: ProductUnitCreateManyVariantInputEnvelope
    set?: ProductUnitWhereUniqueInput | ProductUnitWhereUniqueInput[]
    disconnect?: ProductUnitWhereUniqueInput | ProductUnitWhereUniqueInput[]
    delete?: ProductUnitWhereUniqueInput | ProductUnitWhereUniqueInput[]
    connect?: ProductUnitWhereUniqueInput | ProductUnitWhereUniqueInput[]
    update?: ProductUnitUpdateWithWhereUniqueWithoutVariantInput | ProductUnitUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: ProductUnitUpdateManyWithWhereWithoutVariantInput | ProductUnitUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: ProductUnitScalarWhereInput | ProductUnitScalarWhereInput[]
  }

  export type RentalItemUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<RentalItemCreateWithoutVariantInput, RentalItemUncheckedCreateWithoutVariantInput> | RentalItemCreateWithoutVariantInput[] | RentalItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: RentalItemCreateOrConnectWithoutVariantInput | RentalItemCreateOrConnectWithoutVariantInput[]
    upsert?: RentalItemUpsertWithWhereUniqueWithoutVariantInput | RentalItemUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: RentalItemCreateManyVariantInputEnvelope
    set?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    disconnect?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    delete?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    connect?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    update?: RentalItemUpdateWithWhereUniqueWithoutVariantInput | RentalItemUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: RentalItemUpdateManyWithWhereWithoutVariantInput | RentalItemUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: RentalItemScalarWhereInput | RentalItemScalarWhereInput[]
  }

  export type ProductUnitUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<ProductUnitCreateWithoutVariantInput, ProductUnitUncheckedCreateWithoutVariantInput> | ProductUnitCreateWithoutVariantInput[] | ProductUnitUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: ProductUnitCreateOrConnectWithoutVariantInput | ProductUnitCreateOrConnectWithoutVariantInput[]
    upsert?: ProductUnitUpsertWithWhereUniqueWithoutVariantInput | ProductUnitUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: ProductUnitCreateManyVariantInputEnvelope
    set?: ProductUnitWhereUniqueInput | ProductUnitWhereUniqueInput[]
    disconnect?: ProductUnitWhereUniqueInput | ProductUnitWhereUniqueInput[]
    delete?: ProductUnitWhereUniqueInput | ProductUnitWhereUniqueInput[]
    connect?: ProductUnitWhereUniqueInput | ProductUnitWhereUniqueInput[]
    update?: ProductUnitUpdateWithWhereUniqueWithoutVariantInput | ProductUnitUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: ProductUnitUpdateManyWithWhereWithoutVariantInput | ProductUnitUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: ProductUnitScalarWhereInput | ProductUnitScalarWhereInput[]
  }

  export type ProductVariantCreateNestedOneWithoutUnitsInput = {
    create?: XOR<ProductVariantCreateWithoutUnitsInput, ProductVariantUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutUnitsInput
    connect?: ProductVariantWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutAssignedUnitsInput = {
    create?: XOR<OrderCreateWithoutAssignedUnitsInput, OrderUncheckedCreateWithoutAssignedUnitsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutAssignedUnitsInput
    connect?: OrderWhereUniqueInput
  }

  export type RentalItemCreateNestedManyWithoutUnitInput = {
    create?: XOR<RentalItemCreateWithoutUnitInput, RentalItemUncheckedCreateWithoutUnitInput> | RentalItemCreateWithoutUnitInput[] | RentalItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: RentalItemCreateOrConnectWithoutUnitInput | RentalItemCreateOrConnectWithoutUnitInput[]
    createMany?: RentalItemCreateManyUnitInputEnvelope
    connect?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
  }

  export type UnitHistoryCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitHistoryCreateWithoutUnitInput, UnitHistoryUncheckedCreateWithoutUnitInput> | UnitHistoryCreateWithoutUnitInput[] | UnitHistoryUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitHistoryCreateOrConnectWithoutUnitInput | UnitHistoryCreateOrConnectWithoutUnitInput[]
    createMany?: UnitHistoryCreateManyUnitInputEnvelope
    connect?: UnitHistoryWhereUniqueInput | UnitHistoryWhereUniqueInput[]
  }

  export type RentalItemUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<RentalItemCreateWithoutUnitInput, RentalItemUncheckedCreateWithoutUnitInput> | RentalItemCreateWithoutUnitInput[] | RentalItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: RentalItemCreateOrConnectWithoutUnitInput | RentalItemCreateOrConnectWithoutUnitInput[]
    createMany?: RentalItemCreateManyUnitInputEnvelope
    connect?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
  }

  export type UnitHistoryUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitHistoryCreateWithoutUnitInput, UnitHistoryUncheckedCreateWithoutUnitInput> | UnitHistoryCreateWithoutUnitInput[] | UnitHistoryUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitHistoryCreateOrConnectWithoutUnitInput | UnitHistoryCreateOrConnectWithoutUnitInput[]
    createMany?: UnitHistoryCreateManyUnitInputEnvelope
    connect?: UnitHistoryWhereUniqueInput | UnitHistoryWhereUniqueInput[]
  }

  export type EnumUnitStatusFieldUpdateOperationsInput = {
    set?: $Enums.UnitStatus
  }

  export type EnumUnitConditionFieldUpdateOperationsInput = {
    set?: $Enums.UnitCondition
  }

  export type ProductVariantUpdateOneRequiredWithoutUnitsNestedInput = {
    create?: XOR<ProductVariantCreateWithoutUnitsInput, ProductVariantUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutUnitsInput
    upsert?: ProductVariantUpsertWithoutUnitsInput
    connect?: ProductVariantWhereUniqueInput
    update?: XOR<XOR<ProductVariantUpdateToOneWithWhereWithoutUnitsInput, ProductVariantUpdateWithoutUnitsInput>, ProductVariantUncheckedUpdateWithoutUnitsInput>
  }

  export type OrderUpdateOneWithoutAssignedUnitsNestedInput = {
    create?: XOR<OrderCreateWithoutAssignedUnitsInput, OrderUncheckedCreateWithoutAssignedUnitsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutAssignedUnitsInput
    upsert?: OrderUpsertWithoutAssignedUnitsInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutAssignedUnitsInput, OrderUpdateWithoutAssignedUnitsInput>, OrderUncheckedUpdateWithoutAssignedUnitsInput>
  }

  export type RentalItemUpdateManyWithoutUnitNestedInput = {
    create?: XOR<RentalItemCreateWithoutUnitInput, RentalItemUncheckedCreateWithoutUnitInput> | RentalItemCreateWithoutUnitInput[] | RentalItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: RentalItemCreateOrConnectWithoutUnitInput | RentalItemCreateOrConnectWithoutUnitInput[]
    upsert?: RentalItemUpsertWithWhereUniqueWithoutUnitInput | RentalItemUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: RentalItemCreateManyUnitInputEnvelope
    set?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    disconnect?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    delete?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    connect?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    update?: RentalItemUpdateWithWhereUniqueWithoutUnitInput | RentalItemUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: RentalItemUpdateManyWithWhereWithoutUnitInput | RentalItemUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: RentalItemScalarWhereInput | RentalItemScalarWhereInput[]
  }

  export type UnitHistoryUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitHistoryCreateWithoutUnitInput, UnitHistoryUncheckedCreateWithoutUnitInput> | UnitHistoryCreateWithoutUnitInput[] | UnitHistoryUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitHistoryCreateOrConnectWithoutUnitInput | UnitHistoryCreateOrConnectWithoutUnitInput[]
    upsert?: UnitHistoryUpsertWithWhereUniqueWithoutUnitInput | UnitHistoryUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitHistoryCreateManyUnitInputEnvelope
    set?: UnitHistoryWhereUniqueInput | UnitHistoryWhereUniqueInput[]
    disconnect?: UnitHistoryWhereUniqueInput | UnitHistoryWhereUniqueInput[]
    delete?: UnitHistoryWhereUniqueInput | UnitHistoryWhereUniqueInput[]
    connect?: UnitHistoryWhereUniqueInput | UnitHistoryWhereUniqueInput[]
    update?: UnitHistoryUpdateWithWhereUniqueWithoutUnitInput | UnitHistoryUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitHistoryUpdateManyWithWhereWithoutUnitInput | UnitHistoryUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitHistoryScalarWhereInput | UnitHistoryScalarWhereInput[]
  }

  export type RentalItemUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<RentalItemCreateWithoutUnitInput, RentalItemUncheckedCreateWithoutUnitInput> | RentalItemCreateWithoutUnitInput[] | RentalItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: RentalItemCreateOrConnectWithoutUnitInput | RentalItemCreateOrConnectWithoutUnitInput[]
    upsert?: RentalItemUpsertWithWhereUniqueWithoutUnitInput | RentalItemUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: RentalItemCreateManyUnitInputEnvelope
    set?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    disconnect?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    delete?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    connect?: RentalItemWhereUniqueInput | RentalItemWhereUniqueInput[]
    update?: RentalItemUpdateWithWhereUniqueWithoutUnitInput | RentalItemUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: RentalItemUpdateManyWithWhereWithoutUnitInput | RentalItemUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: RentalItemScalarWhereInput | RentalItemScalarWhereInput[]
  }

  export type UnitHistoryUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitHistoryCreateWithoutUnitInput, UnitHistoryUncheckedCreateWithoutUnitInput> | UnitHistoryCreateWithoutUnitInput[] | UnitHistoryUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitHistoryCreateOrConnectWithoutUnitInput | UnitHistoryCreateOrConnectWithoutUnitInput[]
    upsert?: UnitHistoryUpsertWithWhereUniqueWithoutUnitInput | UnitHistoryUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitHistoryCreateManyUnitInputEnvelope
    set?: UnitHistoryWhereUniqueInput | UnitHistoryWhereUniqueInput[]
    disconnect?: UnitHistoryWhereUniqueInput | UnitHistoryWhereUniqueInput[]
    delete?: UnitHistoryWhereUniqueInput | UnitHistoryWhereUniqueInput[]
    connect?: UnitHistoryWhereUniqueInput | UnitHistoryWhereUniqueInput[]
    update?: UnitHistoryUpdateWithWhereUniqueWithoutUnitInput | UnitHistoryUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitHistoryUpdateManyWithWhereWithoutUnitInput | UnitHistoryUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitHistoryScalarWhereInput | UnitHistoryScalarWhereInput[]
  }

  export type ProductUnitCreateNestedOneWithoutHistoryInput = {
    create?: XOR<ProductUnitCreateWithoutHistoryInput, ProductUnitUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: ProductUnitCreateOrConnectWithoutHistoryInput
    connect?: ProductUnitWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUnitActionsInput = {
    create?: XOR<UserCreateWithoutUnitActionsInput, UserUncheckedCreateWithoutUnitActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUnitActionsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductUnitUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<ProductUnitCreateWithoutHistoryInput, ProductUnitUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: ProductUnitCreateOrConnectWithoutHistoryInput
    upsert?: ProductUnitUpsertWithoutHistoryInput
    connect?: ProductUnitWhereUniqueInput
    update?: XOR<XOR<ProductUnitUpdateToOneWithWhereWithoutHistoryInput, ProductUnitUpdateWithoutHistoryInput>, ProductUnitUncheckedUpdateWithoutHistoryInput>
  }

  export type UserUpdateOneWithoutUnitActionsNestedInput = {
    create?: XOR<UserCreateWithoutUnitActionsInput, UserUncheckedCreateWithoutUnitActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUnitActionsInput
    upsert?: UserUpsertWithoutUnitActionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUnitActionsInput, UserUpdateWithoutUnitActionsInput>, UserUncheckedUpdateWithoutUnitActionsInput>
  }

  export type UserCreateNestedOneWithoutSystemNotificationsInput = {
    create?: XOR<UserCreateWithoutSystemNotificationsInput, UserUncheckedCreateWithoutSystemNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSystemNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneWithoutSystemNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutSystemNotificationsInput, UserUncheckedCreateWithoutSystemNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSystemNotificationsInput
    upsert?: UserUpsertWithoutSystemNotificationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSystemNotificationsInput, UserUpdateWithoutSystemNotificationsInput>, UserUncheckedUpdateWithoutSystemNotificationsInput>
  }

  export type OrderCreateNestedOneWithoutRentalItemsInput = {
    create?: XOR<OrderCreateWithoutRentalItemsInput, OrderUncheckedCreateWithoutRentalItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutRentalItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type RentalPackageCreateNestedOneWithoutRentalItemsInput = {
    create?: XOR<RentalPackageCreateWithoutRentalItemsInput, RentalPackageUncheckedCreateWithoutRentalItemsInput>
    connectOrCreate?: RentalPackageCreateOrConnectWithoutRentalItemsInput
    connect?: RentalPackageWhereUniqueInput
  }

  export type ProductVariantCreateNestedOneWithoutRentalItemsInput = {
    create?: XOR<ProductVariantCreateWithoutRentalItemsInput, ProductVariantUncheckedCreateWithoutRentalItemsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutRentalItemsInput
    connect?: ProductVariantWhereUniqueInput
  }

  export type ProductUnitCreateNestedOneWithoutRentalItemsInput = {
    create?: XOR<ProductUnitCreateWithoutRentalItemsInput, ProductUnitUncheckedCreateWithoutRentalItemsInput>
    connectOrCreate?: ProductUnitCreateOrConnectWithoutRentalItemsInput
    connect?: ProductUnitWhereUniqueInput
  }

  export type DeliveryItemCreateNestedManyWithoutRentalItemInput = {
    create?: XOR<DeliveryItemCreateWithoutRentalItemInput, DeliveryItemUncheckedCreateWithoutRentalItemInput> | DeliveryItemCreateWithoutRentalItemInput[] | DeliveryItemUncheckedCreateWithoutRentalItemInput[]
    connectOrCreate?: DeliveryItemCreateOrConnectWithoutRentalItemInput | DeliveryItemCreateOrConnectWithoutRentalItemInput[]
    createMany?: DeliveryItemCreateManyRentalItemInputEnvelope
    connect?: DeliveryItemWhereUniqueInput | DeliveryItemWhereUniqueInput[]
  }

  export type DeliveryItemUncheckedCreateNestedManyWithoutRentalItemInput = {
    create?: XOR<DeliveryItemCreateWithoutRentalItemInput, DeliveryItemUncheckedCreateWithoutRentalItemInput> | DeliveryItemCreateWithoutRentalItemInput[] | DeliveryItemUncheckedCreateWithoutRentalItemInput[]
    connectOrCreate?: DeliveryItemCreateOrConnectWithoutRentalItemInput | DeliveryItemCreateOrConnectWithoutRentalItemInput[]
    createMany?: DeliveryItemCreateManyRentalItemInputEnvelope
    connect?: DeliveryItemWhereUniqueInput | DeliveryItemWhereUniqueInput[]
  }

  export type OrderUpdateOneRequiredWithoutRentalItemsNestedInput = {
    create?: XOR<OrderCreateWithoutRentalItemsInput, OrderUncheckedCreateWithoutRentalItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutRentalItemsInput
    upsert?: OrderUpsertWithoutRentalItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutRentalItemsInput, OrderUpdateWithoutRentalItemsInput>, OrderUncheckedUpdateWithoutRentalItemsInput>
  }

  export type RentalPackageUpdateOneWithoutRentalItemsNestedInput = {
    create?: XOR<RentalPackageCreateWithoutRentalItemsInput, RentalPackageUncheckedCreateWithoutRentalItemsInput>
    connectOrCreate?: RentalPackageCreateOrConnectWithoutRentalItemsInput
    upsert?: RentalPackageUpsertWithoutRentalItemsInput
    disconnect?: RentalPackageWhereInput | boolean
    delete?: RentalPackageWhereInput | boolean
    connect?: RentalPackageWhereUniqueInput
    update?: XOR<XOR<RentalPackageUpdateToOneWithWhereWithoutRentalItemsInput, RentalPackageUpdateWithoutRentalItemsInput>, RentalPackageUncheckedUpdateWithoutRentalItemsInput>
  }

  export type ProductVariantUpdateOneWithoutRentalItemsNestedInput = {
    create?: XOR<ProductVariantCreateWithoutRentalItemsInput, ProductVariantUncheckedCreateWithoutRentalItemsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutRentalItemsInput
    upsert?: ProductVariantUpsertWithoutRentalItemsInput
    disconnect?: ProductVariantWhereInput | boolean
    delete?: ProductVariantWhereInput | boolean
    connect?: ProductVariantWhereUniqueInput
    update?: XOR<XOR<ProductVariantUpdateToOneWithWhereWithoutRentalItemsInput, ProductVariantUpdateWithoutRentalItemsInput>, ProductVariantUncheckedUpdateWithoutRentalItemsInput>
  }

  export type ProductUnitUpdateOneWithoutRentalItemsNestedInput = {
    create?: XOR<ProductUnitCreateWithoutRentalItemsInput, ProductUnitUncheckedCreateWithoutRentalItemsInput>
    connectOrCreate?: ProductUnitCreateOrConnectWithoutRentalItemsInput
    upsert?: ProductUnitUpsertWithoutRentalItemsInput
    disconnect?: ProductUnitWhereInput | boolean
    delete?: ProductUnitWhereInput | boolean
    connect?: ProductUnitWhereUniqueInput
    update?: XOR<XOR<ProductUnitUpdateToOneWithWhereWithoutRentalItemsInput, ProductUnitUpdateWithoutRentalItemsInput>, ProductUnitUncheckedUpdateWithoutRentalItemsInput>
  }

  export type DeliveryItemUpdateManyWithoutRentalItemNestedInput = {
    create?: XOR<DeliveryItemCreateWithoutRentalItemInput, DeliveryItemUncheckedCreateWithoutRentalItemInput> | DeliveryItemCreateWithoutRentalItemInput[] | DeliveryItemUncheckedCreateWithoutRentalItemInput[]
    connectOrCreate?: DeliveryItemCreateOrConnectWithoutRentalItemInput | DeliveryItemCreateOrConnectWithoutRentalItemInput[]
    upsert?: DeliveryItemUpsertWithWhereUniqueWithoutRentalItemInput | DeliveryItemUpsertWithWhereUniqueWithoutRentalItemInput[]
    createMany?: DeliveryItemCreateManyRentalItemInputEnvelope
    set?: DeliveryItemWhereUniqueInput | DeliveryItemWhereUniqueInput[]
    disconnect?: DeliveryItemWhereUniqueInput | DeliveryItemWhereUniqueInput[]
    delete?: DeliveryItemWhereUniqueInput | DeliveryItemWhereUniqueInput[]
    connect?: DeliveryItemWhereUniqueInput | DeliveryItemWhereUniqueInput[]
    update?: DeliveryItemUpdateWithWhereUniqueWithoutRentalItemInput | DeliveryItemUpdateWithWhereUniqueWithoutRentalItemInput[]
    updateMany?: DeliveryItemUpdateManyWithWhereWithoutRentalItemInput | DeliveryItemUpdateManyWithWhereWithoutRentalItemInput[]
    deleteMany?: DeliveryItemScalarWhereInput | DeliveryItemScalarWhereInput[]
  }

  export type DeliveryItemUncheckedUpdateManyWithoutRentalItemNestedInput = {
    create?: XOR<DeliveryItemCreateWithoutRentalItemInput, DeliveryItemUncheckedCreateWithoutRentalItemInput> | DeliveryItemCreateWithoutRentalItemInput[] | DeliveryItemUncheckedCreateWithoutRentalItemInput[]
    connectOrCreate?: DeliveryItemCreateOrConnectWithoutRentalItemInput | DeliveryItemCreateOrConnectWithoutRentalItemInput[]
    upsert?: DeliveryItemUpsertWithWhereUniqueWithoutRentalItemInput | DeliveryItemUpsertWithWhereUniqueWithoutRentalItemInput[]
    createMany?: DeliveryItemCreateManyRentalItemInputEnvelope
    set?: DeliveryItemWhereUniqueInput | DeliveryItemWhereUniqueInput[]
    disconnect?: DeliveryItemWhereUniqueInput | DeliveryItemWhereUniqueInput[]
    delete?: DeliveryItemWhereUniqueInput | DeliveryItemWhereUniqueInput[]
    connect?: DeliveryItemWhereUniqueInput | DeliveryItemWhereUniqueInput[]
    update?: DeliveryItemUpdateWithWhereUniqueWithoutRentalItemInput | DeliveryItemUpdateWithWhereUniqueWithoutRentalItemInput[]
    updateMany?: DeliveryItemUpdateManyWithWhereWithoutRentalItemInput | DeliveryItemUpdateManyWithWhereWithoutRentalItemInput[]
    deleteMany?: DeliveryItemScalarWhereInput | DeliveryItemScalarWhereInput[]
  }

  export type ActivityLogCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type InventorySyncLogCreateNestedManyWithoutResolvedByUserInput = {
    create?: XOR<InventorySyncLogCreateWithoutResolvedByUserInput, InventorySyncLogUncheckedCreateWithoutResolvedByUserInput> | InventorySyncLogCreateWithoutResolvedByUserInput[] | InventorySyncLogUncheckedCreateWithoutResolvedByUserInput[]
    connectOrCreate?: InventorySyncLogCreateOrConnectWithoutResolvedByUserInput | InventorySyncLogCreateOrConnectWithoutResolvedByUserInput[]
    createMany?: InventorySyncLogCreateManyResolvedByUserInputEnvelope
    connect?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
  }

  export type InventorySyncLogCreateNestedManyWithoutUpdatedByUserInput = {
    create?: XOR<InventorySyncLogCreateWithoutUpdatedByUserInput, InventorySyncLogUncheckedCreateWithoutUpdatedByUserInput> | InventorySyncLogCreateWithoutUpdatedByUserInput[] | InventorySyncLogUncheckedCreateWithoutUpdatedByUserInput[]
    connectOrCreate?: InventorySyncLogCreateOrConnectWithoutUpdatedByUserInput | InventorySyncLogCreateOrConnectWithoutUpdatedByUserInput[]
    createMany?: InventorySyncLogCreateManyUpdatedByUserInputEnvelope
    connect?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutUserInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput = {
    create?: XOR<OrderCreateWithoutUsers_orders_payment_confirmed_byTousersInput, OrderUncheckedCreateWithoutUsers_orders_payment_confirmed_byTousersInput> | OrderCreateWithoutUsers_orders_payment_confirmed_byTousersInput[] | OrderUncheckedCreateWithoutUsers_orders_payment_confirmed_byTousersInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUsers_orders_payment_confirmed_byTousersInput | OrderCreateOrConnectWithoutUsers_orders_payment_confirmed_byTousersInput[]
    createMany?: OrderCreateManyUsers_orders_payment_confirmed_byTousersInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type WorkerAttendanceCreateNestedManyWithoutWorkerInput = {
    create?: XOR<WorkerAttendanceCreateWithoutWorkerInput, WorkerAttendanceUncheckedCreateWithoutWorkerInput> | WorkerAttendanceCreateWithoutWorkerInput[] | WorkerAttendanceUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: WorkerAttendanceCreateOrConnectWithoutWorkerInput | WorkerAttendanceCreateOrConnectWithoutWorkerInput[]
    createMany?: WorkerAttendanceCreateManyWorkerInputEnvelope
    connect?: WorkerAttendanceWhereUniqueInput | WorkerAttendanceWhereUniqueInput[]
  }

  export type DeliveryCreateNestedManyWithoutClaimedByWorkerInput = {
    create?: XOR<DeliveryCreateWithoutClaimedByWorkerInput, DeliveryUncheckedCreateWithoutClaimedByWorkerInput> | DeliveryCreateWithoutClaimedByWorkerInput[] | DeliveryUncheckedCreateWithoutClaimedByWorkerInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutClaimedByWorkerInput | DeliveryCreateOrConnectWithoutClaimedByWorkerInput[]
    createMany?: DeliveryCreateManyClaimedByWorkerInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type DeliveryLogCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<DeliveryLogCreateWithoutCreatedByUserInput, DeliveryLogUncheckedCreateWithoutCreatedByUserInput> | DeliveryLogCreateWithoutCreatedByUserInput[] | DeliveryLogUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: DeliveryLogCreateOrConnectWithoutCreatedByUserInput | DeliveryLogCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: DeliveryLogCreateManyCreatedByUserInputEnvelope
    connect?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
  }

  export type DeliveryEditLogCreateNestedManyWithoutEditedByUserInput = {
    create?: XOR<DeliveryEditLogCreateWithoutEditedByUserInput, DeliveryEditLogUncheckedCreateWithoutEditedByUserInput> | DeliveryEditLogCreateWithoutEditedByUserInput[] | DeliveryEditLogUncheckedCreateWithoutEditedByUserInput[]
    connectOrCreate?: DeliveryEditLogCreateOrConnectWithoutEditedByUserInput | DeliveryEditLogCreateOrConnectWithoutEditedByUserInput[]
    createMany?: DeliveryEditLogCreateManyEditedByUserInputEnvelope
    connect?: DeliveryEditLogWhereUniqueInput | DeliveryEditLogWhereUniqueInput[]
  }

  export type WorkerNotificationCreateNestedManyWithoutFromAdminInput = {
    create?: XOR<WorkerNotificationCreateWithoutFromAdminInput, WorkerNotificationUncheckedCreateWithoutFromAdminInput> | WorkerNotificationCreateWithoutFromAdminInput[] | WorkerNotificationUncheckedCreateWithoutFromAdminInput[]
    connectOrCreate?: WorkerNotificationCreateOrConnectWithoutFromAdminInput | WorkerNotificationCreateOrConnectWithoutFromAdminInput[]
    createMany?: WorkerNotificationCreateManyFromAdminInputEnvelope
    connect?: WorkerNotificationWhereUniqueInput | WorkerNotificationWhereUniqueInput[]
  }

  export type WorkerNotificationCreateNestedManyWithoutWorkerInput = {
    create?: XOR<WorkerNotificationCreateWithoutWorkerInput, WorkerNotificationUncheckedCreateWithoutWorkerInput> | WorkerNotificationCreateWithoutWorkerInput[] | WorkerNotificationUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: WorkerNotificationCreateOrConnectWithoutWorkerInput | WorkerNotificationCreateOrConnectWithoutWorkerInput[]
    createMany?: WorkerNotificationCreateManyWorkerInputEnvelope
    connect?: WorkerNotificationWhereUniqueInput | WorkerNotificationWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ChatGroupMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatGroupMemberCreateWithoutUserInput, ChatGroupMemberUncheckedCreateWithoutUserInput> | ChatGroupMemberCreateWithoutUserInput[] | ChatGroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatGroupMemberCreateOrConnectWithoutUserInput | ChatGroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: ChatGroupMemberCreateManyUserInputEnvelope
    connect?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
  }

  export type GroupMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<GroupMessageCreateWithoutSenderInput, GroupMessageUncheckedCreateWithoutSenderInput> | GroupMessageCreateWithoutSenderInput[] | GroupMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: GroupMessageCreateOrConnectWithoutSenderInput | GroupMessageCreateOrConnectWithoutSenderInput[]
    createMany?: GroupMessageCreateManySenderInputEnvelope
    connect?: GroupMessageWhereUniqueInput | GroupMessageWhereUniqueInput[]
  }

  export type NotificationDismissalCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationDismissalCreateWithoutUserInput, NotificationDismissalUncheckedCreateWithoutUserInput> | NotificationDismissalCreateWithoutUserInput[] | NotificationDismissalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationDismissalCreateOrConnectWithoutUserInput | NotificationDismissalCreateOrConnectWithoutUserInput[]
    createMany?: NotificationDismissalCreateManyUserInputEnvelope
    connect?: NotificationDismissalWhereUniqueInput | NotificationDismissalWhereUniqueInput[]
  }

  export type SystemNotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<SystemNotificationCreateWithoutUserInput, SystemNotificationUncheckedCreateWithoutUserInput> | SystemNotificationCreateWithoutUserInput[] | SystemNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemNotificationCreateOrConnectWithoutUserInput | SystemNotificationCreateOrConnectWithoutUserInput[]
    createMany?: SystemNotificationCreateManyUserInputEnvelope
    connect?: SystemNotificationWhereUniqueInput | SystemNotificationWhereUniqueInput[]
  }

  export type PaymentTransactionCreateNestedManyWithoutVerifiedByInput = {
    create?: XOR<PaymentTransactionCreateWithoutVerifiedByInput, PaymentTransactionUncheckedCreateWithoutVerifiedByInput> | PaymentTransactionCreateWithoutVerifiedByInput[] | PaymentTransactionUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutVerifiedByInput | PaymentTransactionCreateOrConnectWithoutVerifiedByInput[]
    createMany?: PaymentTransactionCreateManyVerifiedByInputEnvelope
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
  }

  export type UnitHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<UnitHistoryCreateWithoutUserInput, UnitHistoryUncheckedCreateWithoutUserInput> | UnitHistoryCreateWithoutUserInput[] | UnitHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UnitHistoryCreateOrConnectWithoutUserInput | UnitHistoryCreateOrConnectWithoutUserInput[]
    createMany?: UnitHistoryCreateManyUserInputEnvelope
    connect?: UnitHistoryWhereUniqueInput | UnitHistoryWhereUniqueInput[]
  }

  export type AiActionCreateNestedManyWithoutApproverInput = {
    create?: XOR<AiActionCreateWithoutApproverInput, AiActionUncheckedCreateWithoutApproverInput> | AiActionCreateWithoutApproverInput[] | AiActionUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: AiActionCreateOrConnectWithoutApproverInput | AiActionCreateOrConnectWithoutApproverInput[]
    createMany?: AiActionCreateManyApproverInputEnvelope
    connect?: AiActionWhereUniqueInput | AiActionWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type InventorySyncLogUncheckedCreateNestedManyWithoutResolvedByUserInput = {
    create?: XOR<InventorySyncLogCreateWithoutResolvedByUserInput, InventorySyncLogUncheckedCreateWithoutResolvedByUserInput> | InventorySyncLogCreateWithoutResolvedByUserInput[] | InventorySyncLogUncheckedCreateWithoutResolvedByUserInput[]
    connectOrCreate?: InventorySyncLogCreateOrConnectWithoutResolvedByUserInput | InventorySyncLogCreateOrConnectWithoutResolvedByUserInput[]
    createMany?: InventorySyncLogCreateManyResolvedByUserInputEnvelope
    connect?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
  }

  export type InventorySyncLogUncheckedCreateNestedManyWithoutUpdatedByUserInput = {
    create?: XOR<InventorySyncLogCreateWithoutUpdatedByUserInput, InventorySyncLogUncheckedCreateWithoutUpdatedByUserInput> | InventorySyncLogCreateWithoutUpdatedByUserInput[] | InventorySyncLogUncheckedCreateWithoutUpdatedByUserInput[]
    connectOrCreate?: InventorySyncLogCreateOrConnectWithoutUpdatedByUserInput | InventorySyncLogCreateOrConnectWithoutUpdatedByUserInput[]
    createMany?: InventorySyncLogCreateManyUpdatedByUserInputEnvelope
    connect?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput = {
    create?: XOR<OrderCreateWithoutUsers_orders_payment_confirmed_byTousersInput, OrderUncheckedCreateWithoutUsers_orders_payment_confirmed_byTousersInput> | OrderCreateWithoutUsers_orders_payment_confirmed_byTousersInput[] | OrderUncheckedCreateWithoutUsers_orders_payment_confirmed_byTousersInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUsers_orders_payment_confirmed_byTousersInput | OrderCreateOrConnectWithoutUsers_orders_payment_confirmed_byTousersInput[]
    createMany?: OrderCreateManyUsers_orders_payment_confirmed_byTousersInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type WorkerAttendanceUncheckedCreateNestedManyWithoutWorkerInput = {
    create?: XOR<WorkerAttendanceCreateWithoutWorkerInput, WorkerAttendanceUncheckedCreateWithoutWorkerInput> | WorkerAttendanceCreateWithoutWorkerInput[] | WorkerAttendanceUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: WorkerAttendanceCreateOrConnectWithoutWorkerInput | WorkerAttendanceCreateOrConnectWithoutWorkerInput[]
    createMany?: WorkerAttendanceCreateManyWorkerInputEnvelope
    connect?: WorkerAttendanceWhereUniqueInput | WorkerAttendanceWhereUniqueInput[]
  }

  export type DeliveryUncheckedCreateNestedManyWithoutClaimedByWorkerInput = {
    create?: XOR<DeliveryCreateWithoutClaimedByWorkerInput, DeliveryUncheckedCreateWithoutClaimedByWorkerInput> | DeliveryCreateWithoutClaimedByWorkerInput[] | DeliveryUncheckedCreateWithoutClaimedByWorkerInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutClaimedByWorkerInput | DeliveryCreateOrConnectWithoutClaimedByWorkerInput[]
    createMany?: DeliveryCreateManyClaimedByWorkerInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type DeliveryLogUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<DeliveryLogCreateWithoutCreatedByUserInput, DeliveryLogUncheckedCreateWithoutCreatedByUserInput> | DeliveryLogCreateWithoutCreatedByUserInput[] | DeliveryLogUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: DeliveryLogCreateOrConnectWithoutCreatedByUserInput | DeliveryLogCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: DeliveryLogCreateManyCreatedByUserInputEnvelope
    connect?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
  }

  export type DeliveryEditLogUncheckedCreateNestedManyWithoutEditedByUserInput = {
    create?: XOR<DeliveryEditLogCreateWithoutEditedByUserInput, DeliveryEditLogUncheckedCreateWithoutEditedByUserInput> | DeliveryEditLogCreateWithoutEditedByUserInput[] | DeliveryEditLogUncheckedCreateWithoutEditedByUserInput[]
    connectOrCreate?: DeliveryEditLogCreateOrConnectWithoutEditedByUserInput | DeliveryEditLogCreateOrConnectWithoutEditedByUserInput[]
    createMany?: DeliveryEditLogCreateManyEditedByUserInputEnvelope
    connect?: DeliveryEditLogWhereUniqueInput | DeliveryEditLogWhereUniqueInput[]
  }

  export type WorkerNotificationUncheckedCreateNestedManyWithoutFromAdminInput = {
    create?: XOR<WorkerNotificationCreateWithoutFromAdminInput, WorkerNotificationUncheckedCreateWithoutFromAdminInput> | WorkerNotificationCreateWithoutFromAdminInput[] | WorkerNotificationUncheckedCreateWithoutFromAdminInput[]
    connectOrCreate?: WorkerNotificationCreateOrConnectWithoutFromAdminInput | WorkerNotificationCreateOrConnectWithoutFromAdminInput[]
    createMany?: WorkerNotificationCreateManyFromAdminInputEnvelope
    connect?: WorkerNotificationWhereUniqueInput | WorkerNotificationWhereUniqueInput[]
  }

  export type WorkerNotificationUncheckedCreateNestedManyWithoutWorkerInput = {
    create?: XOR<WorkerNotificationCreateWithoutWorkerInput, WorkerNotificationUncheckedCreateWithoutWorkerInput> | WorkerNotificationCreateWithoutWorkerInput[] | WorkerNotificationUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: WorkerNotificationCreateOrConnectWithoutWorkerInput | WorkerNotificationCreateOrConnectWithoutWorkerInput[]
    createMany?: WorkerNotificationCreateManyWorkerInputEnvelope
    connect?: WorkerNotificationWhereUniqueInput | WorkerNotificationWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatGroupMemberCreateWithoutUserInput, ChatGroupMemberUncheckedCreateWithoutUserInput> | ChatGroupMemberCreateWithoutUserInput[] | ChatGroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatGroupMemberCreateOrConnectWithoutUserInput | ChatGroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: ChatGroupMemberCreateManyUserInputEnvelope
    connect?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
  }

  export type GroupMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<GroupMessageCreateWithoutSenderInput, GroupMessageUncheckedCreateWithoutSenderInput> | GroupMessageCreateWithoutSenderInput[] | GroupMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: GroupMessageCreateOrConnectWithoutSenderInput | GroupMessageCreateOrConnectWithoutSenderInput[]
    createMany?: GroupMessageCreateManySenderInputEnvelope
    connect?: GroupMessageWhereUniqueInput | GroupMessageWhereUniqueInput[]
  }

  export type NotificationDismissalUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationDismissalCreateWithoutUserInput, NotificationDismissalUncheckedCreateWithoutUserInput> | NotificationDismissalCreateWithoutUserInput[] | NotificationDismissalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationDismissalCreateOrConnectWithoutUserInput | NotificationDismissalCreateOrConnectWithoutUserInput[]
    createMany?: NotificationDismissalCreateManyUserInputEnvelope
    connect?: NotificationDismissalWhereUniqueInput | NotificationDismissalWhereUniqueInput[]
  }

  export type SystemNotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SystemNotificationCreateWithoutUserInput, SystemNotificationUncheckedCreateWithoutUserInput> | SystemNotificationCreateWithoutUserInput[] | SystemNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemNotificationCreateOrConnectWithoutUserInput | SystemNotificationCreateOrConnectWithoutUserInput[]
    createMany?: SystemNotificationCreateManyUserInputEnvelope
    connect?: SystemNotificationWhereUniqueInput | SystemNotificationWhereUniqueInput[]
  }

  export type PaymentTransactionUncheckedCreateNestedManyWithoutVerifiedByInput = {
    create?: XOR<PaymentTransactionCreateWithoutVerifiedByInput, PaymentTransactionUncheckedCreateWithoutVerifiedByInput> | PaymentTransactionCreateWithoutVerifiedByInput[] | PaymentTransactionUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutVerifiedByInput | PaymentTransactionCreateOrConnectWithoutVerifiedByInput[]
    createMany?: PaymentTransactionCreateManyVerifiedByInputEnvelope
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
  }

  export type UnitHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UnitHistoryCreateWithoutUserInput, UnitHistoryUncheckedCreateWithoutUserInput> | UnitHistoryCreateWithoutUserInput[] | UnitHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UnitHistoryCreateOrConnectWithoutUserInput | UnitHistoryCreateOrConnectWithoutUserInput[]
    createMany?: UnitHistoryCreateManyUserInputEnvelope
    connect?: UnitHistoryWhereUniqueInput | UnitHistoryWhereUniqueInput[]
  }

  export type AiActionUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<AiActionCreateWithoutApproverInput, AiActionUncheckedCreateWithoutApproverInput> | AiActionCreateWithoutApproverInput[] | AiActionUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: AiActionCreateOrConnectWithoutApproverInput | AiActionCreateOrConnectWithoutApproverInput[]
    createMany?: AiActionCreateManyApproverInputEnvelope
    connect?: AiActionWhereUniqueInput | AiActionWhereUniqueInput[]
  }

  export type ActivityLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type InventorySyncLogUpdateManyWithoutResolvedByUserNestedInput = {
    create?: XOR<InventorySyncLogCreateWithoutResolvedByUserInput, InventorySyncLogUncheckedCreateWithoutResolvedByUserInput> | InventorySyncLogCreateWithoutResolvedByUserInput[] | InventorySyncLogUncheckedCreateWithoutResolvedByUserInput[]
    connectOrCreate?: InventorySyncLogCreateOrConnectWithoutResolvedByUserInput | InventorySyncLogCreateOrConnectWithoutResolvedByUserInput[]
    upsert?: InventorySyncLogUpsertWithWhereUniqueWithoutResolvedByUserInput | InventorySyncLogUpsertWithWhereUniqueWithoutResolvedByUserInput[]
    createMany?: InventorySyncLogCreateManyResolvedByUserInputEnvelope
    set?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
    disconnect?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
    delete?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
    connect?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
    update?: InventorySyncLogUpdateWithWhereUniqueWithoutResolvedByUserInput | InventorySyncLogUpdateWithWhereUniqueWithoutResolvedByUserInput[]
    updateMany?: InventorySyncLogUpdateManyWithWhereWithoutResolvedByUserInput | InventorySyncLogUpdateManyWithWhereWithoutResolvedByUserInput[]
    deleteMany?: InventorySyncLogScalarWhereInput | InventorySyncLogScalarWhereInput[]
  }

  export type InventorySyncLogUpdateManyWithoutUpdatedByUserNestedInput = {
    create?: XOR<InventorySyncLogCreateWithoutUpdatedByUserInput, InventorySyncLogUncheckedCreateWithoutUpdatedByUserInput> | InventorySyncLogCreateWithoutUpdatedByUserInput[] | InventorySyncLogUncheckedCreateWithoutUpdatedByUserInput[]
    connectOrCreate?: InventorySyncLogCreateOrConnectWithoutUpdatedByUserInput | InventorySyncLogCreateOrConnectWithoutUpdatedByUserInput[]
    upsert?: InventorySyncLogUpsertWithWhereUniqueWithoutUpdatedByUserInput | InventorySyncLogUpsertWithWhereUniqueWithoutUpdatedByUserInput[]
    createMany?: InventorySyncLogCreateManyUpdatedByUserInputEnvelope
    set?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
    disconnect?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
    delete?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
    connect?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
    update?: InventorySyncLogUpdateWithWhereUniqueWithoutUpdatedByUserInput | InventorySyncLogUpdateWithWhereUniqueWithoutUpdatedByUserInput[]
    updateMany?: InventorySyncLogUpdateManyWithWhereWithoutUpdatedByUserInput | InventorySyncLogUpdateManyWithWhereWithoutUpdatedByUserInput[]
    deleteMany?: InventorySyncLogScalarWhereInput | InventorySyncLogScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUserInput | InvoiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUserInput | InvoiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUserInput | InvoiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput = {
    create?: XOR<OrderCreateWithoutUsers_orders_payment_confirmed_byTousersInput, OrderUncheckedCreateWithoutUsers_orders_payment_confirmed_byTousersInput> | OrderCreateWithoutUsers_orders_payment_confirmed_byTousersInput[] | OrderUncheckedCreateWithoutUsers_orders_payment_confirmed_byTousersInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUsers_orders_payment_confirmed_byTousersInput | OrderCreateOrConnectWithoutUsers_orders_payment_confirmed_byTousersInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUsers_orders_payment_confirmed_byTousersInput | OrderUpsertWithWhereUniqueWithoutUsers_orders_payment_confirmed_byTousersInput[]
    createMany?: OrderCreateManyUsers_orders_payment_confirmed_byTousersInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUsers_orders_payment_confirmed_byTousersInput | OrderUpdateWithWhereUniqueWithoutUsers_orders_payment_confirmed_byTousersInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUsers_orders_payment_confirmed_byTousersInput | OrderUpdateManyWithWhereWithoutUsers_orders_payment_confirmed_byTousersInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type WorkerAttendanceUpdateManyWithoutWorkerNestedInput = {
    create?: XOR<WorkerAttendanceCreateWithoutWorkerInput, WorkerAttendanceUncheckedCreateWithoutWorkerInput> | WorkerAttendanceCreateWithoutWorkerInput[] | WorkerAttendanceUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: WorkerAttendanceCreateOrConnectWithoutWorkerInput | WorkerAttendanceCreateOrConnectWithoutWorkerInput[]
    upsert?: WorkerAttendanceUpsertWithWhereUniqueWithoutWorkerInput | WorkerAttendanceUpsertWithWhereUniqueWithoutWorkerInput[]
    createMany?: WorkerAttendanceCreateManyWorkerInputEnvelope
    set?: WorkerAttendanceWhereUniqueInput | WorkerAttendanceWhereUniqueInput[]
    disconnect?: WorkerAttendanceWhereUniqueInput | WorkerAttendanceWhereUniqueInput[]
    delete?: WorkerAttendanceWhereUniqueInput | WorkerAttendanceWhereUniqueInput[]
    connect?: WorkerAttendanceWhereUniqueInput | WorkerAttendanceWhereUniqueInput[]
    update?: WorkerAttendanceUpdateWithWhereUniqueWithoutWorkerInput | WorkerAttendanceUpdateWithWhereUniqueWithoutWorkerInput[]
    updateMany?: WorkerAttendanceUpdateManyWithWhereWithoutWorkerInput | WorkerAttendanceUpdateManyWithWhereWithoutWorkerInput[]
    deleteMany?: WorkerAttendanceScalarWhereInput | WorkerAttendanceScalarWhereInput[]
  }

  export type DeliveryUpdateManyWithoutClaimedByWorkerNestedInput = {
    create?: XOR<DeliveryCreateWithoutClaimedByWorkerInput, DeliveryUncheckedCreateWithoutClaimedByWorkerInput> | DeliveryCreateWithoutClaimedByWorkerInput[] | DeliveryUncheckedCreateWithoutClaimedByWorkerInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutClaimedByWorkerInput | DeliveryCreateOrConnectWithoutClaimedByWorkerInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutClaimedByWorkerInput | DeliveryUpsertWithWhereUniqueWithoutClaimedByWorkerInput[]
    createMany?: DeliveryCreateManyClaimedByWorkerInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutClaimedByWorkerInput | DeliveryUpdateWithWhereUniqueWithoutClaimedByWorkerInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutClaimedByWorkerInput | DeliveryUpdateManyWithWhereWithoutClaimedByWorkerInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type DeliveryLogUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<DeliveryLogCreateWithoutCreatedByUserInput, DeliveryLogUncheckedCreateWithoutCreatedByUserInput> | DeliveryLogCreateWithoutCreatedByUserInput[] | DeliveryLogUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: DeliveryLogCreateOrConnectWithoutCreatedByUserInput | DeliveryLogCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: DeliveryLogUpsertWithWhereUniqueWithoutCreatedByUserInput | DeliveryLogUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: DeliveryLogCreateManyCreatedByUserInputEnvelope
    set?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
    disconnect?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
    delete?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
    connect?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
    update?: DeliveryLogUpdateWithWhereUniqueWithoutCreatedByUserInput | DeliveryLogUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: DeliveryLogUpdateManyWithWhereWithoutCreatedByUserInput | DeliveryLogUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: DeliveryLogScalarWhereInput | DeliveryLogScalarWhereInput[]
  }

  export type DeliveryEditLogUpdateManyWithoutEditedByUserNestedInput = {
    create?: XOR<DeliveryEditLogCreateWithoutEditedByUserInput, DeliveryEditLogUncheckedCreateWithoutEditedByUserInput> | DeliveryEditLogCreateWithoutEditedByUserInput[] | DeliveryEditLogUncheckedCreateWithoutEditedByUserInput[]
    connectOrCreate?: DeliveryEditLogCreateOrConnectWithoutEditedByUserInput | DeliveryEditLogCreateOrConnectWithoutEditedByUserInput[]
    upsert?: DeliveryEditLogUpsertWithWhereUniqueWithoutEditedByUserInput | DeliveryEditLogUpsertWithWhereUniqueWithoutEditedByUserInput[]
    createMany?: DeliveryEditLogCreateManyEditedByUserInputEnvelope
    set?: DeliveryEditLogWhereUniqueInput | DeliveryEditLogWhereUniqueInput[]
    disconnect?: DeliveryEditLogWhereUniqueInput | DeliveryEditLogWhereUniqueInput[]
    delete?: DeliveryEditLogWhereUniqueInput | DeliveryEditLogWhereUniqueInput[]
    connect?: DeliveryEditLogWhereUniqueInput | DeliveryEditLogWhereUniqueInput[]
    update?: DeliveryEditLogUpdateWithWhereUniqueWithoutEditedByUserInput | DeliveryEditLogUpdateWithWhereUniqueWithoutEditedByUserInput[]
    updateMany?: DeliveryEditLogUpdateManyWithWhereWithoutEditedByUserInput | DeliveryEditLogUpdateManyWithWhereWithoutEditedByUserInput[]
    deleteMany?: DeliveryEditLogScalarWhereInput | DeliveryEditLogScalarWhereInput[]
  }

  export type WorkerNotificationUpdateManyWithoutFromAdminNestedInput = {
    create?: XOR<WorkerNotificationCreateWithoutFromAdminInput, WorkerNotificationUncheckedCreateWithoutFromAdminInput> | WorkerNotificationCreateWithoutFromAdminInput[] | WorkerNotificationUncheckedCreateWithoutFromAdminInput[]
    connectOrCreate?: WorkerNotificationCreateOrConnectWithoutFromAdminInput | WorkerNotificationCreateOrConnectWithoutFromAdminInput[]
    upsert?: WorkerNotificationUpsertWithWhereUniqueWithoutFromAdminInput | WorkerNotificationUpsertWithWhereUniqueWithoutFromAdminInput[]
    createMany?: WorkerNotificationCreateManyFromAdminInputEnvelope
    set?: WorkerNotificationWhereUniqueInput | WorkerNotificationWhereUniqueInput[]
    disconnect?: WorkerNotificationWhereUniqueInput | WorkerNotificationWhereUniqueInput[]
    delete?: WorkerNotificationWhereUniqueInput | WorkerNotificationWhereUniqueInput[]
    connect?: WorkerNotificationWhereUniqueInput | WorkerNotificationWhereUniqueInput[]
    update?: WorkerNotificationUpdateWithWhereUniqueWithoutFromAdminInput | WorkerNotificationUpdateWithWhereUniqueWithoutFromAdminInput[]
    updateMany?: WorkerNotificationUpdateManyWithWhereWithoutFromAdminInput | WorkerNotificationUpdateManyWithWhereWithoutFromAdminInput[]
    deleteMany?: WorkerNotificationScalarWhereInput | WorkerNotificationScalarWhereInput[]
  }

  export type WorkerNotificationUpdateManyWithoutWorkerNestedInput = {
    create?: XOR<WorkerNotificationCreateWithoutWorkerInput, WorkerNotificationUncheckedCreateWithoutWorkerInput> | WorkerNotificationCreateWithoutWorkerInput[] | WorkerNotificationUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: WorkerNotificationCreateOrConnectWithoutWorkerInput | WorkerNotificationCreateOrConnectWithoutWorkerInput[]
    upsert?: WorkerNotificationUpsertWithWhereUniqueWithoutWorkerInput | WorkerNotificationUpsertWithWhereUniqueWithoutWorkerInput[]
    createMany?: WorkerNotificationCreateManyWorkerInputEnvelope
    set?: WorkerNotificationWhereUniqueInput | WorkerNotificationWhereUniqueInput[]
    disconnect?: WorkerNotificationWhereUniqueInput | WorkerNotificationWhereUniqueInput[]
    delete?: WorkerNotificationWhereUniqueInput | WorkerNotificationWhereUniqueInput[]
    connect?: WorkerNotificationWhereUniqueInput | WorkerNotificationWhereUniqueInput[]
    update?: WorkerNotificationUpdateWithWhereUniqueWithoutWorkerInput | WorkerNotificationUpdateWithWhereUniqueWithoutWorkerInput[]
    updateMany?: WorkerNotificationUpdateManyWithWhereWithoutWorkerInput | WorkerNotificationUpdateManyWithWhereWithoutWorkerInput[]
    deleteMany?: WorkerNotificationScalarWhereInput | WorkerNotificationScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReceiverInput | MessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReceiverInput | MessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReceiverInput | MessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ChatGroupMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatGroupMemberCreateWithoutUserInput, ChatGroupMemberUncheckedCreateWithoutUserInput> | ChatGroupMemberCreateWithoutUserInput[] | ChatGroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatGroupMemberCreateOrConnectWithoutUserInput | ChatGroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: ChatGroupMemberUpsertWithWhereUniqueWithoutUserInput | ChatGroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatGroupMemberCreateManyUserInputEnvelope
    set?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    disconnect?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    delete?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    connect?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    update?: ChatGroupMemberUpdateWithWhereUniqueWithoutUserInput | ChatGroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatGroupMemberUpdateManyWithWhereWithoutUserInput | ChatGroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatGroupMemberScalarWhereInput | ChatGroupMemberScalarWhereInput[]
  }

  export type GroupMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<GroupMessageCreateWithoutSenderInput, GroupMessageUncheckedCreateWithoutSenderInput> | GroupMessageCreateWithoutSenderInput[] | GroupMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: GroupMessageCreateOrConnectWithoutSenderInput | GroupMessageCreateOrConnectWithoutSenderInput[]
    upsert?: GroupMessageUpsertWithWhereUniqueWithoutSenderInput | GroupMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: GroupMessageCreateManySenderInputEnvelope
    set?: GroupMessageWhereUniqueInput | GroupMessageWhereUniqueInput[]
    disconnect?: GroupMessageWhereUniqueInput | GroupMessageWhereUniqueInput[]
    delete?: GroupMessageWhereUniqueInput | GroupMessageWhereUniqueInput[]
    connect?: GroupMessageWhereUniqueInput | GroupMessageWhereUniqueInput[]
    update?: GroupMessageUpdateWithWhereUniqueWithoutSenderInput | GroupMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: GroupMessageUpdateManyWithWhereWithoutSenderInput | GroupMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: GroupMessageScalarWhereInput | GroupMessageScalarWhereInput[]
  }

  export type NotificationDismissalUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationDismissalCreateWithoutUserInput, NotificationDismissalUncheckedCreateWithoutUserInput> | NotificationDismissalCreateWithoutUserInput[] | NotificationDismissalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationDismissalCreateOrConnectWithoutUserInput | NotificationDismissalCreateOrConnectWithoutUserInput[]
    upsert?: NotificationDismissalUpsertWithWhereUniqueWithoutUserInput | NotificationDismissalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationDismissalCreateManyUserInputEnvelope
    set?: NotificationDismissalWhereUniqueInput | NotificationDismissalWhereUniqueInput[]
    disconnect?: NotificationDismissalWhereUniqueInput | NotificationDismissalWhereUniqueInput[]
    delete?: NotificationDismissalWhereUniqueInput | NotificationDismissalWhereUniqueInput[]
    connect?: NotificationDismissalWhereUniqueInput | NotificationDismissalWhereUniqueInput[]
    update?: NotificationDismissalUpdateWithWhereUniqueWithoutUserInput | NotificationDismissalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationDismissalUpdateManyWithWhereWithoutUserInput | NotificationDismissalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationDismissalScalarWhereInput | NotificationDismissalScalarWhereInput[]
  }

  export type SystemNotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<SystemNotificationCreateWithoutUserInput, SystemNotificationUncheckedCreateWithoutUserInput> | SystemNotificationCreateWithoutUserInput[] | SystemNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemNotificationCreateOrConnectWithoutUserInput | SystemNotificationCreateOrConnectWithoutUserInput[]
    upsert?: SystemNotificationUpsertWithWhereUniqueWithoutUserInput | SystemNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SystemNotificationCreateManyUserInputEnvelope
    set?: SystemNotificationWhereUniqueInput | SystemNotificationWhereUniqueInput[]
    disconnect?: SystemNotificationWhereUniqueInput | SystemNotificationWhereUniqueInput[]
    delete?: SystemNotificationWhereUniqueInput | SystemNotificationWhereUniqueInput[]
    connect?: SystemNotificationWhereUniqueInput | SystemNotificationWhereUniqueInput[]
    update?: SystemNotificationUpdateWithWhereUniqueWithoutUserInput | SystemNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SystemNotificationUpdateManyWithWhereWithoutUserInput | SystemNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SystemNotificationScalarWhereInput | SystemNotificationScalarWhereInput[]
  }

  export type PaymentTransactionUpdateManyWithoutVerifiedByNestedInput = {
    create?: XOR<PaymentTransactionCreateWithoutVerifiedByInput, PaymentTransactionUncheckedCreateWithoutVerifiedByInput> | PaymentTransactionCreateWithoutVerifiedByInput[] | PaymentTransactionUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutVerifiedByInput | PaymentTransactionCreateOrConnectWithoutVerifiedByInput[]
    upsert?: PaymentTransactionUpsertWithWhereUniqueWithoutVerifiedByInput | PaymentTransactionUpsertWithWhereUniqueWithoutVerifiedByInput[]
    createMany?: PaymentTransactionCreateManyVerifiedByInputEnvelope
    set?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    disconnect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    delete?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    update?: PaymentTransactionUpdateWithWhereUniqueWithoutVerifiedByInput | PaymentTransactionUpdateWithWhereUniqueWithoutVerifiedByInput[]
    updateMany?: PaymentTransactionUpdateManyWithWhereWithoutVerifiedByInput | PaymentTransactionUpdateManyWithWhereWithoutVerifiedByInput[]
    deleteMany?: PaymentTransactionScalarWhereInput | PaymentTransactionScalarWhereInput[]
  }

  export type UnitHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<UnitHistoryCreateWithoutUserInput, UnitHistoryUncheckedCreateWithoutUserInput> | UnitHistoryCreateWithoutUserInput[] | UnitHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UnitHistoryCreateOrConnectWithoutUserInput | UnitHistoryCreateOrConnectWithoutUserInput[]
    upsert?: UnitHistoryUpsertWithWhereUniqueWithoutUserInput | UnitHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UnitHistoryCreateManyUserInputEnvelope
    set?: UnitHistoryWhereUniqueInput | UnitHistoryWhereUniqueInput[]
    disconnect?: UnitHistoryWhereUniqueInput | UnitHistoryWhereUniqueInput[]
    delete?: UnitHistoryWhereUniqueInput | UnitHistoryWhereUniqueInput[]
    connect?: UnitHistoryWhereUniqueInput | UnitHistoryWhereUniqueInput[]
    update?: UnitHistoryUpdateWithWhereUniqueWithoutUserInput | UnitHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UnitHistoryUpdateManyWithWhereWithoutUserInput | UnitHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UnitHistoryScalarWhereInput | UnitHistoryScalarWhereInput[]
  }

  export type AiActionUpdateManyWithoutApproverNestedInput = {
    create?: XOR<AiActionCreateWithoutApproverInput, AiActionUncheckedCreateWithoutApproverInput> | AiActionCreateWithoutApproverInput[] | AiActionUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: AiActionCreateOrConnectWithoutApproverInput | AiActionCreateOrConnectWithoutApproverInput[]
    upsert?: AiActionUpsertWithWhereUniqueWithoutApproverInput | AiActionUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: AiActionCreateManyApproverInputEnvelope
    set?: AiActionWhereUniqueInput | AiActionWhereUniqueInput[]
    disconnect?: AiActionWhereUniqueInput | AiActionWhereUniqueInput[]
    delete?: AiActionWhereUniqueInput | AiActionWhereUniqueInput[]
    connect?: AiActionWhereUniqueInput | AiActionWhereUniqueInput[]
    update?: AiActionUpdateWithWhereUniqueWithoutApproverInput | AiActionUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: AiActionUpdateManyWithWhereWithoutApproverInput | AiActionUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: AiActionScalarWhereInput | AiActionScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type InventorySyncLogUncheckedUpdateManyWithoutResolvedByUserNestedInput = {
    create?: XOR<InventorySyncLogCreateWithoutResolvedByUserInput, InventorySyncLogUncheckedCreateWithoutResolvedByUserInput> | InventorySyncLogCreateWithoutResolvedByUserInput[] | InventorySyncLogUncheckedCreateWithoutResolvedByUserInput[]
    connectOrCreate?: InventorySyncLogCreateOrConnectWithoutResolvedByUserInput | InventorySyncLogCreateOrConnectWithoutResolvedByUserInput[]
    upsert?: InventorySyncLogUpsertWithWhereUniqueWithoutResolvedByUserInput | InventorySyncLogUpsertWithWhereUniqueWithoutResolvedByUserInput[]
    createMany?: InventorySyncLogCreateManyResolvedByUserInputEnvelope
    set?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
    disconnect?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
    delete?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
    connect?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
    update?: InventorySyncLogUpdateWithWhereUniqueWithoutResolvedByUserInput | InventorySyncLogUpdateWithWhereUniqueWithoutResolvedByUserInput[]
    updateMany?: InventorySyncLogUpdateManyWithWhereWithoutResolvedByUserInput | InventorySyncLogUpdateManyWithWhereWithoutResolvedByUserInput[]
    deleteMany?: InventorySyncLogScalarWhereInput | InventorySyncLogScalarWhereInput[]
  }

  export type InventorySyncLogUncheckedUpdateManyWithoutUpdatedByUserNestedInput = {
    create?: XOR<InventorySyncLogCreateWithoutUpdatedByUserInput, InventorySyncLogUncheckedCreateWithoutUpdatedByUserInput> | InventorySyncLogCreateWithoutUpdatedByUserInput[] | InventorySyncLogUncheckedCreateWithoutUpdatedByUserInput[]
    connectOrCreate?: InventorySyncLogCreateOrConnectWithoutUpdatedByUserInput | InventorySyncLogCreateOrConnectWithoutUpdatedByUserInput[]
    upsert?: InventorySyncLogUpsertWithWhereUniqueWithoutUpdatedByUserInput | InventorySyncLogUpsertWithWhereUniqueWithoutUpdatedByUserInput[]
    createMany?: InventorySyncLogCreateManyUpdatedByUserInputEnvelope
    set?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
    disconnect?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
    delete?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
    connect?: InventorySyncLogWhereUniqueInput | InventorySyncLogWhereUniqueInput[]
    update?: InventorySyncLogUpdateWithWhereUniqueWithoutUpdatedByUserInput | InventorySyncLogUpdateWithWhereUniqueWithoutUpdatedByUserInput[]
    updateMany?: InventorySyncLogUpdateManyWithWhereWithoutUpdatedByUserInput | InventorySyncLogUpdateManyWithWhereWithoutUpdatedByUserInput[]
    deleteMany?: InventorySyncLogScalarWhereInput | InventorySyncLogScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUserInput | InvoiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUserInput | InvoiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUserInput | InvoiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput = {
    create?: XOR<OrderCreateWithoutUsers_orders_payment_confirmed_byTousersInput, OrderUncheckedCreateWithoutUsers_orders_payment_confirmed_byTousersInput> | OrderCreateWithoutUsers_orders_payment_confirmed_byTousersInput[] | OrderUncheckedCreateWithoutUsers_orders_payment_confirmed_byTousersInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUsers_orders_payment_confirmed_byTousersInput | OrderCreateOrConnectWithoutUsers_orders_payment_confirmed_byTousersInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUsers_orders_payment_confirmed_byTousersInput | OrderUpsertWithWhereUniqueWithoutUsers_orders_payment_confirmed_byTousersInput[]
    createMany?: OrderCreateManyUsers_orders_payment_confirmed_byTousersInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUsers_orders_payment_confirmed_byTousersInput | OrderUpdateWithWhereUniqueWithoutUsers_orders_payment_confirmed_byTousersInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUsers_orders_payment_confirmed_byTousersInput | OrderUpdateManyWithWhereWithoutUsers_orders_payment_confirmed_byTousersInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type WorkerAttendanceUncheckedUpdateManyWithoutWorkerNestedInput = {
    create?: XOR<WorkerAttendanceCreateWithoutWorkerInput, WorkerAttendanceUncheckedCreateWithoutWorkerInput> | WorkerAttendanceCreateWithoutWorkerInput[] | WorkerAttendanceUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: WorkerAttendanceCreateOrConnectWithoutWorkerInput | WorkerAttendanceCreateOrConnectWithoutWorkerInput[]
    upsert?: WorkerAttendanceUpsertWithWhereUniqueWithoutWorkerInput | WorkerAttendanceUpsertWithWhereUniqueWithoutWorkerInput[]
    createMany?: WorkerAttendanceCreateManyWorkerInputEnvelope
    set?: WorkerAttendanceWhereUniqueInput | WorkerAttendanceWhereUniqueInput[]
    disconnect?: WorkerAttendanceWhereUniqueInput | WorkerAttendanceWhereUniqueInput[]
    delete?: WorkerAttendanceWhereUniqueInput | WorkerAttendanceWhereUniqueInput[]
    connect?: WorkerAttendanceWhereUniqueInput | WorkerAttendanceWhereUniqueInput[]
    update?: WorkerAttendanceUpdateWithWhereUniqueWithoutWorkerInput | WorkerAttendanceUpdateWithWhereUniqueWithoutWorkerInput[]
    updateMany?: WorkerAttendanceUpdateManyWithWhereWithoutWorkerInput | WorkerAttendanceUpdateManyWithWhereWithoutWorkerInput[]
    deleteMany?: WorkerAttendanceScalarWhereInput | WorkerAttendanceScalarWhereInput[]
  }

  export type DeliveryUncheckedUpdateManyWithoutClaimedByWorkerNestedInput = {
    create?: XOR<DeliveryCreateWithoutClaimedByWorkerInput, DeliveryUncheckedCreateWithoutClaimedByWorkerInput> | DeliveryCreateWithoutClaimedByWorkerInput[] | DeliveryUncheckedCreateWithoutClaimedByWorkerInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutClaimedByWorkerInput | DeliveryCreateOrConnectWithoutClaimedByWorkerInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutClaimedByWorkerInput | DeliveryUpsertWithWhereUniqueWithoutClaimedByWorkerInput[]
    createMany?: DeliveryCreateManyClaimedByWorkerInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutClaimedByWorkerInput | DeliveryUpdateWithWhereUniqueWithoutClaimedByWorkerInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutClaimedByWorkerInput | DeliveryUpdateManyWithWhereWithoutClaimedByWorkerInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type DeliveryLogUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<DeliveryLogCreateWithoutCreatedByUserInput, DeliveryLogUncheckedCreateWithoutCreatedByUserInput> | DeliveryLogCreateWithoutCreatedByUserInput[] | DeliveryLogUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: DeliveryLogCreateOrConnectWithoutCreatedByUserInput | DeliveryLogCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: DeliveryLogUpsertWithWhereUniqueWithoutCreatedByUserInput | DeliveryLogUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: DeliveryLogCreateManyCreatedByUserInputEnvelope
    set?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
    disconnect?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
    delete?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
    connect?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
    update?: DeliveryLogUpdateWithWhereUniqueWithoutCreatedByUserInput | DeliveryLogUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: DeliveryLogUpdateManyWithWhereWithoutCreatedByUserInput | DeliveryLogUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: DeliveryLogScalarWhereInput | DeliveryLogScalarWhereInput[]
  }

  export type DeliveryEditLogUncheckedUpdateManyWithoutEditedByUserNestedInput = {
    create?: XOR<DeliveryEditLogCreateWithoutEditedByUserInput, DeliveryEditLogUncheckedCreateWithoutEditedByUserInput> | DeliveryEditLogCreateWithoutEditedByUserInput[] | DeliveryEditLogUncheckedCreateWithoutEditedByUserInput[]
    connectOrCreate?: DeliveryEditLogCreateOrConnectWithoutEditedByUserInput | DeliveryEditLogCreateOrConnectWithoutEditedByUserInput[]
    upsert?: DeliveryEditLogUpsertWithWhereUniqueWithoutEditedByUserInput | DeliveryEditLogUpsertWithWhereUniqueWithoutEditedByUserInput[]
    createMany?: DeliveryEditLogCreateManyEditedByUserInputEnvelope
    set?: DeliveryEditLogWhereUniqueInput | DeliveryEditLogWhereUniqueInput[]
    disconnect?: DeliveryEditLogWhereUniqueInput | DeliveryEditLogWhereUniqueInput[]
    delete?: DeliveryEditLogWhereUniqueInput | DeliveryEditLogWhereUniqueInput[]
    connect?: DeliveryEditLogWhereUniqueInput | DeliveryEditLogWhereUniqueInput[]
    update?: DeliveryEditLogUpdateWithWhereUniqueWithoutEditedByUserInput | DeliveryEditLogUpdateWithWhereUniqueWithoutEditedByUserInput[]
    updateMany?: DeliveryEditLogUpdateManyWithWhereWithoutEditedByUserInput | DeliveryEditLogUpdateManyWithWhereWithoutEditedByUserInput[]
    deleteMany?: DeliveryEditLogScalarWhereInput | DeliveryEditLogScalarWhereInput[]
  }

  export type WorkerNotificationUncheckedUpdateManyWithoutFromAdminNestedInput = {
    create?: XOR<WorkerNotificationCreateWithoutFromAdminInput, WorkerNotificationUncheckedCreateWithoutFromAdminInput> | WorkerNotificationCreateWithoutFromAdminInput[] | WorkerNotificationUncheckedCreateWithoutFromAdminInput[]
    connectOrCreate?: WorkerNotificationCreateOrConnectWithoutFromAdminInput | WorkerNotificationCreateOrConnectWithoutFromAdminInput[]
    upsert?: WorkerNotificationUpsertWithWhereUniqueWithoutFromAdminInput | WorkerNotificationUpsertWithWhereUniqueWithoutFromAdminInput[]
    createMany?: WorkerNotificationCreateManyFromAdminInputEnvelope
    set?: WorkerNotificationWhereUniqueInput | WorkerNotificationWhereUniqueInput[]
    disconnect?: WorkerNotificationWhereUniqueInput | WorkerNotificationWhereUniqueInput[]
    delete?: WorkerNotificationWhereUniqueInput | WorkerNotificationWhereUniqueInput[]
    connect?: WorkerNotificationWhereUniqueInput | WorkerNotificationWhereUniqueInput[]
    update?: WorkerNotificationUpdateWithWhereUniqueWithoutFromAdminInput | WorkerNotificationUpdateWithWhereUniqueWithoutFromAdminInput[]
    updateMany?: WorkerNotificationUpdateManyWithWhereWithoutFromAdminInput | WorkerNotificationUpdateManyWithWhereWithoutFromAdminInput[]
    deleteMany?: WorkerNotificationScalarWhereInput | WorkerNotificationScalarWhereInput[]
  }

  export type WorkerNotificationUncheckedUpdateManyWithoutWorkerNestedInput = {
    create?: XOR<WorkerNotificationCreateWithoutWorkerInput, WorkerNotificationUncheckedCreateWithoutWorkerInput> | WorkerNotificationCreateWithoutWorkerInput[] | WorkerNotificationUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: WorkerNotificationCreateOrConnectWithoutWorkerInput | WorkerNotificationCreateOrConnectWithoutWorkerInput[]
    upsert?: WorkerNotificationUpsertWithWhereUniqueWithoutWorkerInput | WorkerNotificationUpsertWithWhereUniqueWithoutWorkerInput[]
    createMany?: WorkerNotificationCreateManyWorkerInputEnvelope
    set?: WorkerNotificationWhereUniqueInput | WorkerNotificationWhereUniqueInput[]
    disconnect?: WorkerNotificationWhereUniqueInput | WorkerNotificationWhereUniqueInput[]
    delete?: WorkerNotificationWhereUniqueInput | WorkerNotificationWhereUniqueInput[]
    connect?: WorkerNotificationWhereUniqueInput | WorkerNotificationWhereUniqueInput[]
    update?: WorkerNotificationUpdateWithWhereUniqueWithoutWorkerInput | WorkerNotificationUpdateWithWhereUniqueWithoutWorkerInput[]
    updateMany?: WorkerNotificationUpdateManyWithWhereWithoutWorkerInput | WorkerNotificationUpdateManyWithWhereWithoutWorkerInput[]
    deleteMany?: WorkerNotificationScalarWhereInput | WorkerNotificationScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReceiverInput | MessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReceiverInput | MessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReceiverInput | MessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatGroupMemberCreateWithoutUserInput, ChatGroupMemberUncheckedCreateWithoutUserInput> | ChatGroupMemberCreateWithoutUserInput[] | ChatGroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatGroupMemberCreateOrConnectWithoutUserInput | ChatGroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: ChatGroupMemberUpsertWithWhereUniqueWithoutUserInput | ChatGroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatGroupMemberCreateManyUserInputEnvelope
    set?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    disconnect?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    delete?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    connect?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    update?: ChatGroupMemberUpdateWithWhereUniqueWithoutUserInput | ChatGroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatGroupMemberUpdateManyWithWhereWithoutUserInput | ChatGroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatGroupMemberScalarWhereInput | ChatGroupMemberScalarWhereInput[]
  }

  export type GroupMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<GroupMessageCreateWithoutSenderInput, GroupMessageUncheckedCreateWithoutSenderInput> | GroupMessageCreateWithoutSenderInput[] | GroupMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: GroupMessageCreateOrConnectWithoutSenderInput | GroupMessageCreateOrConnectWithoutSenderInput[]
    upsert?: GroupMessageUpsertWithWhereUniqueWithoutSenderInput | GroupMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: GroupMessageCreateManySenderInputEnvelope
    set?: GroupMessageWhereUniqueInput | GroupMessageWhereUniqueInput[]
    disconnect?: GroupMessageWhereUniqueInput | GroupMessageWhereUniqueInput[]
    delete?: GroupMessageWhereUniqueInput | GroupMessageWhereUniqueInput[]
    connect?: GroupMessageWhereUniqueInput | GroupMessageWhereUniqueInput[]
    update?: GroupMessageUpdateWithWhereUniqueWithoutSenderInput | GroupMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: GroupMessageUpdateManyWithWhereWithoutSenderInput | GroupMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: GroupMessageScalarWhereInput | GroupMessageScalarWhereInput[]
  }

  export type NotificationDismissalUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationDismissalCreateWithoutUserInput, NotificationDismissalUncheckedCreateWithoutUserInput> | NotificationDismissalCreateWithoutUserInput[] | NotificationDismissalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationDismissalCreateOrConnectWithoutUserInput | NotificationDismissalCreateOrConnectWithoutUserInput[]
    upsert?: NotificationDismissalUpsertWithWhereUniqueWithoutUserInput | NotificationDismissalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationDismissalCreateManyUserInputEnvelope
    set?: NotificationDismissalWhereUniqueInput | NotificationDismissalWhereUniqueInput[]
    disconnect?: NotificationDismissalWhereUniqueInput | NotificationDismissalWhereUniqueInput[]
    delete?: NotificationDismissalWhereUniqueInput | NotificationDismissalWhereUniqueInput[]
    connect?: NotificationDismissalWhereUniqueInput | NotificationDismissalWhereUniqueInput[]
    update?: NotificationDismissalUpdateWithWhereUniqueWithoutUserInput | NotificationDismissalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationDismissalUpdateManyWithWhereWithoutUserInput | NotificationDismissalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationDismissalScalarWhereInput | NotificationDismissalScalarWhereInput[]
  }

  export type SystemNotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SystemNotificationCreateWithoutUserInput, SystemNotificationUncheckedCreateWithoutUserInput> | SystemNotificationCreateWithoutUserInput[] | SystemNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemNotificationCreateOrConnectWithoutUserInput | SystemNotificationCreateOrConnectWithoutUserInput[]
    upsert?: SystemNotificationUpsertWithWhereUniqueWithoutUserInput | SystemNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SystemNotificationCreateManyUserInputEnvelope
    set?: SystemNotificationWhereUniqueInput | SystemNotificationWhereUniqueInput[]
    disconnect?: SystemNotificationWhereUniqueInput | SystemNotificationWhereUniqueInput[]
    delete?: SystemNotificationWhereUniqueInput | SystemNotificationWhereUniqueInput[]
    connect?: SystemNotificationWhereUniqueInput | SystemNotificationWhereUniqueInput[]
    update?: SystemNotificationUpdateWithWhereUniqueWithoutUserInput | SystemNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SystemNotificationUpdateManyWithWhereWithoutUserInput | SystemNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SystemNotificationScalarWhereInput | SystemNotificationScalarWhereInput[]
  }

  export type PaymentTransactionUncheckedUpdateManyWithoutVerifiedByNestedInput = {
    create?: XOR<PaymentTransactionCreateWithoutVerifiedByInput, PaymentTransactionUncheckedCreateWithoutVerifiedByInput> | PaymentTransactionCreateWithoutVerifiedByInput[] | PaymentTransactionUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutVerifiedByInput | PaymentTransactionCreateOrConnectWithoutVerifiedByInput[]
    upsert?: PaymentTransactionUpsertWithWhereUniqueWithoutVerifiedByInput | PaymentTransactionUpsertWithWhereUniqueWithoutVerifiedByInput[]
    createMany?: PaymentTransactionCreateManyVerifiedByInputEnvelope
    set?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    disconnect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    delete?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    update?: PaymentTransactionUpdateWithWhereUniqueWithoutVerifiedByInput | PaymentTransactionUpdateWithWhereUniqueWithoutVerifiedByInput[]
    updateMany?: PaymentTransactionUpdateManyWithWhereWithoutVerifiedByInput | PaymentTransactionUpdateManyWithWhereWithoutVerifiedByInput[]
    deleteMany?: PaymentTransactionScalarWhereInput | PaymentTransactionScalarWhereInput[]
  }

  export type UnitHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UnitHistoryCreateWithoutUserInput, UnitHistoryUncheckedCreateWithoutUserInput> | UnitHistoryCreateWithoutUserInput[] | UnitHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UnitHistoryCreateOrConnectWithoutUserInput | UnitHistoryCreateOrConnectWithoutUserInput[]
    upsert?: UnitHistoryUpsertWithWhereUniqueWithoutUserInput | UnitHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UnitHistoryCreateManyUserInputEnvelope
    set?: UnitHistoryWhereUniqueInput | UnitHistoryWhereUniqueInput[]
    disconnect?: UnitHistoryWhereUniqueInput | UnitHistoryWhereUniqueInput[]
    delete?: UnitHistoryWhereUniqueInput | UnitHistoryWhereUniqueInput[]
    connect?: UnitHistoryWhereUniqueInput | UnitHistoryWhereUniqueInput[]
    update?: UnitHistoryUpdateWithWhereUniqueWithoutUserInput | UnitHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UnitHistoryUpdateManyWithWhereWithoutUserInput | UnitHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UnitHistoryScalarWhereInput | UnitHistoryScalarWhereInput[]
  }

  export type AiActionUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<AiActionCreateWithoutApproverInput, AiActionUncheckedCreateWithoutApproverInput> | AiActionCreateWithoutApproverInput[] | AiActionUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: AiActionCreateOrConnectWithoutApproverInput | AiActionCreateOrConnectWithoutApproverInput[]
    upsert?: AiActionUpsertWithWhereUniqueWithoutApproverInput | AiActionUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: AiActionCreateManyApproverInputEnvelope
    set?: AiActionWhereUniqueInput | AiActionWhereUniqueInput[]
    disconnect?: AiActionWhereUniqueInput | AiActionWhereUniqueInput[]
    delete?: AiActionWhereUniqueInput | AiActionWhereUniqueInput[]
    connect?: AiActionWhereUniqueInput | AiActionWhereUniqueInput[]
    update?: AiActionUpdateWithWhereUniqueWithoutApproverInput | AiActionUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: AiActionUpdateManyWithWhereWithoutApproverInput | AiActionUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: AiActionScalarWhereInput | AiActionScalarWhereInput[]
  }

  export type ChatGroupMemberCreateNestedManyWithoutGroupInput = {
    create?: XOR<ChatGroupMemberCreateWithoutGroupInput, ChatGroupMemberUncheckedCreateWithoutGroupInput> | ChatGroupMemberCreateWithoutGroupInput[] | ChatGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ChatGroupMemberCreateOrConnectWithoutGroupInput | ChatGroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: ChatGroupMemberCreateManyGroupInputEnvelope
    connect?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
  }

  export type GroupMessageCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMessageCreateWithoutGroupInput, GroupMessageUncheckedCreateWithoutGroupInput> | GroupMessageCreateWithoutGroupInput[] | GroupMessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMessageCreateOrConnectWithoutGroupInput | GroupMessageCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMessageCreateManyGroupInputEnvelope
    connect?: GroupMessageWhereUniqueInput | GroupMessageWhereUniqueInput[]
  }

  export type ChatGroupMemberUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<ChatGroupMemberCreateWithoutGroupInput, ChatGroupMemberUncheckedCreateWithoutGroupInput> | ChatGroupMemberCreateWithoutGroupInput[] | ChatGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ChatGroupMemberCreateOrConnectWithoutGroupInput | ChatGroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: ChatGroupMemberCreateManyGroupInputEnvelope
    connect?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
  }

  export type GroupMessageUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMessageCreateWithoutGroupInput, GroupMessageUncheckedCreateWithoutGroupInput> | GroupMessageCreateWithoutGroupInput[] | GroupMessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMessageCreateOrConnectWithoutGroupInput | GroupMessageCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMessageCreateManyGroupInputEnvelope
    connect?: GroupMessageWhereUniqueInput | GroupMessageWhereUniqueInput[]
  }

  export type ChatGroupMemberUpdateManyWithoutGroupNestedInput = {
    create?: XOR<ChatGroupMemberCreateWithoutGroupInput, ChatGroupMemberUncheckedCreateWithoutGroupInput> | ChatGroupMemberCreateWithoutGroupInput[] | ChatGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ChatGroupMemberCreateOrConnectWithoutGroupInput | ChatGroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: ChatGroupMemberUpsertWithWhereUniqueWithoutGroupInput | ChatGroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: ChatGroupMemberCreateManyGroupInputEnvelope
    set?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    disconnect?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    delete?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    connect?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    update?: ChatGroupMemberUpdateWithWhereUniqueWithoutGroupInput | ChatGroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: ChatGroupMemberUpdateManyWithWhereWithoutGroupInput | ChatGroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: ChatGroupMemberScalarWhereInput | ChatGroupMemberScalarWhereInput[]
  }

  export type GroupMessageUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMessageCreateWithoutGroupInput, GroupMessageUncheckedCreateWithoutGroupInput> | GroupMessageCreateWithoutGroupInput[] | GroupMessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMessageCreateOrConnectWithoutGroupInput | GroupMessageCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMessageUpsertWithWhereUniqueWithoutGroupInput | GroupMessageUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMessageCreateManyGroupInputEnvelope
    set?: GroupMessageWhereUniqueInput | GroupMessageWhereUniqueInput[]
    disconnect?: GroupMessageWhereUniqueInput | GroupMessageWhereUniqueInput[]
    delete?: GroupMessageWhereUniqueInput | GroupMessageWhereUniqueInput[]
    connect?: GroupMessageWhereUniqueInput | GroupMessageWhereUniqueInput[]
    update?: GroupMessageUpdateWithWhereUniqueWithoutGroupInput | GroupMessageUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMessageUpdateManyWithWhereWithoutGroupInput | GroupMessageUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMessageScalarWhereInput | GroupMessageScalarWhereInput[]
  }

  export type ChatGroupMemberUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<ChatGroupMemberCreateWithoutGroupInput, ChatGroupMemberUncheckedCreateWithoutGroupInput> | ChatGroupMemberCreateWithoutGroupInput[] | ChatGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ChatGroupMemberCreateOrConnectWithoutGroupInput | ChatGroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: ChatGroupMemberUpsertWithWhereUniqueWithoutGroupInput | ChatGroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: ChatGroupMemberCreateManyGroupInputEnvelope
    set?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    disconnect?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    delete?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    connect?: ChatGroupMemberWhereUniqueInput | ChatGroupMemberWhereUniqueInput[]
    update?: ChatGroupMemberUpdateWithWhereUniqueWithoutGroupInput | ChatGroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: ChatGroupMemberUpdateManyWithWhereWithoutGroupInput | ChatGroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: ChatGroupMemberScalarWhereInput | ChatGroupMemberScalarWhereInput[]
  }

  export type GroupMessageUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMessageCreateWithoutGroupInput, GroupMessageUncheckedCreateWithoutGroupInput> | GroupMessageCreateWithoutGroupInput[] | GroupMessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMessageCreateOrConnectWithoutGroupInput | GroupMessageCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMessageUpsertWithWhereUniqueWithoutGroupInput | GroupMessageUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMessageCreateManyGroupInputEnvelope
    set?: GroupMessageWhereUniqueInput | GroupMessageWhereUniqueInput[]
    disconnect?: GroupMessageWhereUniqueInput | GroupMessageWhereUniqueInput[]
    delete?: GroupMessageWhereUniqueInput | GroupMessageWhereUniqueInput[]
    connect?: GroupMessageWhereUniqueInput | GroupMessageWhereUniqueInput[]
    update?: GroupMessageUpdateWithWhereUniqueWithoutGroupInput | GroupMessageUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMessageUpdateManyWithWhereWithoutGroupInput | GroupMessageUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMessageScalarWhereInput | GroupMessageScalarWhereInput[]
  }

  export type ChatGroupCreateNestedOneWithoutMembersInput = {
    create?: XOR<ChatGroupCreateWithoutMembersInput, ChatGroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ChatGroupCreateOrConnectWithoutMembersInput
    connect?: ChatGroupWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChatGroupMembershipsInput = {
    create?: XOR<UserCreateWithoutChatGroupMembershipsInput, UserUncheckedCreateWithoutChatGroupMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatGroupMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type ChatGroupUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ChatGroupCreateWithoutMembersInput, ChatGroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ChatGroupCreateOrConnectWithoutMembersInput
    upsert?: ChatGroupUpsertWithoutMembersInput
    connect?: ChatGroupWhereUniqueInput
    update?: XOR<XOR<ChatGroupUpdateToOneWithWhereWithoutMembersInput, ChatGroupUpdateWithoutMembersInput>, ChatGroupUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutChatGroupMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutChatGroupMembershipsInput, UserUncheckedCreateWithoutChatGroupMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatGroupMembershipsInput
    upsert?: UserUpsertWithoutChatGroupMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatGroupMembershipsInput, UserUpdateWithoutChatGroupMembershipsInput>, UserUncheckedUpdateWithoutChatGroupMembershipsInput>
  }

  export type ChatGroupCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatGroupCreateWithoutMessagesInput, ChatGroupUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatGroupCreateOrConnectWithoutMessagesInput
    connect?: ChatGroupWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentGroupMessagesInput = {
    create?: XOR<UserCreateWithoutSentGroupMessagesInput, UserUncheckedCreateWithoutSentGroupMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentGroupMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type ChatGroupUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatGroupCreateWithoutMessagesInput, ChatGroupUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatGroupCreateOrConnectWithoutMessagesInput
    upsert?: ChatGroupUpsertWithoutMessagesInput
    connect?: ChatGroupWhereUniqueInput
    update?: XOR<XOR<ChatGroupUpdateToOneWithWhereWithoutMessagesInput, ChatGroupUpdateWithoutMessagesInput>, ChatGroupUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutSentGroupMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentGroupMessagesInput, UserUncheckedCreateWithoutSentGroupMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentGroupMessagesInput
    upsert?: UserUpsertWithoutSentGroupMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentGroupMessagesInput, UserUpdateWithoutSentGroupMessagesInput>, UserUncheckedUpdateWithoutSentGroupMessagesInput>
  }

  export type UserCreateNestedOneWithoutActivityLogsInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutActivityLogsNestedInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    upsert?: UserUpsertWithoutActivityLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityLogsInput, UserUpdateWithoutActivityLogsInput>, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserCreateNestedOneWithoutWorkerAttendanceInput = {
    create?: XOR<UserCreateWithoutWorkerAttendanceInput, UserUncheckedCreateWithoutWorkerAttendanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkerAttendanceInput
    connect?: UserWhereUniqueInput
  }

  export type NullableEnumattendance_statusFieldUpdateOperationsInput = {
    set?: $Enums.attendance_status | null
  }

  export type UserUpdateOneRequiredWithoutWorkerAttendanceNestedInput = {
    create?: XOR<UserCreateWithoutWorkerAttendanceInput, UserUncheckedCreateWithoutWorkerAttendanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkerAttendanceInput
    upsert?: UserUpsertWithoutWorkerAttendanceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkerAttendanceInput, UserUpdateWithoutWorkerAttendanceInput>, UserUncheckedUpdateWithoutWorkerAttendanceInput>
  }

  export type ProductCreateNestedOneWithoutInventorySyncLogsInput = {
    create?: XOR<ProductCreateWithoutInventorySyncLogsInput, ProductUncheckedCreateWithoutInventorySyncLogsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventorySyncLogsInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInventoryResolutionsInput = {
    create?: XOR<UserCreateWithoutInventoryResolutionsInput, UserUncheckedCreateWithoutInventoryResolutionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryResolutionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInventoryUpdatesInput = {
    create?: XOR<UserCreateWithoutInventoryUpdatesInput, UserUncheckedCreateWithoutInventoryUpdatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryUpdatesInput
    connect?: UserWhereUniqueInput
  }

  export type Enuminventory_sourceFieldUpdateOperationsInput = {
    set?: $Enums.inventory_source
  }

  export type ProductUpdateOneRequiredWithoutInventorySyncLogsNestedInput = {
    create?: XOR<ProductCreateWithoutInventorySyncLogsInput, ProductUncheckedCreateWithoutInventorySyncLogsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventorySyncLogsInput
    upsert?: ProductUpsertWithoutInventorySyncLogsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutInventorySyncLogsInput, ProductUpdateWithoutInventorySyncLogsInput>, ProductUncheckedUpdateWithoutInventorySyncLogsInput>
  }

  export type UserUpdateOneWithoutInventoryResolutionsNestedInput = {
    create?: XOR<UserCreateWithoutInventoryResolutionsInput, UserUncheckedCreateWithoutInventoryResolutionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryResolutionsInput
    upsert?: UserUpsertWithoutInventoryResolutionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryResolutionsInput, UserUpdateWithoutInventoryResolutionsInput>, UserUncheckedUpdateWithoutInventoryResolutionsInput>
  }

  export type UserUpdateOneRequiredWithoutInventoryUpdatesNestedInput = {
    create?: XOR<UserCreateWithoutInventoryUpdatesInput, UserUncheckedCreateWithoutInventoryUpdatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryUpdatesInput
    upsert?: UserUpsertWithoutInventoryUpdatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryUpdatesInput, UserUpdateWithoutInventoryUpdatesInput>, UserUncheckedUpdateWithoutInventoryUpdatesInput>
  }

  export type UserCreateNestedOneWithoutSentNotificationsInput = {
    create?: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedNotificationsInput = {
    create?: XOR<UserCreateWithoutReceivedNotificationsInput, UserUncheckedCreateWithoutReceivedNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutSentNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentNotificationsInput
    upsert?: UserUpsertWithoutSentNotificationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentNotificationsInput, UserUpdateWithoutSentNotificationsInput>, UserUncheckedUpdateWithoutSentNotificationsInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedNotificationsInput, UserUncheckedCreateWithoutReceivedNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedNotificationsInput
    upsert?: UserUpsertWithoutReceivedNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedNotificationsInput, UserUpdateWithoutReceivedNotificationsInput>, UserUncheckedUpdateWithoutReceivedNotificationsInput>
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    upsert?: UserUpsertWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedMessagesInput, UserUpdateWithoutReceivedMessagesInput>, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserCreateNestedOneWithoutNotificationDismissalsInput = {
    create?: XOR<UserCreateWithoutNotificationDismissalsInput, UserUncheckedCreateWithoutNotificationDismissalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationDismissalsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationDismissalsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationDismissalsInput, UserUncheckedCreateWithoutNotificationDismissalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationDismissalsInput
    upsert?: UserUpsertWithoutNotificationDismissalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationDismissalsInput, UserUpdateWithoutNotificationDismissalsInput>, UserUncheckedUpdateWithoutNotificationDismissalsInput>
  }

  export type AiPermissionCreateNestedOneWithoutAgentInput = {
    create?: XOR<AiPermissionCreateWithoutAgentInput, AiPermissionUncheckedCreateWithoutAgentInput>
    connectOrCreate?: AiPermissionCreateOrConnectWithoutAgentInput
    connect?: AiPermissionWhereUniqueInput
  }

  export type AiActionCreateNestedManyWithoutAgentInput = {
    create?: XOR<AiActionCreateWithoutAgentInput, AiActionUncheckedCreateWithoutAgentInput> | AiActionCreateWithoutAgentInput[] | AiActionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AiActionCreateOrConnectWithoutAgentInput | AiActionCreateOrConnectWithoutAgentInput[]
    createMany?: AiActionCreateManyAgentInputEnvelope
    connect?: AiActionWhereUniqueInput | AiActionWhereUniqueInput[]
  }

  export type AiTrainingDataCreateNestedManyWithoutAgentInput = {
    create?: XOR<AiTrainingDataCreateWithoutAgentInput, AiTrainingDataUncheckedCreateWithoutAgentInput> | AiTrainingDataCreateWithoutAgentInput[] | AiTrainingDataUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AiTrainingDataCreateOrConnectWithoutAgentInput | AiTrainingDataCreateOrConnectWithoutAgentInput[]
    createMany?: AiTrainingDataCreateManyAgentInputEnvelope
    connect?: AiTrainingDataWhereUniqueInput | AiTrainingDataWhereUniqueInput[]
  }

  export type AiPermissionUncheckedCreateNestedOneWithoutAgentInput = {
    create?: XOR<AiPermissionCreateWithoutAgentInput, AiPermissionUncheckedCreateWithoutAgentInput>
    connectOrCreate?: AiPermissionCreateOrConnectWithoutAgentInput
    connect?: AiPermissionWhereUniqueInput
  }

  export type AiActionUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<AiActionCreateWithoutAgentInput, AiActionUncheckedCreateWithoutAgentInput> | AiActionCreateWithoutAgentInput[] | AiActionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AiActionCreateOrConnectWithoutAgentInput | AiActionCreateOrConnectWithoutAgentInput[]
    createMany?: AiActionCreateManyAgentInputEnvelope
    connect?: AiActionWhereUniqueInput | AiActionWhereUniqueInput[]
  }

  export type AiTrainingDataUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<AiTrainingDataCreateWithoutAgentInput, AiTrainingDataUncheckedCreateWithoutAgentInput> | AiTrainingDataCreateWithoutAgentInput[] | AiTrainingDataUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AiTrainingDataCreateOrConnectWithoutAgentInput | AiTrainingDataCreateOrConnectWithoutAgentInput[]
    createMany?: AiTrainingDataCreateManyAgentInputEnvelope
    connect?: AiTrainingDataWhereUniqueInput | AiTrainingDataWhereUniqueInput[]
  }

  export type EnumAiAgentSystemNameFieldUpdateOperationsInput = {
    set?: $Enums.AiAgentSystemName
  }

  export type AiPermissionUpdateOneWithoutAgentNestedInput = {
    create?: XOR<AiPermissionCreateWithoutAgentInput, AiPermissionUncheckedCreateWithoutAgentInput>
    connectOrCreate?: AiPermissionCreateOrConnectWithoutAgentInput
    upsert?: AiPermissionUpsertWithoutAgentInput
    disconnect?: AiPermissionWhereInput | boolean
    delete?: AiPermissionWhereInput | boolean
    connect?: AiPermissionWhereUniqueInput
    update?: XOR<XOR<AiPermissionUpdateToOneWithWhereWithoutAgentInput, AiPermissionUpdateWithoutAgentInput>, AiPermissionUncheckedUpdateWithoutAgentInput>
  }

  export type AiActionUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AiActionCreateWithoutAgentInput, AiActionUncheckedCreateWithoutAgentInput> | AiActionCreateWithoutAgentInput[] | AiActionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AiActionCreateOrConnectWithoutAgentInput | AiActionCreateOrConnectWithoutAgentInput[]
    upsert?: AiActionUpsertWithWhereUniqueWithoutAgentInput | AiActionUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AiActionCreateManyAgentInputEnvelope
    set?: AiActionWhereUniqueInput | AiActionWhereUniqueInput[]
    disconnect?: AiActionWhereUniqueInput | AiActionWhereUniqueInput[]
    delete?: AiActionWhereUniqueInput | AiActionWhereUniqueInput[]
    connect?: AiActionWhereUniqueInput | AiActionWhereUniqueInput[]
    update?: AiActionUpdateWithWhereUniqueWithoutAgentInput | AiActionUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AiActionUpdateManyWithWhereWithoutAgentInput | AiActionUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AiActionScalarWhereInput | AiActionScalarWhereInput[]
  }

  export type AiTrainingDataUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AiTrainingDataCreateWithoutAgentInput, AiTrainingDataUncheckedCreateWithoutAgentInput> | AiTrainingDataCreateWithoutAgentInput[] | AiTrainingDataUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AiTrainingDataCreateOrConnectWithoutAgentInput | AiTrainingDataCreateOrConnectWithoutAgentInput[]
    upsert?: AiTrainingDataUpsertWithWhereUniqueWithoutAgentInput | AiTrainingDataUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AiTrainingDataCreateManyAgentInputEnvelope
    set?: AiTrainingDataWhereUniqueInput | AiTrainingDataWhereUniqueInput[]
    disconnect?: AiTrainingDataWhereUniqueInput | AiTrainingDataWhereUniqueInput[]
    delete?: AiTrainingDataWhereUniqueInput | AiTrainingDataWhereUniqueInput[]
    connect?: AiTrainingDataWhereUniqueInput | AiTrainingDataWhereUniqueInput[]
    update?: AiTrainingDataUpdateWithWhereUniqueWithoutAgentInput | AiTrainingDataUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AiTrainingDataUpdateManyWithWhereWithoutAgentInput | AiTrainingDataUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AiTrainingDataScalarWhereInput | AiTrainingDataScalarWhereInput[]
  }

  export type AiPermissionUncheckedUpdateOneWithoutAgentNestedInput = {
    create?: XOR<AiPermissionCreateWithoutAgentInput, AiPermissionUncheckedCreateWithoutAgentInput>
    connectOrCreate?: AiPermissionCreateOrConnectWithoutAgentInput
    upsert?: AiPermissionUpsertWithoutAgentInput
    disconnect?: AiPermissionWhereInput | boolean
    delete?: AiPermissionWhereInput | boolean
    connect?: AiPermissionWhereUniqueInput
    update?: XOR<XOR<AiPermissionUpdateToOneWithWhereWithoutAgentInput, AiPermissionUpdateWithoutAgentInput>, AiPermissionUncheckedUpdateWithoutAgentInput>
  }

  export type AiActionUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AiActionCreateWithoutAgentInput, AiActionUncheckedCreateWithoutAgentInput> | AiActionCreateWithoutAgentInput[] | AiActionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AiActionCreateOrConnectWithoutAgentInput | AiActionCreateOrConnectWithoutAgentInput[]
    upsert?: AiActionUpsertWithWhereUniqueWithoutAgentInput | AiActionUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AiActionCreateManyAgentInputEnvelope
    set?: AiActionWhereUniqueInput | AiActionWhereUniqueInput[]
    disconnect?: AiActionWhereUniqueInput | AiActionWhereUniqueInput[]
    delete?: AiActionWhereUniqueInput | AiActionWhereUniqueInput[]
    connect?: AiActionWhereUniqueInput | AiActionWhereUniqueInput[]
    update?: AiActionUpdateWithWhereUniqueWithoutAgentInput | AiActionUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AiActionUpdateManyWithWhereWithoutAgentInput | AiActionUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AiActionScalarWhereInput | AiActionScalarWhereInput[]
  }

  export type AiTrainingDataUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AiTrainingDataCreateWithoutAgentInput, AiTrainingDataUncheckedCreateWithoutAgentInput> | AiTrainingDataCreateWithoutAgentInput[] | AiTrainingDataUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AiTrainingDataCreateOrConnectWithoutAgentInput | AiTrainingDataCreateOrConnectWithoutAgentInput[]
    upsert?: AiTrainingDataUpsertWithWhereUniqueWithoutAgentInput | AiTrainingDataUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AiTrainingDataCreateManyAgentInputEnvelope
    set?: AiTrainingDataWhereUniqueInput | AiTrainingDataWhereUniqueInput[]
    disconnect?: AiTrainingDataWhereUniqueInput | AiTrainingDataWhereUniqueInput[]
    delete?: AiTrainingDataWhereUniqueInput | AiTrainingDataWhereUniqueInput[]
    connect?: AiTrainingDataWhereUniqueInput | AiTrainingDataWhereUniqueInput[]
    update?: AiTrainingDataUpdateWithWhereUniqueWithoutAgentInput | AiTrainingDataUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AiTrainingDataUpdateManyWithWhereWithoutAgentInput | AiTrainingDataUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AiTrainingDataScalarWhereInput | AiTrainingDataScalarWhereInput[]
  }

  export type AiAgentCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<AiAgentCreateWithoutPermissionsInput, AiAgentUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: AiAgentCreateOrConnectWithoutPermissionsInput
    connect?: AiAgentWhereUniqueInput
  }

  export type AiAgentUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<AiAgentCreateWithoutPermissionsInput, AiAgentUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: AiAgentCreateOrConnectWithoutPermissionsInput
    upsert?: AiAgentUpsertWithoutPermissionsInput
    connect?: AiAgentWhereUniqueInput
    update?: XOR<XOR<AiAgentUpdateToOneWithWhereWithoutPermissionsInput, AiAgentUpdateWithoutPermissionsInput>, AiAgentUncheckedUpdateWithoutPermissionsInput>
  }

  export type AiAgentCreateNestedOneWithoutActionsInput = {
    create?: XOR<AiAgentCreateWithoutActionsInput, AiAgentUncheckedCreateWithoutActionsInput>
    connectOrCreate?: AiAgentCreateOrConnectWithoutActionsInput
    connect?: AiAgentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAiActionApprovalsInput = {
    create?: XOR<UserCreateWithoutAiActionApprovalsInput, UserUncheckedCreateWithoutAiActionApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiActionApprovalsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAiActionStatusFieldUpdateOperationsInput = {
    set?: $Enums.AiActionStatus
  }

  export type AiAgentUpdateOneRequiredWithoutActionsNestedInput = {
    create?: XOR<AiAgentCreateWithoutActionsInput, AiAgentUncheckedCreateWithoutActionsInput>
    connectOrCreate?: AiAgentCreateOrConnectWithoutActionsInput
    upsert?: AiAgentUpsertWithoutActionsInput
    connect?: AiAgentWhereUniqueInput
    update?: XOR<XOR<AiAgentUpdateToOneWithWhereWithoutActionsInput, AiAgentUpdateWithoutActionsInput>, AiAgentUncheckedUpdateWithoutActionsInput>
  }

  export type UserUpdateOneWithoutAiActionApprovalsNestedInput = {
    create?: XOR<UserCreateWithoutAiActionApprovalsInput, UserUncheckedCreateWithoutAiActionApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiActionApprovalsInput
    upsert?: UserUpsertWithoutAiActionApprovalsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAiActionApprovalsInput, UserUpdateWithoutAiActionApprovalsInput>, UserUncheckedUpdateWithoutAiActionApprovalsInput>
  }

  export type AiAgentCreateNestedOneWithoutTrainingDataInput = {
    create?: XOR<AiAgentCreateWithoutTrainingDataInput, AiAgentUncheckedCreateWithoutTrainingDataInput>
    connectOrCreate?: AiAgentCreateOrConnectWithoutTrainingDataInput
    connect?: AiAgentWhereUniqueInput
  }

  export type AiAgentUpdateOneRequiredWithoutTrainingDataNestedInput = {
    create?: XOR<AiAgentCreateWithoutTrainingDataInput, AiAgentUncheckedCreateWithoutTrainingDataInput>
    connectOrCreate?: AiAgentCreateOrConnectWithoutTrainingDataInput
    upsert?: AiAgentUpsertWithoutTrainingDataInput
    connect?: AiAgentWhereUniqueInput
    update?: XOR<XOR<AiAgentUpdateToOneWithWhereWithoutTrainingDataInput, AiAgentUpdateWithoutTrainingDataInput>, AiAgentUncheckedUpdateWithoutTrainingDataInput>
  }

  export type DeliveryCreateNestedManyWithoutVehicleInput = {
    create?: XOR<DeliveryCreateWithoutVehicleInput, DeliveryUncheckedCreateWithoutVehicleInput> | DeliveryCreateWithoutVehicleInput[] | DeliveryUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutVehicleInput | DeliveryCreateOrConnectWithoutVehicleInput[]
    createMany?: DeliveryCreateManyVehicleInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type DeliveryUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<DeliveryCreateWithoutVehicleInput, DeliveryUncheckedCreateWithoutVehicleInput> | DeliveryCreateWithoutVehicleInput[] | DeliveryUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutVehicleInput | DeliveryCreateOrConnectWithoutVehicleInput[]
    createMany?: DeliveryCreateManyVehicleInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type EnumVehicleTypeFieldUpdateOperationsInput = {
    set?: $Enums.VehicleType
  }

  export type EnumVehicleStatusFieldUpdateOperationsInput = {
    set?: $Enums.VehicleStatus
  }

  export type DeliveryUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<DeliveryCreateWithoutVehicleInput, DeliveryUncheckedCreateWithoutVehicleInput> | DeliveryCreateWithoutVehicleInput[] | DeliveryUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutVehicleInput | DeliveryCreateOrConnectWithoutVehicleInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutVehicleInput | DeliveryUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: DeliveryCreateManyVehicleInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutVehicleInput | DeliveryUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutVehicleInput | DeliveryUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type DeliveryUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<DeliveryCreateWithoutVehicleInput, DeliveryUncheckedCreateWithoutVehicleInput> | DeliveryCreateWithoutVehicleInput[] | DeliveryUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutVehicleInput | DeliveryCreateOrConnectWithoutVehicleInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutVehicleInput | DeliveryUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: DeliveryCreateManyVehicleInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutVehicleInput | DeliveryUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutVehicleInput | DeliveryUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<InvoiceCreateWithoutDeliveriesInput, InvoiceUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutDeliveriesInput
    connect?: InvoiceWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<VehicleCreateWithoutDeliveriesInput, VehicleUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutDeliveriesInput
    connect?: VehicleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClaimedDeliveriesInput = {
    create?: XOR<UserCreateWithoutClaimedDeliveriesInput, UserUncheckedCreateWithoutClaimedDeliveriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutClaimedDeliveriesInput
    connect?: UserWhereUniqueInput
  }

  export type DeliveryItemCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<DeliveryItemCreateWithoutDeliveryInput, DeliveryItemUncheckedCreateWithoutDeliveryInput> | DeliveryItemCreateWithoutDeliveryInput[] | DeliveryItemUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: DeliveryItemCreateOrConnectWithoutDeliveryInput | DeliveryItemCreateOrConnectWithoutDeliveryInput[]
    createMany?: DeliveryItemCreateManyDeliveryInputEnvelope
    connect?: DeliveryItemWhereUniqueInput | DeliveryItemWhereUniqueInput[]
  }

  export type DeliveryLogCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<DeliveryLogCreateWithoutDeliveryInput, DeliveryLogUncheckedCreateWithoutDeliveryInput> | DeliveryLogCreateWithoutDeliveryInput[] | DeliveryLogUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: DeliveryLogCreateOrConnectWithoutDeliveryInput | DeliveryLogCreateOrConnectWithoutDeliveryInput[]
    createMany?: DeliveryLogCreateManyDeliveryInputEnvelope
    connect?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
  }

  export type DeliveryEditLogCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<DeliveryEditLogCreateWithoutDeliveryInput, DeliveryEditLogUncheckedCreateWithoutDeliveryInput> | DeliveryEditLogCreateWithoutDeliveryInput[] | DeliveryEditLogUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: DeliveryEditLogCreateOrConnectWithoutDeliveryInput | DeliveryEditLogCreateOrConnectWithoutDeliveryInput[]
    createMany?: DeliveryEditLogCreateManyDeliveryInputEnvelope
    connect?: DeliveryEditLogWhereUniqueInput | DeliveryEditLogWhereUniqueInput[]
  }

  export type DeliveryItemUncheckedCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<DeliveryItemCreateWithoutDeliveryInput, DeliveryItemUncheckedCreateWithoutDeliveryInput> | DeliveryItemCreateWithoutDeliveryInput[] | DeliveryItemUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: DeliveryItemCreateOrConnectWithoutDeliveryInput | DeliveryItemCreateOrConnectWithoutDeliveryInput[]
    createMany?: DeliveryItemCreateManyDeliveryInputEnvelope
    connect?: DeliveryItemWhereUniqueInput | DeliveryItemWhereUniqueInput[]
  }

  export type DeliveryLogUncheckedCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<DeliveryLogCreateWithoutDeliveryInput, DeliveryLogUncheckedCreateWithoutDeliveryInput> | DeliveryLogCreateWithoutDeliveryInput[] | DeliveryLogUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: DeliveryLogCreateOrConnectWithoutDeliveryInput | DeliveryLogCreateOrConnectWithoutDeliveryInput[]
    createMany?: DeliveryLogCreateManyDeliveryInputEnvelope
    connect?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
  }

  export type DeliveryEditLogUncheckedCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<DeliveryEditLogCreateWithoutDeliveryInput, DeliveryEditLogUncheckedCreateWithoutDeliveryInput> | DeliveryEditLogCreateWithoutDeliveryInput[] | DeliveryEditLogUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: DeliveryEditLogCreateOrConnectWithoutDeliveryInput | DeliveryEditLogCreateOrConnectWithoutDeliveryInput[]
    createMany?: DeliveryEditLogCreateManyDeliveryInputEnvelope
    connect?: DeliveryEditLogWhereUniqueInput | DeliveryEditLogWhereUniqueInput[]
  }

  export type EnumDeliveryMethodFieldUpdateOperationsInput = {
    set?: $Enums.DeliveryMethod
  }

  export type EnumDeliveryTypeFieldUpdateOperationsInput = {
    set?: $Enums.DeliveryType
  }

  export type EnumDeliveryStatusFieldUpdateOperationsInput = {
    set?: $Enums.DeliveryStatus
  }

  export type InvoiceUpdateOneWithoutDeliveriesNestedInput = {
    create?: XOR<InvoiceCreateWithoutDeliveriesInput, InvoiceUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutDeliveriesInput
    upsert?: InvoiceUpsertWithoutDeliveriesInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutDeliveriesInput, InvoiceUpdateWithoutDeliveriesInput>, InvoiceUncheckedUpdateWithoutDeliveriesInput>
  }

  export type VehicleUpdateOneWithoutDeliveriesNestedInput = {
    create?: XOR<VehicleCreateWithoutDeliveriesInput, VehicleUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutDeliveriesInput
    upsert?: VehicleUpsertWithoutDeliveriesInput
    disconnect?: VehicleWhereInput | boolean
    delete?: VehicleWhereInput | boolean
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutDeliveriesInput, VehicleUpdateWithoutDeliveriesInput>, VehicleUncheckedUpdateWithoutDeliveriesInput>
  }

  export type UserUpdateOneWithoutClaimedDeliveriesNestedInput = {
    create?: XOR<UserCreateWithoutClaimedDeliveriesInput, UserUncheckedCreateWithoutClaimedDeliveriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutClaimedDeliveriesInput
    upsert?: UserUpsertWithoutClaimedDeliveriesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClaimedDeliveriesInput, UserUpdateWithoutClaimedDeliveriesInput>, UserUncheckedUpdateWithoutClaimedDeliveriesInput>
  }

  export type DeliveryItemUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<DeliveryItemCreateWithoutDeliveryInput, DeliveryItemUncheckedCreateWithoutDeliveryInput> | DeliveryItemCreateWithoutDeliveryInput[] | DeliveryItemUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: DeliveryItemCreateOrConnectWithoutDeliveryInput | DeliveryItemCreateOrConnectWithoutDeliveryInput[]
    upsert?: DeliveryItemUpsertWithWhereUniqueWithoutDeliveryInput | DeliveryItemUpsertWithWhereUniqueWithoutDeliveryInput[]
    createMany?: DeliveryItemCreateManyDeliveryInputEnvelope
    set?: DeliveryItemWhereUniqueInput | DeliveryItemWhereUniqueInput[]
    disconnect?: DeliveryItemWhereUniqueInput | DeliveryItemWhereUniqueInput[]
    delete?: DeliveryItemWhereUniqueInput | DeliveryItemWhereUniqueInput[]
    connect?: DeliveryItemWhereUniqueInput | DeliveryItemWhereUniqueInput[]
    update?: DeliveryItemUpdateWithWhereUniqueWithoutDeliveryInput | DeliveryItemUpdateWithWhereUniqueWithoutDeliveryInput[]
    updateMany?: DeliveryItemUpdateManyWithWhereWithoutDeliveryInput | DeliveryItemUpdateManyWithWhereWithoutDeliveryInput[]
    deleteMany?: DeliveryItemScalarWhereInput | DeliveryItemScalarWhereInput[]
  }

  export type DeliveryLogUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<DeliveryLogCreateWithoutDeliveryInput, DeliveryLogUncheckedCreateWithoutDeliveryInput> | DeliveryLogCreateWithoutDeliveryInput[] | DeliveryLogUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: DeliveryLogCreateOrConnectWithoutDeliveryInput | DeliveryLogCreateOrConnectWithoutDeliveryInput[]
    upsert?: DeliveryLogUpsertWithWhereUniqueWithoutDeliveryInput | DeliveryLogUpsertWithWhereUniqueWithoutDeliveryInput[]
    createMany?: DeliveryLogCreateManyDeliveryInputEnvelope
    set?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
    disconnect?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
    delete?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
    connect?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
    update?: DeliveryLogUpdateWithWhereUniqueWithoutDeliveryInput | DeliveryLogUpdateWithWhereUniqueWithoutDeliveryInput[]
    updateMany?: DeliveryLogUpdateManyWithWhereWithoutDeliveryInput | DeliveryLogUpdateManyWithWhereWithoutDeliveryInput[]
    deleteMany?: DeliveryLogScalarWhereInput | DeliveryLogScalarWhereInput[]
  }

  export type DeliveryEditLogUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<DeliveryEditLogCreateWithoutDeliveryInput, DeliveryEditLogUncheckedCreateWithoutDeliveryInput> | DeliveryEditLogCreateWithoutDeliveryInput[] | DeliveryEditLogUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: DeliveryEditLogCreateOrConnectWithoutDeliveryInput | DeliveryEditLogCreateOrConnectWithoutDeliveryInput[]
    upsert?: DeliveryEditLogUpsertWithWhereUniqueWithoutDeliveryInput | DeliveryEditLogUpsertWithWhereUniqueWithoutDeliveryInput[]
    createMany?: DeliveryEditLogCreateManyDeliveryInputEnvelope
    set?: DeliveryEditLogWhereUniqueInput | DeliveryEditLogWhereUniqueInput[]
    disconnect?: DeliveryEditLogWhereUniqueInput | DeliveryEditLogWhereUniqueInput[]
    delete?: DeliveryEditLogWhereUniqueInput | DeliveryEditLogWhereUniqueInput[]
    connect?: DeliveryEditLogWhereUniqueInput | DeliveryEditLogWhereUniqueInput[]
    update?: DeliveryEditLogUpdateWithWhereUniqueWithoutDeliveryInput | DeliveryEditLogUpdateWithWhereUniqueWithoutDeliveryInput[]
    updateMany?: DeliveryEditLogUpdateManyWithWhereWithoutDeliveryInput | DeliveryEditLogUpdateManyWithWhereWithoutDeliveryInput[]
    deleteMany?: DeliveryEditLogScalarWhereInput | DeliveryEditLogScalarWhereInput[]
  }

  export type DeliveryItemUncheckedUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<DeliveryItemCreateWithoutDeliveryInput, DeliveryItemUncheckedCreateWithoutDeliveryInput> | DeliveryItemCreateWithoutDeliveryInput[] | DeliveryItemUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: DeliveryItemCreateOrConnectWithoutDeliveryInput | DeliveryItemCreateOrConnectWithoutDeliveryInput[]
    upsert?: DeliveryItemUpsertWithWhereUniqueWithoutDeliveryInput | DeliveryItemUpsertWithWhereUniqueWithoutDeliveryInput[]
    createMany?: DeliveryItemCreateManyDeliveryInputEnvelope
    set?: DeliveryItemWhereUniqueInput | DeliveryItemWhereUniqueInput[]
    disconnect?: DeliveryItemWhereUniqueInput | DeliveryItemWhereUniqueInput[]
    delete?: DeliveryItemWhereUniqueInput | DeliveryItemWhereUniqueInput[]
    connect?: DeliveryItemWhereUniqueInput | DeliveryItemWhereUniqueInput[]
    update?: DeliveryItemUpdateWithWhereUniqueWithoutDeliveryInput | DeliveryItemUpdateWithWhereUniqueWithoutDeliveryInput[]
    updateMany?: DeliveryItemUpdateManyWithWhereWithoutDeliveryInput | DeliveryItemUpdateManyWithWhereWithoutDeliveryInput[]
    deleteMany?: DeliveryItemScalarWhereInput | DeliveryItemScalarWhereInput[]
  }

  export type DeliveryLogUncheckedUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<DeliveryLogCreateWithoutDeliveryInput, DeliveryLogUncheckedCreateWithoutDeliveryInput> | DeliveryLogCreateWithoutDeliveryInput[] | DeliveryLogUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: DeliveryLogCreateOrConnectWithoutDeliveryInput | DeliveryLogCreateOrConnectWithoutDeliveryInput[]
    upsert?: DeliveryLogUpsertWithWhereUniqueWithoutDeliveryInput | DeliveryLogUpsertWithWhereUniqueWithoutDeliveryInput[]
    createMany?: DeliveryLogCreateManyDeliveryInputEnvelope
    set?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
    disconnect?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
    delete?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
    connect?: DeliveryLogWhereUniqueInput | DeliveryLogWhereUniqueInput[]
    update?: DeliveryLogUpdateWithWhereUniqueWithoutDeliveryInput | DeliveryLogUpdateWithWhereUniqueWithoutDeliveryInput[]
    updateMany?: DeliveryLogUpdateManyWithWhereWithoutDeliveryInput | DeliveryLogUpdateManyWithWhereWithoutDeliveryInput[]
    deleteMany?: DeliveryLogScalarWhereInput | DeliveryLogScalarWhereInput[]
  }

  export type DeliveryEditLogUncheckedUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<DeliveryEditLogCreateWithoutDeliveryInput, DeliveryEditLogUncheckedCreateWithoutDeliveryInput> | DeliveryEditLogCreateWithoutDeliveryInput[] | DeliveryEditLogUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: DeliveryEditLogCreateOrConnectWithoutDeliveryInput | DeliveryEditLogCreateOrConnectWithoutDeliveryInput[]
    upsert?: DeliveryEditLogUpsertWithWhereUniqueWithoutDeliveryInput | DeliveryEditLogUpsertWithWhereUniqueWithoutDeliveryInput[]
    createMany?: DeliveryEditLogCreateManyDeliveryInputEnvelope
    set?: DeliveryEditLogWhereUniqueInput | DeliveryEditLogWhereUniqueInput[]
    disconnect?: DeliveryEditLogWhereUniqueInput | DeliveryEditLogWhereUniqueInput[]
    delete?: DeliveryEditLogWhereUniqueInput | DeliveryEditLogWhereUniqueInput[]
    connect?: DeliveryEditLogWhereUniqueInput | DeliveryEditLogWhereUniqueInput[]
    update?: DeliveryEditLogUpdateWithWhereUniqueWithoutDeliveryInput | DeliveryEditLogUpdateWithWhereUniqueWithoutDeliveryInput[]
    updateMany?: DeliveryEditLogUpdateManyWithWhereWithoutDeliveryInput | DeliveryEditLogUpdateManyWithWhereWithoutDeliveryInput[]
    deleteMany?: DeliveryEditLogScalarWhereInput | DeliveryEditLogScalarWhereInput[]
  }

  export type DeliveryCreateNestedOneWithoutItemsInput = {
    create?: XOR<DeliveryCreateWithoutItemsInput, DeliveryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutItemsInput
    connect?: DeliveryWhereUniqueInput
  }

  export type RentalItemCreateNestedOneWithoutDeliveryItemsInput = {
    create?: XOR<RentalItemCreateWithoutDeliveryItemsInput, RentalItemUncheckedCreateWithoutDeliveryItemsInput>
    connectOrCreate?: RentalItemCreateOrConnectWithoutDeliveryItemsInput
    connect?: RentalItemWhereUniqueInput
  }

  export type DeliveryUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<DeliveryCreateWithoutItemsInput, DeliveryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutItemsInput
    upsert?: DeliveryUpsertWithoutItemsInput
    connect?: DeliveryWhereUniqueInput
    update?: XOR<XOR<DeliveryUpdateToOneWithWhereWithoutItemsInput, DeliveryUpdateWithoutItemsInput>, DeliveryUncheckedUpdateWithoutItemsInput>
  }

  export type RentalItemUpdateOneRequiredWithoutDeliveryItemsNestedInput = {
    create?: XOR<RentalItemCreateWithoutDeliveryItemsInput, RentalItemUncheckedCreateWithoutDeliveryItemsInput>
    connectOrCreate?: RentalItemCreateOrConnectWithoutDeliveryItemsInput
    upsert?: RentalItemUpsertWithoutDeliveryItemsInput
    connect?: RentalItemWhereUniqueInput
    update?: XOR<XOR<RentalItemUpdateToOneWithWhereWithoutDeliveryItemsInput, RentalItemUpdateWithoutDeliveryItemsInput>, RentalItemUncheckedUpdateWithoutDeliveryItemsInput>
  }

  export type DeliveryCreateNestedOneWithoutLogsInput = {
    create?: XOR<DeliveryCreateWithoutLogsInput, DeliveryUncheckedCreateWithoutLogsInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutLogsInput
    connect?: DeliveryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDeliveryLogsInput = {
    create?: XOR<UserCreateWithoutDeliveryLogsInput, UserUncheckedCreateWithoutDeliveryLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeliveryLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumDeliveryRoleFieldUpdateOperationsInput = {
    set?: $Enums.DeliveryRole
  }

  export type DeliveryUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<DeliveryCreateWithoutLogsInput, DeliveryUncheckedCreateWithoutLogsInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutLogsInput
    upsert?: DeliveryUpsertWithoutLogsInput
    connect?: DeliveryWhereUniqueInput
    update?: XOR<XOR<DeliveryUpdateToOneWithWhereWithoutLogsInput, DeliveryUpdateWithoutLogsInput>, DeliveryUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateOneWithoutDeliveryLogsNestedInput = {
    create?: XOR<UserCreateWithoutDeliveryLogsInput, UserUncheckedCreateWithoutDeliveryLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeliveryLogsInput
    upsert?: UserUpsertWithoutDeliveryLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeliveryLogsInput, UserUpdateWithoutDeliveryLogsInput>, UserUncheckedUpdateWithoutDeliveryLogsInput>
  }

  export type DeliveryCreateNestedOneWithoutEditLogsInput = {
    create?: XOR<DeliveryCreateWithoutEditLogsInput, DeliveryUncheckedCreateWithoutEditLogsInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutEditLogsInput
    connect?: DeliveryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDeliveryEditLogsInput = {
    create?: XOR<UserCreateWithoutDeliveryEditLogsInput, UserUncheckedCreateWithoutDeliveryEditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeliveryEditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type DeliveryUpdateOneRequiredWithoutEditLogsNestedInput = {
    create?: XOR<DeliveryCreateWithoutEditLogsInput, DeliveryUncheckedCreateWithoutEditLogsInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutEditLogsInput
    upsert?: DeliveryUpsertWithoutEditLogsInput
    connect?: DeliveryWhereUniqueInput
    update?: XOR<XOR<DeliveryUpdateToOneWithWhereWithoutEditLogsInput, DeliveryUpdateWithoutEditLogsInput>, DeliveryUncheckedUpdateWithoutEditLogsInput>
  }

  export type UserUpdateOneRequiredWithoutDeliveryEditLogsNestedInput = {
    create?: XOR<UserCreateWithoutDeliveryEditLogsInput, UserUncheckedCreateWithoutDeliveryEditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeliveryEditLogsInput
    upsert?: UserUpsertWithoutDeliveryEditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeliveryEditLogsInput, UserUpdateWithoutDeliveryEditLogsInput>, UserUncheckedUpdateWithoutDeliveryEditLogsInput>
  }

  export type SpecialOfferCreateimagesInput = {
    set: string[]
  }

  export type SpecialOfferUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumPaymentProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentProviderFilter<$PrismaModel> | $Enums.PaymentProvider
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedEnumPaymentProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentProviderWithAggregatesFilter<$PrismaModel> | $Enums.PaymentProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentProviderFilter<$PrismaModel>
    _max?: NestedEnumPaymentProviderFilter<$PrismaModel>
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type NestedEnumRelationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationType | EnumRelationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationType[] | ListEnumRelationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationType[] | ListEnumRelationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationTypeFilter<$PrismaModel> | $Enums.RelationType
  }

  export type NestedEnumRelationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationType | EnumRelationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationType[] | ListEnumRelationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationType[] | ListEnumRelationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationTypeWithAggregatesFilter<$PrismaModel> | $Enums.RelationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRelationTypeFilter<$PrismaModel>
    _max?: NestedEnumRelationTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumUnitStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitStatus | EnumUnitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitStatusFilter<$PrismaModel> | $Enums.UnitStatus
  }

  export type NestedEnumUnitConditionFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitCondition | EnumUnitConditionFieldRefInput<$PrismaModel>
    in?: $Enums.UnitCondition[] | ListEnumUnitConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitCondition[] | ListEnumUnitConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitConditionFilter<$PrismaModel> | $Enums.UnitCondition
  }

  export type NestedEnumUnitStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitStatus | EnumUnitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitStatus[] | ListEnumUnitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitStatusWithAggregatesFilter<$PrismaModel> | $Enums.UnitStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUnitStatusFilter<$PrismaModel>
    _max?: NestedEnumUnitStatusFilter<$PrismaModel>
  }

  export type NestedEnumUnitConditionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitCondition | EnumUnitConditionFieldRefInput<$PrismaModel>
    in?: $Enums.UnitCondition[] | ListEnumUnitConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitCondition[] | ListEnumUnitConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitConditionWithAggregatesFilter<$PrismaModel> | $Enums.UnitCondition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUnitConditionFilter<$PrismaModel>
    _max?: NestedEnumUnitConditionFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumattendance_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.attendance_status | Enumattendance_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.attendance_status[] | ListEnumattendance_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.attendance_status[] | ListEnumattendance_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumattendance_statusNullableFilter<$PrismaModel> | $Enums.attendance_status | null
  }

  export type NestedEnumattendance_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.attendance_status | Enumattendance_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.attendance_status[] | ListEnumattendance_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.attendance_status[] | ListEnumattendance_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumattendance_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.attendance_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumattendance_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumattendance_statusNullableFilter<$PrismaModel>
  }

  export type NestedEnuminventory_sourceFilter<$PrismaModel = never> = {
    equals?: $Enums.inventory_source | Enuminventory_sourceFieldRefInput<$PrismaModel>
    in?: $Enums.inventory_source[] | ListEnuminventory_sourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.inventory_source[] | ListEnuminventory_sourceFieldRefInput<$PrismaModel>
    not?: NestedEnuminventory_sourceFilter<$PrismaModel> | $Enums.inventory_source
  }

  export type NestedEnuminventory_sourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inventory_source | Enuminventory_sourceFieldRefInput<$PrismaModel>
    in?: $Enums.inventory_source[] | ListEnuminventory_sourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.inventory_source[] | ListEnuminventory_sourceFieldRefInput<$PrismaModel>
    not?: NestedEnuminventory_sourceWithAggregatesFilter<$PrismaModel> | $Enums.inventory_source
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminventory_sourceFilter<$PrismaModel>
    _max?: NestedEnuminventory_sourceFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAiAgentSystemNameFilter<$PrismaModel = never> = {
    equals?: $Enums.AiAgentSystemName | EnumAiAgentSystemNameFieldRefInput<$PrismaModel>
    in?: $Enums.AiAgentSystemName[] | ListEnumAiAgentSystemNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiAgentSystemName[] | ListEnumAiAgentSystemNameFieldRefInput<$PrismaModel>
    not?: NestedEnumAiAgentSystemNameFilter<$PrismaModel> | $Enums.AiAgentSystemName
  }

  export type NestedEnumAiAgentSystemNameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AiAgentSystemName | EnumAiAgentSystemNameFieldRefInput<$PrismaModel>
    in?: $Enums.AiAgentSystemName[] | ListEnumAiAgentSystemNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiAgentSystemName[] | ListEnumAiAgentSystemNameFieldRefInput<$PrismaModel>
    not?: NestedEnumAiAgentSystemNameWithAggregatesFilter<$PrismaModel> | $Enums.AiAgentSystemName
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAiAgentSystemNameFilter<$PrismaModel>
    _max?: NestedEnumAiAgentSystemNameFilter<$PrismaModel>
  }

  export type NestedEnumAiActionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AiActionStatus | EnumAiActionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AiActionStatus[] | ListEnumAiActionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiActionStatus[] | ListEnumAiActionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAiActionStatusFilter<$PrismaModel> | $Enums.AiActionStatus
  }

  export type NestedEnumAiActionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AiActionStatus | EnumAiActionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AiActionStatus[] | ListEnumAiActionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiActionStatus[] | ListEnumAiActionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAiActionStatusWithAggregatesFilter<$PrismaModel> | $Enums.AiActionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAiActionStatusFilter<$PrismaModel>
    _max?: NestedEnumAiActionStatusFilter<$PrismaModel>
  }

  export type NestedEnumVehicleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleType | EnumVehicleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVehicleTypeFilter<$PrismaModel> | $Enums.VehicleType
  }

  export type NestedEnumVehicleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleStatus | EnumVehicleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleStatus[] | ListEnumVehicleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VehicleStatus[] | ListEnumVehicleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVehicleStatusFilter<$PrismaModel> | $Enums.VehicleStatus
  }

  export type NestedEnumVehicleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleType | EnumVehicleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVehicleTypeWithAggregatesFilter<$PrismaModel> | $Enums.VehicleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVehicleTypeFilter<$PrismaModel>
    _max?: NestedEnumVehicleTypeFilter<$PrismaModel>
  }

  export type NestedEnumVehicleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleStatus | EnumVehicleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleStatus[] | ListEnumVehicleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VehicleStatus[] | ListEnumVehicleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVehicleStatusWithAggregatesFilter<$PrismaModel> | $Enums.VehicleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVehicleStatusFilter<$PrismaModel>
    _max?: NestedEnumVehicleStatusFilter<$PrismaModel>
  }

  export type NestedEnumDeliveryMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryMethod | EnumDeliveryMethodFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryMethod[] | ListEnumDeliveryMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryMethod[] | ListEnumDeliveryMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryMethodFilter<$PrismaModel> | $Enums.DeliveryMethod
  }

  export type NestedEnumDeliveryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryType | EnumDeliveryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryType[] | ListEnumDeliveryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryType[] | ListEnumDeliveryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryTypeFilter<$PrismaModel> | $Enums.DeliveryType
  }

  export type NestedEnumDeliveryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryStatus | EnumDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryStatusFilter<$PrismaModel> | $Enums.DeliveryStatus
  }

  export type NestedEnumDeliveryMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryMethod | EnumDeliveryMethodFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryMethod[] | ListEnumDeliveryMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryMethod[] | ListEnumDeliveryMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryMethodWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryMethodFilter<$PrismaModel>
    _max?: NestedEnumDeliveryMethodFilter<$PrismaModel>
  }

  export type NestedEnumDeliveryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryType | EnumDeliveryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryType[] | ListEnumDeliveryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryType[] | ListEnumDeliveryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryTypeWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryTypeFilter<$PrismaModel>
    _max?: NestedEnumDeliveryTypeFilter<$PrismaModel>
  }

  export type NestedEnumDeliveryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryStatus | EnumDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryStatusFilter<$PrismaModel>
    _max?: NestedEnumDeliveryStatusFilter<$PrismaModel>
  }

  export type NestedEnumDeliveryRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryRole | EnumDeliveryRoleFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryRole[] | ListEnumDeliveryRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryRole[] | ListEnumDeliveryRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryRoleFilter<$PrismaModel> | $Enums.DeliveryRole
  }

  export type NestedEnumDeliveryRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryRole | EnumDeliveryRoleFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryRole[] | ListEnumDeliveryRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryRole[] | ListEnumDeliveryRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryRoleWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryRoleFilter<$PrismaModel>
    _max?: NestedEnumDeliveryRoleFilter<$PrismaModel>
  }

  export type OrderCreateWithoutInvoicesInput = {
    id?: string
    orderNumber: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    totalAmount: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    paymentMethod?: string | null
    createdAt?: Date | string | null
    paymentStatus?: string | null
    paymentConfirmedAt?: Date | string | null
    deliveryAddress?: string | null
    assignedUnits?: ProductUnitCreateNestedManyWithoutAssignedOrderInput
    users_orders_payment_confirmed_byTousers?: UserCreateNestedOneWithoutOrders_orders_payment_confirmed_byTousersInput
    user: UserCreateNestedOneWithoutOrdersInput
    rentalItems?: RentalItemCreateNestedManyWithoutOrderInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutInvoicesInput = {
    id?: string
    orderNumber: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    totalAmount: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    paymentMethod?: string | null
    createdAt?: Date | string | null
    userId: string
    paymentStatus?: string | null
    paymentConfirmedBy?: string | null
    paymentConfirmedAt?: Date | string | null
    deliveryAddress?: string | null
    assignedUnits?: ProductUnitUncheckedCreateNestedManyWithoutAssignedOrderInput
    rentalItems?: RentalItemUncheckedCreateNestedManyWithoutOrderInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutInvoicesInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutInvoicesInput, OrderUncheckedCreateWithoutInvoicesInput>
  }

  export type DeliveryCreateWithoutInvoiceInput = {
    id?: string
    deliveryMethod: $Enums.DeliveryMethod
    deliveryType: $Enums.DeliveryType
    status?: $Enums.DeliveryStatus
    claimedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    eta?: Date | string | null
    etaOverrideCount?: number
    delayMinutes?: number
    latitude?: number | null
    longitude?: number | null
    lastLocationUpdate?: Date | string | null
    trackingCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle?: VehicleCreateNestedOneWithoutDeliveriesInput
    claimedByWorker?: UserCreateNestedOneWithoutClaimedDeliveriesInput
    items?: DeliveryItemCreateNestedManyWithoutDeliveryInput
    logs?: DeliveryLogCreateNestedManyWithoutDeliveryInput
    editLogs?: DeliveryEditLogCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateWithoutInvoiceInput = {
    id?: string
    deliveryMethod: $Enums.DeliveryMethod
    deliveryType: $Enums.DeliveryType
    vehicleId?: string | null
    status?: $Enums.DeliveryStatus
    claimedByWorkerId?: string | null
    claimedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    eta?: Date | string | null
    etaOverrideCount?: number
    delayMinutes?: number
    latitude?: number | null
    longitude?: number | null
    lastLocationUpdate?: Date | string | null
    trackingCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: DeliveryItemUncheckedCreateNestedManyWithoutDeliveryInput
    logs?: DeliveryLogUncheckedCreateNestedManyWithoutDeliveryInput
    editLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryCreateOrConnectWithoutInvoiceInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutInvoiceInput, DeliveryUncheckedCreateWithoutInvoiceInput>
  }

  export type DeliveryCreateManyInvoiceInputEnvelope = {
    data: DeliveryCreateManyInvoiceInput | DeliveryCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutInvoicesInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogCreateNestedManyWithoutUpdatedByUserInput
    orders_orders_payment_confirmed_byTousers?: OrderCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutInvoicesInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogUncheckedCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogUncheckedCreateNestedManyWithoutUpdatedByUserInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceUncheckedCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryUncheckedCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageUncheckedCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalUncheckedCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryUncheckedCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutInvoicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
  }

  export type OrderUpsertWithoutInvoicesInput = {
    update: XOR<OrderUpdateWithoutInvoicesInput, OrderUncheckedUpdateWithoutInvoicesInput>
    create: XOR<OrderCreateWithoutInvoicesInput, OrderUncheckedCreateWithoutInvoicesInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutInvoicesInput, OrderUncheckedUpdateWithoutInvoicesInput>
  }

  export type OrderUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnits?: ProductUnitUpdateManyWithoutAssignedOrderNestedInput
    users_orders_payment_confirmed_byTousers?: UserUpdateOneWithoutOrders_orders_payment_confirmed_byTousersNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    rentalItems?: RentalItemUpdateManyWithoutOrderNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUnits?: ProductUnitUncheckedUpdateManyWithoutAssignedOrderNestedInput
    rentalItems?: RentalItemUncheckedUpdateManyWithoutOrderNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type DeliveryUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: DeliveryWhereUniqueInput
    update: XOR<DeliveryUpdateWithoutInvoiceInput, DeliveryUncheckedUpdateWithoutInvoiceInput>
    create: XOR<DeliveryCreateWithoutInvoiceInput, DeliveryUncheckedCreateWithoutInvoiceInput>
  }

  export type DeliveryUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: DeliveryWhereUniqueInput
    data: XOR<DeliveryUpdateWithoutInvoiceInput, DeliveryUncheckedUpdateWithoutInvoiceInput>
  }

  export type DeliveryUpdateManyWithWhereWithoutInvoiceInput = {
    where: DeliveryScalarWhereInput
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type DeliveryScalarWhereInput = {
    AND?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
    OR?: DeliveryScalarWhereInput[]
    NOT?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
    id?: UuidFilter<"Delivery"> | string
    invoiceId?: UuidNullableFilter<"Delivery"> | string | null
    deliveryMethod?: EnumDeliveryMethodFilter<"Delivery"> | $Enums.DeliveryMethod
    deliveryType?: EnumDeliveryTypeFilter<"Delivery"> | $Enums.DeliveryType
    vehicleId?: UuidNullableFilter<"Delivery"> | string | null
    status?: EnumDeliveryStatusFilter<"Delivery"> | $Enums.DeliveryStatus
    claimedByWorkerId?: UuidNullableFilter<"Delivery"> | string | null
    claimedAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    eta?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    etaOverrideCount?: IntFilter<"Delivery"> | number
    delayMinutes?: IntFilter<"Delivery"> | number
    latitude?: FloatNullableFilter<"Delivery"> | number | null
    longitude?: FloatNullableFilter<"Delivery"> | number | null
    lastLocationUpdate?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    trackingCode?: StringNullableFilter<"Delivery"> | string | null
    createdAt?: DateTimeFilter<"Delivery"> | Date | string
    updatedAt?: DateTimeFilter<"Delivery"> | Date | string
  }

  export type UserUpsertWithoutInvoicesInput = {
    update: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUpdateManyWithoutUpdatedByUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUncheckedUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUncheckedUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUncheckedUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUncheckedUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUncheckedUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUncheckedUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUncheckedUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUncheckedUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type InvoiceCreateWithoutOrderInput = {
    id?: string
    invoiceNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string | null
    createdAt?: Date | string | null
    status?: string
    guestEmail?: string | null
    guestName?: string | null
    guestWhatsapp?: string | null
    guestAddress?: string | null
    deliveryFeeOverride?: Decimal | DecimalJsLike | number | string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    shareableToken?: string | null
    emailSent?: boolean | null
    emailSentAt?: Date | string | null
    deliveries?: DeliveryCreateNestedManyWithoutInvoiceInput
    user?: UserCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutOrderInput = {
    id?: string
    invoiceNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string | null
    createdAt?: Date | string | null
    userId?: string | null
    status?: string
    guestEmail?: string | null
    guestName?: string | null
    guestWhatsapp?: string | null
    guestAddress?: string | null
    deliveryFeeOverride?: Decimal | DecimalJsLike | number | string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    shareableToken?: string | null
    emailSent?: boolean | null
    emailSentAt?: Date | string | null
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutOrderInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
  }

  export type InvoiceCreateManyOrderInputEnvelope = {
    data: InvoiceCreateManyOrderInput | InvoiceCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type ProductUnitCreateWithoutAssignedOrderInput = {
    id?: string
    serialNumber: string
    status?: $Enums.UnitStatus
    condition?: $Enums.UnitCondition
    purchaseDate?: Date | string | null
    lastServiceDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variant: ProductVariantCreateNestedOneWithoutUnitsInput
    rentalItems?: RentalItemCreateNestedManyWithoutUnitInput
    history?: UnitHistoryCreateNestedManyWithoutUnitInput
  }

  export type ProductUnitUncheckedCreateWithoutAssignedOrderInput = {
    id?: string
    variantId: string
    serialNumber: string
    status?: $Enums.UnitStatus
    condition?: $Enums.UnitCondition
    purchaseDate?: Date | string | null
    lastServiceDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rentalItems?: RentalItemUncheckedCreateNestedManyWithoutUnitInput
    history?: UnitHistoryUncheckedCreateNestedManyWithoutUnitInput
  }

  export type ProductUnitCreateOrConnectWithoutAssignedOrderInput = {
    where: ProductUnitWhereUniqueInput
    create: XOR<ProductUnitCreateWithoutAssignedOrderInput, ProductUnitUncheckedCreateWithoutAssignedOrderInput>
  }

  export type ProductUnitCreateManyAssignedOrderInputEnvelope = {
    data: ProductUnitCreateManyAssignedOrderInput | ProductUnitCreateManyAssignedOrderInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutOrders_orders_payment_confirmed_byTousersInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutOrders_orders_payment_confirmed_byTousersInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogUncheckedCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogUncheckedCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceUncheckedCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryUncheckedCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageUncheckedCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalUncheckedCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryUncheckedCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutOrders_orders_payment_confirmed_byTousersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrders_orders_payment_confirmed_byTousersInput, UserUncheckedCreateWithoutOrders_orders_payment_confirmed_byTousersInput>
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    workerAttendance?: WorkerAttendanceCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogUncheckedCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogUncheckedCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    workerAttendance?: WorkerAttendanceUncheckedCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryUncheckedCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageUncheckedCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalUncheckedCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryUncheckedCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type RentalItemCreateWithoutOrderInput = {
    id?: string
    quantity?: number | null
    createdAt?: Date | string | null
    rentalPackage?: RentalPackageCreateNestedOneWithoutRentalItemsInput
    variant?: ProductVariantCreateNestedOneWithoutRentalItemsInput
    unit?: ProductUnitCreateNestedOneWithoutRentalItemsInput
    deliveryItems?: DeliveryItemCreateNestedManyWithoutRentalItemInput
  }

  export type RentalItemUncheckedCreateWithoutOrderInput = {
    id?: string
    variantId?: string | null
    packageId?: string | null
    quantity?: number | null
    createdAt?: Date | string | null
    unitId?: string | null
    deliveryItems?: DeliveryItemUncheckedCreateNestedManyWithoutRentalItemInput
  }

  export type RentalItemCreateOrConnectWithoutOrderInput = {
    where: RentalItemWhereUniqueInput
    create: XOR<RentalItemCreateWithoutOrderInput, RentalItemUncheckedCreateWithoutOrderInput>
  }

  export type RentalItemCreateManyOrderInputEnvelope = {
    data: RentalItemCreateManyOrderInput | RentalItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type PaymentTransactionCreateWithoutOrderInput = {
    id?: string
    provider: $Enums.PaymentProvider
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.TransactionStatus
    externalReferenceId?: string | null
    proofUrl?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verifiedBy?: UserCreateNestedOneWithoutVerifiedTransactionsInput
  }

  export type PaymentTransactionUncheckedCreateWithoutOrderInput = {
    id?: string
    provider: $Enums.PaymentProvider
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.TransactionStatus
    externalReferenceId?: string | null
    proofUrl?: string | null
    verifiedByAdminId?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentTransactionCreateOrConnectWithoutOrderInput = {
    where: PaymentTransactionWhereUniqueInput
    create: XOR<PaymentTransactionCreateWithoutOrderInput, PaymentTransactionUncheckedCreateWithoutOrderInput>
  }

  export type PaymentTransactionCreateManyOrderInputEnvelope = {
    data: PaymentTransactionCreateManyOrderInput | PaymentTransactionCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceUpsertWithWhereUniqueWithoutOrderInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutOrderInput, InvoiceUncheckedUpdateWithoutOrderInput>
    create: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutOrderInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutOrderInput, InvoiceUncheckedUpdateWithoutOrderInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutOrderInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutOrderInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: UuidFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    orderId?: UuidNullableFilter<"Invoice"> | string | null
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    currency?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    userId?: UuidNullableFilter<"Invoice"> | string | null
    status?: StringFilter<"Invoice"> | string
    guestEmail?: StringNullableFilter<"Invoice"> | string | null
    guestName?: StringNullableFilter<"Invoice"> | string | null
    guestWhatsapp?: StringNullableFilter<"Invoice"> | string | null
    guestAddress?: StringNullableFilter<"Invoice"> | string | null
    deliveryFeeOverride?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    taxRate?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: IntNullableFilter<"Invoice"> | number | null
    discountAmount?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    shareableToken?: StringNullableFilter<"Invoice"> | string | null
    emailSent?: BoolNullableFilter<"Invoice"> | boolean | null
    emailSentAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
  }

  export type ProductUnitUpsertWithWhereUniqueWithoutAssignedOrderInput = {
    where: ProductUnitWhereUniqueInput
    update: XOR<ProductUnitUpdateWithoutAssignedOrderInput, ProductUnitUncheckedUpdateWithoutAssignedOrderInput>
    create: XOR<ProductUnitCreateWithoutAssignedOrderInput, ProductUnitUncheckedCreateWithoutAssignedOrderInput>
  }

  export type ProductUnitUpdateWithWhereUniqueWithoutAssignedOrderInput = {
    where: ProductUnitWhereUniqueInput
    data: XOR<ProductUnitUpdateWithoutAssignedOrderInput, ProductUnitUncheckedUpdateWithoutAssignedOrderInput>
  }

  export type ProductUnitUpdateManyWithWhereWithoutAssignedOrderInput = {
    where: ProductUnitScalarWhereInput
    data: XOR<ProductUnitUpdateManyMutationInput, ProductUnitUncheckedUpdateManyWithoutAssignedOrderInput>
  }

  export type ProductUnitScalarWhereInput = {
    AND?: ProductUnitScalarWhereInput | ProductUnitScalarWhereInput[]
    OR?: ProductUnitScalarWhereInput[]
    NOT?: ProductUnitScalarWhereInput | ProductUnitScalarWhereInput[]
    id?: UuidFilter<"ProductUnit"> | string
    variantId?: UuidFilter<"ProductUnit"> | string
    serialNumber?: StringFilter<"ProductUnit"> | string
    status?: EnumUnitStatusFilter<"ProductUnit"> | $Enums.UnitStatus
    condition?: EnumUnitConditionFilter<"ProductUnit"> | $Enums.UnitCondition
    assignedOrderId?: UuidNullableFilter<"ProductUnit"> | string | null
    purchaseDate?: DateTimeNullableFilter<"ProductUnit"> | Date | string | null
    lastServiceDate?: DateTimeNullableFilter<"ProductUnit"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductUnit"> | Date | string
    updatedAt?: DateTimeFilter<"ProductUnit"> | Date | string
  }

  export type UserUpsertWithoutOrders_orders_payment_confirmed_byTousersInput = {
    update: XOR<UserUpdateWithoutOrders_orders_payment_confirmed_byTousersInput, UserUncheckedUpdateWithoutOrders_orders_payment_confirmed_byTousersInput>
    create: XOR<UserCreateWithoutOrders_orders_payment_confirmed_byTousersInput, UserUncheckedCreateWithoutOrders_orders_payment_confirmed_byTousersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrders_orders_payment_confirmed_byTousersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrders_orders_payment_confirmed_byTousersInput, UserUncheckedUpdateWithoutOrders_orders_payment_confirmed_byTousersInput>
  }

  export type UserUpdateWithoutOrders_orders_payment_confirmed_byTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutOrders_orders_payment_confirmed_byTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUncheckedUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUncheckedUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUncheckedUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUncheckedUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUncheckedUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUncheckedUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUncheckedUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUncheckedUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    workerAttendance?: WorkerAttendanceUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUncheckedUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    workerAttendance?: WorkerAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUncheckedUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUncheckedUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUncheckedUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUncheckedUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUncheckedUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUncheckedUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUncheckedUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type RentalItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: RentalItemWhereUniqueInput
    update: XOR<RentalItemUpdateWithoutOrderInput, RentalItemUncheckedUpdateWithoutOrderInput>
    create: XOR<RentalItemCreateWithoutOrderInput, RentalItemUncheckedCreateWithoutOrderInput>
  }

  export type RentalItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: RentalItemWhereUniqueInput
    data: XOR<RentalItemUpdateWithoutOrderInput, RentalItemUncheckedUpdateWithoutOrderInput>
  }

  export type RentalItemUpdateManyWithWhereWithoutOrderInput = {
    where: RentalItemScalarWhereInput
    data: XOR<RentalItemUpdateManyMutationInput, RentalItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type RentalItemScalarWhereInput = {
    AND?: RentalItemScalarWhereInput | RentalItemScalarWhereInput[]
    OR?: RentalItemScalarWhereInput[]
    NOT?: RentalItemScalarWhereInput | RentalItemScalarWhereInput[]
    id?: UuidFilter<"RentalItem"> | string
    orderId?: UuidFilter<"RentalItem"> | string
    variantId?: UuidNullableFilter<"RentalItem"> | string | null
    packageId?: UuidNullableFilter<"RentalItem"> | string | null
    quantity?: IntNullableFilter<"RentalItem"> | number | null
    createdAt?: DateTimeNullableFilter<"RentalItem"> | Date | string | null
    unitId?: UuidNullableFilter<"RentalItem"> | string | null
  }

  export type PaymentTransactionUpsertWithWhereUniqueWithoutOrderInput = {
    where: PaymentTransactionWhereUniqueInput
    update: XOR<PaymentTransactionUpdateWithoutOrderInput, PaymentTransactionUncheckedUpdateWithoutOrderInput>
    create: XOR<PaymentTransactionCreateWithoutOrderInput, PaymentTransactionUncheckedCreateWithoutOrderInput>
  }

  export type PaymentTransactionUpdateWithWhereUniqueWithoutOrderInput = {
    where: PaymentTransactionWhereUniqueInput
    data: XOR<PaymentTransactionUpdateWithoutOrderInput, PaymentTransactionUncheckedUpdateWithoutOrderInput>
  }

  export type PaymentTransactionUpdateManyWithWhereWithoutOrderInput = {
    where: PaymentTransactionScalarWhereInput
    data: XOR<PaymentTransactionUpdateManyMutationInput, PaymentTransactionUncheckedUpdateManyWithoutOrderInput>
  }

  export type PaymentTransactionScalarWhereInput = {
    AND?: PaymentTransactionScalarWhereInput | PaymentTransactionScalarWhereInput[]
    OR?: PaymentTransactionScalarWhereInput[]
    NOT?: PaymentTransactionScalarWhereInput | PaymentTransactionScalarWhereInput[]
    id?: UuidFilter<"PaymentTransaction"> | string
    orderId?: UuidFilter<"PaymentTransaction"> | string
    provider?: EnumPaymentProviderFilter<"PaymentTransaction"> | $Enums.PaymentProvider
    amount?: DecimalFilter<"PaymentTransaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"PaymentTransaction"> | string
    status?: EnumTransactionStatusFilter<"PaymentTransaction"> | $Enums.TransactionStatus
    externalReferenceId?: StringNullableFilter<"PaymentTransaction"> | string | null
    proofUrl?: StringNullableFilter<"PaymentTransaction"> | string | null
    verifiedByAdminId?: UuidNullableFilter<"PaymentTransaction"> | string | null
    verifiedAt?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
  }

  export type OrderCreateWithoutPaymentTransactionsInput = {
    id?: string
    orderNumber: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    totalAmount: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    paymentMethod?: string | null
    createdAt?: Date | string | null
    paymentStatus?: string | null
    paymentConfirmedAt?: Date | string | null
    deliveryAddress?: string | null
    invoices?: InvoiceCreateNestedManyWithoutOrderInput
    assignedUnits?: ProductUnitCreateNestedManyWithoutAssignedOrderInput
    users_orders_payment_confirmed_byTousers?: UserCreateNestedOneWithoutOrders_orders_payment_confirmed_byTousersInput
    user: UserCreateNestedOneWithoutOrdersInput
    rentalItems?: RentalItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPaymentTransactionsInput = {
    id?: string
    orderNumber: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    totalAmount: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    paymentMethod?: string | null
    createdAt?: Date | string | null
    userId: string
    paymentStatus?: string | null
    paymentConfirmedBy?: string | null
    paymentConfirmedAt?: Date | string | null
    deliveryAddress?: string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
    assignedUnits?: ProductUnitUncheckedCreateNestedManyWithoutAssignedOrderInput
    rentalItems?: RentalItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPaymentTransactionsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPaymentTransactionsInput, OrderUncheckedCreateWithoutPaymentTransactionsInput>
  }

  export type UserCreateWithoutVerifiedTransactionsInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationCreateNestedManyWithoutUserInput
    unitActions?: UnitHistoryCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutVerifiedTransactionsInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogUncheckedCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogUncheckedCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceUncheckedCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryUncheckedCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageUncheckedCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalUncheckedCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    unitActions?: UnitHistoryUncheckedCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutVerifiedTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVerifiedTransactionsInput, UserUncheckedCreateWithoutVerifiedTransactionsInput>
  }

  export type OrderUpsertWithoutPaymentTransactionsInput = {
    update: XOR<OrderUpdateWithoutPaymentTransactionsInput, OrderUncheckedUpdateWithoutPaymentTransactionsInput>
    create: XOR<OrderCreateWithoutPaymentTransactionsInput, OrderUncheckedCreateWithoutPaymentTransactionsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPaymentTransactionsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPaymentTransactionsInput, OrderUncheckedUpdateWithoutPaymentTransactionsInput>
  }

  export type OrderUpdateWithoutPaymentTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUpdateManyWithoutOrderNestedInput
    assignedUnits?: ProductUnitUpdateManyWithoutAssignedOrderNestedInput
    users_orders_payment_confirmed_byTousers?: UserUpdateOneWithoutOrders_orders_payment_confirmed_byTousersNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    rentalItems?: RentalItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPaymentTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
    assignedUnits?: ProductUnitUncheckedUpdateManyWithoutAssignedOrderNestedInput
    rentalItems?: RentalItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type UserUpsertWithoutVerifiedTransactionsInput = {
    update: XOR<UserUpdateWithoutVerifiedTransactionsInput, UserUncheckedUpdateWithoutVerifiedTransactionsInput>
    create: XOR<UserCreateWithoutVerifiedTransactionsInput, UserUncheckedCreateWithoutVerifiedTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVerifiedTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVerifiedTransactionsInput, UserUncheckedUpdateWithoutVerifiedTransactionsInput>
  }

  export type UserUpdateWithoutVerifiedTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    unitActions?: UnitHistoryUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutVerifiedTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUncheckedUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUncheckedUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUncheckedUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUncheckedUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUncheckedUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUncheckedUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    unitActions?: UnitHistoryUncheckedUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type ProductCreateWithoutProductRelationsInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    monthlyPrice: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    imageUrl?: string | null
    createdAt?: Date | string | null
    images?: ProductCreateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    inventorySyncLogs?: InventorySyncLogCreateNestedManyWithoutProductInput
    rentalPackageItems?: RentalPackageItemCreateNestedManyWithoutProductInput
    relatedTo?: ProductRelationCreateNestedManyWithoutRelatedProductInput
    variants?: ProductVariantCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductRelationsInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    monthlyPrice: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    imageUrl?: string | null
    createdAt?: Date | string | null
    images?: ProductCreateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    inventorySyncLogs?: InventorySyncLogUncheckedCreateNestedManyWithoutProductInput
    rentalPackageItems?: RentalPackageItemUncheckedCreateNestedManyWithoutProductInput
    relatedTo?: ProductRelationUncheckedCreateNestedManyWithoutRelatedProductInput
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductRelationsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductRelationsInput, ProductUncheckedCreateWithoutProductRelationsInput>
  }

  export type ProductCreateWithoutRelatedToInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    monthlyPrice: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    imageUrl?: string | null
    createdAt?: Date | string | null
    images?: ProductCreateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    inventorySyncLogs?: InventorySyncLogCreateNestedManyWithoutProductInput
    rentalPackageItems?: RentalPackageItemCreateNestedManyWithoutProductInput
    productRelations?: ProductRelationCreateNestedManyWithoutProductInput
    variants?: ProductVariantCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutRelatedToInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    monthlyPrice: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    imageUrl?: string | null
    createdAt?: Date | string | null
    images?: ProductCreateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    inventorySyncLogs?: InventorySyncLogUncheckedCreateNestedManyWithoutProductInput
    rentalPackageItems?: RentalPackageItemUncheckedCreateNestedManyWithoutProductInput
    productRelations?: ProductRelationUncheckedCreateNestedManyWithoutProductInput
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutRelatedToInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutRelatedToInput, ProductUncheckedCreateWithoutRelatedToInput>
  }

  export type ProductUpsertWithoutProductRelationsInput = {
    update: XOR<ProductUpdateWithoutProductRelationsInput, ProductUncheckedUpdateWithoutProductRelationsInput>
    create: XOR<ProductCreateWithoutProductRelationsInput, ProductUncheckedCreateWithoutProductRelationsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductRelationsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductRelationsInput, ProductUncheckedUpdateWithoutProductRelationsInput>
  }

  export type ProductUpdateWithoutProductRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: ProductUpdateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    inventorySyncLogs?: InventorySyncLogUpdateManyWithoutProductNestedInput
    rentalPackageItems?: RentalPackageItemUpdateManyWithoutProductNestedInput
    relatedTo?: ProductRelationUpdateManyWithoutRelatedProductNestedInput
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: ProductUpdateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    inventorySyncLogs?: InventorySyncLogUncheckedUpdateManyWithoutProductNestedInput
    rentalPackageItems?: RentalPackageItemUncheckedUpdateManyWithoutProductNestedInput
    relatedTo?: ProductRelationUncheckedUpdateManyWithoutRelatedProductNestedInput
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUpsertWithoutRelatedToInput = {
    update: XOR<ProductUpdateWithoutRelatedToInput, ProductUncheckedUpdateWithoutRelatedToInput>
    create: XOR<ProductCreateWithoutRelatedToInput, ProductUncheckedCreateWithoutRelatedToInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutRelatedToInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutRelatedToInput, ProductUncheckedUpdateWithoutRelatedToInput>
  }

  export type ProductUpdateWithoutRelatedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: ProductUpdateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    inventorySyncLogs?: InventorySyncLogUpdateManyWithoutProductNestedInput
    rentalPackageItems?: RentalPackageItemUpdateManyWithoutProductNestedInput
    productRelations?: ProductRelationUpdateManyWithoutProductNestedInput
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutRelatedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: ProductUpdateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    inventorySyncLogs?: InventorySyncLogUncheckedUpdateManyWithoutProductNestedInput
    rentalPackageItems?: RentalPackageItemUncheckedUpdateManyWithoutProductNestedInput
    productRelations?: ProductRelationUncheckedUpdateManyWithoutProductNestedInput
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
  }

  export type RentalPackageCreateWithoutRentalPackageItemsInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    price: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    duration: number
    createdAt?: Date | string | null
    images?: RentalPackageCreateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    rentalItems?: RentalItemCreateNestedManyWithoutRentalPackageInput
  }

  export type RentalPackageUncheckedCreateWithoutRentalPackageItemsInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    price: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    duration: number
    createdAt?: Date | string | null
    images?: RentalPackageCreateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    rentalItems?: RentalItemUncheckedCreateNestedManyWithoutRentalPackageInput
  }

  export type RentalPackageCreateOrConnectWithoutRentalPackageItemsInput = {
    where: RentalPackageWhereUniqueInput
    create: XOR<RentalPackageCreateWithoutRentalPackageItemsInput, RentalPackageUncheckedCreateWithoutRentalPackageItemsInput>
  }

  export type ProductCreateWithoutRentalPackageItemsInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    monthlyPrice: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    imageUrl?: string | null
    createdAt?: Date | string | null
    images?: ProductCreateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    inventorySyncLogs?: InventorySyncLogCreateNestedManyWithoutProductInput
    productRelations?: ProductRelationCreateNestedManyWithoutProductInput
    relatedTo?: ProductRelationCreateNestedManyWithoutRelatedProductInput
    variants?: ProductVariantCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutRentalPackageItemsInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    monthlyPrice: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    imageUrl?: string | null
    createdAt?: Date | string | null
    images?: ProductCreateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    inventorySyncLogs?: InventorySyncLogUncheckedCreateNestedManyWithoutProductInput
    productRelations?: ProductRelationUncheckedCreateNestedManyWithoutProductInput
    relatedTo?: ProductRelationUncheckedCreateNestedManyWithoutRelatedProductInput
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutRentalPackageItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutRentalPackageItemsInput, ProductUncheckedCreateWithoutRentalPackageItemsInput>
  }

  export type RentalPackageUpsertWithoutRentalPackageItemsInput = {
    update: XOR<RentalPackageUpdateWithoutRentalPackageItemsInput, RentalPackageUncheckedUpdateWithoutRentalPackageItemsInput>
    create: XOR<RentalPackageCreateWithoutRentalPackageItemsInput, RentalPackageUncheckedCreateWithoutRentalPackageItemsInput>
    where?: RentalPackageWhereInput
  }

  export type RentalPackageUpdateToOneWithWhereWithoutRentalPackageItemsInput = {
    where?: RentalPackageWhereInput
    data: XOR<RentalPackageUpdateWithoutRentalPackageItemsInput, RentalPackageUncheckedUpdateWithoutRentalPackageItemsInput>
  }

  export type RentalPackageUpdateWithoutRentalPackageItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: RentalPackageUpdateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    rentalItems?: RentalItemUpdateManyWithoutRentalPackageNestedInput
  }

  export type RentalPackageUncheckedUpdateWithoutRentalPackageItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: RentalPackageUpdateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    rentalItems?: RentalItemUncheckedUpdateManyWithoutRentalPackageNestedInput
  }

  export type ProductUpsertWithoutRentalPackageItemsInput = {
    update: XOR<ProductUpdateWithoutRentalPackageItemsInput, ProductUncheckedUpdateWithoutRentalPackageItemsInput>
    create: XOR<ProductCreateWithoutRentalPackageItemsInput, ProductUncheckedCreateWithoutRentalPackageItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutRentalPackageItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutRentalPackageItemsInput, ProductUncheckedUpdateWithoutRentalPackageItemsInput>
  }

  export type ProductUpdateWithoutRentalPackageItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: ProductUpdateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    inventorySyncLogs?: InventorySyncLogUpdateManyWithoutProductNestedInput
    productRelations?: ProductRelationUpdateManyWithoutProductNestedInput
    relatedTo?: ProductRelationUpdateManyWithoutRelatedProductNestedInput
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutRentalPackageItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: ProductUpdateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    inventorySyncLogs?: InventorySyncLogUncheckedUpdateManyWithoutProductNestedInput
    productRelations?: ProductRelationUncheckedUpdateManyWithoutProductNestedInput
    relatedTo?: ProductRelationUncheckedUpdateManyWithoutRelatedProductNestedInput
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
  }

  export type RentalPackageItemCreateWithoutRentalPackageInput = {
    id?: string
    quantity?: number | null
    createdAt?: Date | string | null
    product: ProductCreateNestedOneWithoutRentalPackageItemsInput
  }

  export type RentalPackageItemUncheckedCreateWithoutRentalPackageInput = {
    id?: string
    productId: string
    quantity?: number | null
    createdAt?: Date | string | null
  }

  export type RentalPackageItemCreateOrConnectWithoutRentalPackageInput = {
    where: RentalPackageItemWhereUniqueInput
    create: XOR<RentalPackageItemCreateWithoutRentalPackageInput, RentalPackageItemUncheckedCreateWithoutRentalPackageInput>
  }

  export type RentalPackageItemCreateManyRentalPackageInputEnvelope = {
    data: RentalPackageItemCreateManyRentalPackageInput | RentalPackageItemCreateManyRentalPackageInput[]
    skipDuplicates?: boolean
  }

  export type RentalItemCreateWithoutRentalPackageInput = {
    id?: string
    quantity?: number | null
    createdAt?: Date | string | null
    order: OrderCreateNestedOneWithoutRentalItemsInput
    variant?: ProductVariantCreateNestedOneWithoutRentalItemsInput
    unit?: ProductUnitCreateNestedOneWithoutRentalItemsInput
    deliveryItems?: DeliveryItemCreateNestedManyWithoutRentalItemInput
  }

  export type RentalItemUncheckedCreateWithoutRentalPackageInput = {
    id?: string
    orderId: string
    variantId?: string | null
    quantity?: number | null
    createdAt?: Date | string | null
    unitId?: string | null
    deliveryItems?: DeliveryItemUncheckedCreateNestedManyWithoutRentalItemInput
  }

  export type RentalItemCreateOrConnectWithoutRentalPackageInput = {
    where: RentalItemWhereUniqueInput
    create: XOR<RentalItemCreateWithoutRentalPackageInput, RentalItemUncheckedCreateWithoutRentalPackageInput>
  }

  export type RentalItemCreateManyRentalPackageInputEnvelope = {
    data: RentalItemCreateManyRentalPackageInput | RentalItemCreateManyRentalPackageInput[]
    skipDuplicates?: boolean
  }

  export type RentalPackageItemUpsertWithWhereUniqueWithoutRentalPackageInput = {
    where: RentalPackageItemWhereUniqueInput
    update: XOR<RentalPackageItemUpdateWithoutRentalPackageInput, RentalPackageItemUncheckedUpdateWithoutRentalPackageInput>
    create: XOR<RentalPackageItemCreateWithoutRentalPackageInput, RentalPackageItemUncheckedCreateWithoutRentalPackageInput>
  }

  export type RentalPackageItemUpdateWithWhereUniqueWithoutRentalPackageInput = {
    where: RentalPackageItemWhereUniqueInput
    data: XOR<RentalPackageItemUpdateWithoutRentalPackageInput, RentalPackageItemUncheckedUpdateWithoutRentalPackageInput>
  }

  export type RentalPackageItemUpdateManyWithWhereWithoutRentalPackageInput = {
    where: RentalPackageItemScalarWhereInput
    data: XOR<RentalPackageItemUpdateManyMutationInput, RentalPackageItemUncheckedUpdateManyWithoutRentalPackageInput>
  }

  export type RentalPackageItemScalarWhereInput = {
    AND?: RentalPackageItemScalarWhereInput | RentalPackageItemScalarWhereInput[]
    OR?: RentalPackageItemScalarWhereInput[]
    NOT?: RentalPackageItemScalarWhereInput | RentalPackageItemScalarWhereInput[]
    id?: UuidFilter<"RentalPackageItem"> | string
    rentalPackageId?: UuidFilter<"RentalPackageItem"> | string
    productId?: UuidFilter<"RentalPackageItem"> | string
    quantity?: IntNullableFilter<"RentalPackageItem"> | number | null
    createdAt?: DateTimeNullableFilter<"RentalPackageItem"> | Date | string | null
  }

  export type RentalItemUpsertWithWhereUniqueWithoutRentalPackageInput = {
    where: RentalItemWhereUniqueInput
    update: XOR<RentalItemUpdateWithoutRentalPackageInput, RentalItemUncheckedUpdateWithoutRentalPackageInput>
    create: XOR<RentalItemCreateWithoutRentalPackageInput, RentalItemUncheckedCreateWithoutRentalPackageInput>
  }

  export type RentalItemUpdateWithWhereUniqueWithoutRentalPackageInput = {
    where: RentalItemWhereUniqueInput
    data: XOR<RentalItemUpdateWithoutRentalPackageInput, RentalItemUncheckedUpdateWithoutRentalPackageInput>
  }

  export type RentalItemUpdateManyWithWhereWithoutRentalPackageInput = {
    where: RentalItemScalarWhereInput
    data: XOR<RentalItemUpdateManyMutationInput, RentalItemUncheckedUpdateManyWithoutRentalPackageInput>
  }

  export type InventorySyncLogCreateWithoutProductInput = {
    id?: string
    oldQuantity: number
    newQuantity: number
    source: $Enums.inventory_source
    conflict?: boolean | null
    resolved?: boolean | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string | null
    resolvedByUser?: UserCreateNestedOneWithoutInventoryResolutionsInput
    updatedByUser: UserCreateNestedOneWithoutInventoryUpdatesInput
  }

  export type InventorySyncLogUncheckedCreateWithoutProductInput = {
    id?: string
    oldQuantity: number
    newQuantity: number
    updatedBy: string
    source: $Enums.inventory_source
    conflict?: boolean | null
    resolved?: boolean | null
    resolvedBy?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string | null
  }

  export type InventorySyncLogCreateOrConnectWithoutProductInput = {
    where: InventorySyncLogWhereUniqueInput
    create: XOR<InventorySyncLogCreateWithoutProductInput, InventorySyncLogUncheckedCreateWithoutProductInput>
  }

  export type InventorySyncLogCreateManyProductInputEnvelope = {
    data: InventorySyncLogCreateManyProductInput | InventorySyncLogCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type RentalPackageItemCreateWithoutProductInput = {
    id?: string
    quantity?: number | null
    createdAt?: Date | string | null
    rentalPackage: RentalPackageCreateNestedOneWithoutRentalPackageItemsInput
  }

  export type RentalPackageItemUncheckedCreateWithoutProductInput = {
    id?: string
    rentalPackageId: string
    quantity?: number | null
    createdAt?: Date | string | null
  }

  export type RentalPackageItemCreateOrConnectWithoutProductInput = {
    where: RentalPackageItemWhereUniqueInput
    create: XOR<RentalPackageItemCreateWithoutProductInput, RentalPackageItemUncheckedCreateWithoutProductInput>
  }

  export type RentalPackageItemCreateManyProductInputEnvelope = {
    data: RentalPackageItemCreateManyProductInput | RentalPackageItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductRelationCreateWithoutProductInput = {
    id?: string
    relationType?: $Enums.RelationType
    priority?: number
    aiScore?: number | null
    createdAt?: Date | string
    relatedProduct: ProductCreateNestedOneWithoutRelatedToInput
  }

  export type ProductRelationUncheckedCreateWithoutProductInput = {
    id?: string
    relatedProductId: string
    relationType?: $Enums.RelationType
    priority?: number
    aiScore?: number | null
    createdAt?: Date | string
  }

  export type ProductRelationCreateOrConnectWithoutProductInput = {
    where: ProductRelationWhereUniqueInput
    create: XOR<ProductRelationCreateWithoutProductInput, ProductRelationUncheckedCreateWithoutProductInput>
  }

  export type ProductRelationCreateManyProductInputEnvelope = {
    data: ProductRelationCreateManyProductInput | ProductRelationCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductRelationCreateWithoutRelatedProductInput = {
    id?: string
    relationType?: $Enums.RelationType
    priority?: number
    aiScore?: number | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutProductRelationsInput
  }

  export type ProductRelationUncheckedCreateWithoutRelatedProductInput = {
    id?: string
    productId: string
    relationType?: $Enums.RelationType
    priority?: number
    aiScore?: number | null
    createdAt?: Date | string
  }

  export type ProductRelationCreateOrConnectWithoutRelatedProductInput = {
    where: ProductRelationWhereUniqueInput
    create: XOR<ProductRelationCreateWithoutRelatedProductInput, ProductRelationUncheckedCreateWithoutRelatedProductInput>
  }

  export type ProductRelationCreateManyRelatedProductInputEnvelope = {
    data: ProductRelationCreateManyRelatedProductInput | ProductRelationCreateManyRelatedProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductVariantCreateWithoutProductInput = {
    id?: string
    color?: string
    sku: string
    monthlyPrice?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rentalItems?: RentalItemCreateNestedManyWithoutVariantInput
    units?: ProductUnitCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutProductInput = {
    id?: string
    color?: string
    sku: string
    monthlyPrice?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rentalItems?: RentalItemUncheckedCreateNestedManyWithoutVariantInput
    units?: ProductUnitUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutProductInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput>
  }

  export type ProductVariantCreateManyProductInputEnvelope = {
    data: ProductVariantCreateManyProductInput | ProductVariantCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type InventorySyncLogUpsertWithWhereUniqueWithoutProductInput = {
    where: InventorySyncLogWhereUniqueInput
    update: XOR<InventorySyncLogUpdateWithoutProductInput, InventorySyncLogUncheckedUpdateWithoutProductInput>
    create: XOR<InventorySyncLogCreateWithoutProductInput, InventorySyncLogUncheckedCreateWithoutProductInput>
  }

  export type InventorySyncLogUpdateWithWhereUniqueWithoutProductInput = {
    where: InventorySyncLogWhereUniqueInput
    data: XOR<InventorySyncLogUpdateWithoutProductInput, InventorySyncLogUncheckedUpdateWithoutProductInput>
  }

  export type InventorySyncLogUpdateManyWithWhereWithoutProductInput = {
    where: InventorySyncLogScalarWhereInput
    data: XOR<InventorySyncLogUpdateManyMutationInput, InventorySyncLogUncheckedUpdateManyWithoutProductInput>
  }

  export type InventorySyncLogScalarWhereInput = {
    AND?: InventorySyncLogScalarWhereInput | InventorySyncLogScalarWhereInput[]
    OR?: InventorySyncLogScalarWhereInput[]
    NOT?: InventorySyncLogScalarWhereInput | InventorySyncLogScalarWhereInput[]
    id?: UuidFilter<"InventorySyncLog"> | string
    productId?: UuidFilter<"InventorySyncLog"> | string
    oldQuantity?: IntFilter<"InventorySyncLog"> | number
    newQuantity?: IntFilter<"InventorySyncLog"> | number
    updatedBy?: UuidFilter<"InventorySyncLog"> | string
    source?: Enuminventory_sourceFilter<"InventorySyncLog"> | $Enums.inventory_source
    conflict?: BoolNullableFilter<"InventorySyncLog"> | boolean | null
    resolved?: BoolNullableFilter<"InventorySyncLog"> | boolean | null
    resolvedBy?: UuidNullableFilter<"InventorySyncLog"> | string | null
    resolvedAt?: DateTimeNullableFilter<"InventorySyncLog"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"InventorySyncLog"> | Date | string | null
  }

  export type RentalPackageItemUpsertWithWhereUniqueWithoutProductInput = {
    where: RentalPackageItemWhereUniqueInput
    update: XOR<RentalPackageItemUpdateWithoutProductInput, RentalPackageItemUncheckedUpdateWithoutProductInput>
    create: XOR<RentalPackageItemCreateWithoutProductInput, RentalPackageItemUncheckedCreateWithoutProductInput>
  }

  export type RentalPackageItemUpdateWithWhereUniqueWithoutProductInput = {
    where: RentalPackageItemWhereUniqueInput
    data: XOR<RentalPackageItemUpdateWithoutProductInput, RentalPackageItemUncheckedUpdateWithoutProductInput>
  }

  export type RentalPackageItemUpdateManyWithWhereWithoutProductInput = {
    where: RentalPackageItemScalarWhereInput
    data: XOR<RentalPackageItemUpdateManyMutationInput, RentalPackageItemUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductRelationUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductRelationWhereUniqueInput
    update: XOR<ProductRelationUpdateWithoutProductInput, ProductRelationUncheckedUpdateWithoutProductInput>
    create: XOR<ProductRelationCreateWithoutProductInput, ProductRelationUncheckedCreateWithoutProductInput>
  }

  export type ProductRelationUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductRelationWhereUniqueInput
    data: XOR<ProductRelationUpdateWithoutProductInput, ProductRelationUncheckedUpdateWithoutProductInput>
  }

  export type ProductRelationUpdateManyWithWhereWithoutProductInput = {
    where: ProductRelationScalarWhereInput
    data: XOR<ProductRelationUpdateManyMutationInput, ProductRelationUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductRelationScalarWhereInput = {
    AND?: ProductRelationScalarWhereInput | ProductRelationScalarWhereInput[]
    OR?: ProductRelationScalarWhereInput[]
    NOT?: ProductRelationScalarWhereInput | ProductRelationScalarWhereInput[]
    id?: UuidFilter<"ProductRelation"> | string
    productId?: UuidFilter<"ProductRelation"> | string
    relatedProductId?: UuidFilter<"ProductRelation"> | string
    relationType?: EnumRelationTypeFilter<"ProductRelation"> | $Enums.RelationType
    priority?: IntFilter<"ProductRelation"> | number
    aiScore?: FloatNullableFilter<"ProductRelation"> | number | null
    createdAt?: DateTimeFilter<"ProductRelation"> | Date | string
  }

  export type ProductRelationUpsertWithWhereUniqueWithoutRelatedProductInput = {
    where: ProductRelationWhereUniqueInput
    update: XOR<ProductRelationUpdateWithoutRelatedProductInput, ProductRelationUncheckedUpdateWithoutRelatedProductInput>
    create: XOR<ProductRelationCreateWithoutRelatedProductInput, ProductRelationUncheckedCreateWithoutRelatedProductInput>
  }

  export type ProductRelationUpdateWithWhereUniqueWithoutRelatedProductInput = {
    where: ProductRelationWhereUniqueInput
    data: XOR<ProductRelationUpdateWithoutRelatedProductInput, ProductRelationUncheckedUpdateWithoutRelatedProductInput>
  }

  export type ProductRelationUpdateManyWithWhereWithoutRelatedProductInput = {
    where: ProductRelationScalarWhereInput
    data: XOR<ProductRelationUpdateManyMutationInput, ProductRelationUncheckedUpdateManyWithoutRelatedProductInput>
  }

  export type ProductVariantUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductVariantWhereUniqueInput
    update: XOR<ProductVariantUpdateWithoutProductInput, ProductVariantUncheckedUpdateWithoutProductInput>
    create: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput>
  }

  export type ProductVariantUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductVariantWhereUniqueInput
    data: XOR<ProductVariantUpdateWithoutProductInput, ProductVariantUncheckedUpdateWithoutProductInput>
  }

  export type ProductVariantUpdateManyWithWhereWithoutProductInput = {
    where: ProductVariantScalarWhereInput
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductVariantScalarWhereInput = {
    AND?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
    OR?: ProductVariantScalarWhereInput[]
    NOT?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
    id?: UuidFilter<"ProductVariant"> | string
    productId?: UuidFilter<"ProductVariant"> | string
    color?: StringFilter<"ProductVariant"> | string
    sku?: StringFilter<"ProductVariant"> | string
    monthlyPrice?: DecimalNullableFilter<"ProductVariant"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string
  }

  export type ProductCreateWithoutVariantsInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    monthlyPrice: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    imageUrl?: string | null
    createdAt?: Date | string | null
    images?: ProductCreateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    inventorySyncLogs?: InventorySyncLogCreateNestedManyWithoutProductInput
    rentalPackageItems?: RentalPackageItemCreateNestedManyWithoutProductInput
    productRelations?: ProductRelationCreateNestedManyWithoutProductInput
    relatedTo?: ProductRelationCreateNestedManyWithoutRelatedProductInput
  }

  export type ProductUncheckedCreateWithoutVariantsInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    monthlyPrice: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    imageUrl?: string | null
    createdAt?: Date | string | null
    images?: ProductCreateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    inventorySyncLogs?: InventorySyncLogUncheckedCreateNestedManyWithoutProductInput
    rentalPackageItems?: RentalPackageItemUncheckedCreateNestedManyWithoutProductInput
    productRelations?: ProductRelationUncheckedCreateNestedManyWithoutProductInput
    relatedTo?: ProductRelationUncheckedCreateNestedManyWithoutRelatedProductInput
  }

  export type ProductCreateOrConnectWithoutVariantsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
  }

  export type RentalItemCreateWithoutVariantInput = {
    id?: string
    quantity?: number | null
    createdAt?: Date | string | null
    order: OrderCreateNestedOneWithoutRentalItemsInput
    rentalPackage?: RentalPackageCreateNestedOneWithoutRentalItemsInput
    unit?: ProductUnitCreateNestedOneWithoutRentalItemsInput
    deliveryItems?: DeliveryItemCreateNestedManyWithoutRentalItemInput
  }

  export type RentalItemUncheckedCreateWithoutVariantInput = {
    id?: string
    orderId: string
    packageId?: string | null
    quantity?: number | null
    createdAt?: Date | string | null
    unitId?: string | null
    deliveryItems?: DeliveryItemUncheckedCreateNestedManyWithoutRentalItemInput
  }

  export type RentalItemCreateOrConnectWithoutVariantInput = {
    where: RentalItemWhereUniqueInput
    create: XOR<RentalItemCreateWithoutVariantInput, RentalItemUncheckedCreateWithoutVariantInput>
  }

  export type RentalItemCreateManyVariantInputEnvelope = {
    data: RentalItemCreateManyVariantInput | RentalItemCreateManyVariantInput[]
    skipDuplicates?: boolean
  }

  export type ProductUnitCreateWithoutVariantInput = {
    id?: string
    serialNumber: string
    status?: $Enums.UnitStatus
    condition?: $Enums.UnitCondition
    purchaseDate?: Date | string | null
    lastServiceDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedOrder?: OrderCreateNestedOneWithoutAssignedUnitsInput
    rentalItems?: RentalItemCreateNestedManyWithoutUnitInput
    history?: UnitHistoryCreateNestedManyWithoutUnitInput
  }

  export type ProductUnitUncheckedCreateWithoutVariantInput = {
    id?: string
    serialNumber: string
    status?: $Enums.UnitStatus
    condition?: $Enums.UnitCondition
    assignedOrderId?: string | null
    purchaseDate?: Date | string | null
    lastServiceDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rentalItems?: RentalItemUncheckedCreateNestedManyWithoutUnitInput
    history?: UnitHistoryUncheckedCreateNestedManyWithoutUnitInput
  }

  export type ProductUnitCreateOrConnectWithoutVariantInput = {
    where: ProductUnitWhereUniqueInput
    create: XOR<ProductUnitCreateWithoutVariantInput, ProductUnitUncheckedCreateWithoutVariantInput>
  }

  export type ProductUnitCreateManyVariantInputEnvelope = {
    data: ProductUnitCreateManyVariantInput | ProductUnitCreateManyVariantInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutVariantsInput = {
    update: XOR<ProductUpdateWithoutVariantsInput, ProductUncheckedUpdateWithoutVariantsInput>
    create: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutVariantsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutVariantsInput, ProductUncheckedUpdateWithoutVariantsInput>
  }

  export type ProductUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: ProductUpdateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    inventorySyncLogs?: InventorySyncLogUpdateManyWithoutProductNestedInput
    rentalPackageItems?: RentalPackageItemUpdateManyWithoutProductNestedInput
    productRelations?: ProductRelationUpdateManyWithoutProductNestedInput
    relatedTo?: ProductRelationUpdateManyWithoutRelatedProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: ProductUpdateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    inventorySyncLogs?: InventorySyncLogUncheckedUpdateManyWithoutProductNestedInput
    rentalPackageItems?: RentalPackageItemUncheckedUpdateManyWithoutProductNestedInput
    productRelations?: ProductRelationUncheckedUpdateManyWithoutProductNestedInput
    relatedTo?: ProductRelationUncheckedUpdateManyWithoutRelatedProductNestedInput
  }

  export type RentalItemUpsertWithWhereUniqueWithoutVariantInput = {
    where: RentalItemWhereUniqueInput
    update: XOR<RentalItemUpdateWithoutVariantInput, RentalItemUncheckedUpdateWithoutVariantInput>
    create: XOR<RentalItemCreateWithoutVariantInput, RentalItemUncheckedCreateWithoutVariantInput>
  }

  export type RentalItemUpdateWithWhereUniqueWithoutVariantInput = {
    where: RentalItemWhereUniqueInput
    data: XOR<RentalItemUpdateWithoutVariantInput, RentalItemUncheckedUpdateWithoutVariantInput>
  }

  export type RentalItemUpdateManyWithWhereWithoutVariantInput = {
    where: RentalItemScalarWhereInput
    data: XOR<RentalItemUpdateManyMutationInput, RentalItemUncheckedUpdateManyWithoutVariantInput>
  }

  export type ProductUnitUpsertWithWhereUniqueWithoutVariantInput = {
    where: ProductUnitWhereUniqueInput
    update: XOR<ProductUnitUpdateWithoutVariantInput, ProductUnitUncheckedUpdateWithoutVariantInput>
    create: XOR<ProductUnitCreateWithoutVariantInput, ProductUnitUncheckedCreateWithoutVariantInput>
  }

  export type ProductUnitUpdateWithWhereUniqueWithoutVariantInput = {
    where: ProductUnitWhereUniqueInput
    data: XOR<ProductUnitUpdateWithoutVariantInput, ProductUnitUncheckedUpdateWithoutVariantInput>
  }

  export type ProductUnitUpdateManyWithWhereWithoutVariantInput = {
    where: ProductUnitScalarWhereInput
    data: XOR<ProductUnitUpdateManyMutationInput, ProductUnitUncheckedUpdateManyWithoutVariantInput>
  }

  export type ProductVariantCreateWithoutUnitsInput = {
    id?: string
    color?: string
    sku: string
    monthlyPrice?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
    rentalItems?: RentalItemCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutUnitsInput = {
    id?: string
    productId: string
    color?: string
    sku: string
    monthlyPrice?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rentalItems?: RentalItemUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutUnitsInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutUnitsInput, ProductVariantUncheckedCreateWithoutUnitsInput>
  }

  export type OrderCreateWithoutAssignedUnitsInput = {
    id?: string
    orderNumber: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    totalAmount: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    paymentMethod?: string | null
    createdAt?: Date | string | null
    paymentStatus?: string | null
    paymentConfirmedAt?: Date | string | null
    deliveryAddress?: string | null
    invoices?: InvoiceCreateNestedManyWithoutOrderInput
    users_orders_payment_confirmed_byTousers?: UserCreateNestedOneWithoutOrders_orders_payment_confirmed_byTousersInput
    user: UserCreateNestedOneWithoutOrdersInput
    rentalItems?: RentalItemCreateNestedManyWithoutOrderInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutAssignedUnitsInput = {
    id?: string
    orderNumber: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    totalAmount: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    paymentMethod?: string | null
    createdAt?: Date | string | null
    userId: string
    paymentStatus?: string | null
    paymentConfirmedBy?: string | null
    paymentConfirmedAt?: Date | string | null
    deliveryAddress?: string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
    rentalItems?: RentalItemUncheckedCreateNestedManyWithoutOrderInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutAssignedUnitsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutAssignedUnitsInput, OrderUncheckedCreateWithoutAssignedUnitsInput>
  }

  export type RentalItemCreateWithoutUnitInput = {
    id?: string
    quantity?: number | null
    createdAt?: Date | string | null
    order: OrderCreateNestedOneWithoutRentalItemsInput
    rentalPackage?: RentalPackageCreateNestedOneWithoutRentalItemsInput
    variant?: ProductVariantCreateNestedOneWithoutRentalItemsInput
    deliveryItems?: DeliveryItemCreateNestedManyWithoutRentalItemInput
  }

  export type RentalItemUncheckedCreateWithoutUnitInput = {
    id?: string
    orderId: string
    variantId?: string | null
    packageId?: string | null
    quantity?: number | null
    createdAt?: Date | string | null
    deliveryItems?: DeliveryItemUncheckedCreateNestedManyWithoutRentalItemInput
  }

  export type RentalItemCreateOrConnectWithoutUnitInput = {
    where: RentalItemWhereUniqueInput
    create: XOR<RentalItemCreateWithoutUnitInput, RentalItemUncheckedCreateWithoutUnitInput>
  }

  export type RentalItemCreateManyUnitInputEnvelope = {
    data: RentalItemCreateManyUnitInput | RentalItemCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type UnitHistoryCreateWithoutUnitInput = {
    id?: string
    oldStatus?: string | null
    newStatus: string
    oldCondition?: string | null
    newCondition?: string | null
    details?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutUnitActionsInput
  }

  export type UnitHistoryUncheckedCreateWithoutUnitInput = {
    id?: string
    oldStatus?: string | null
    newStatus: string
    oldCondition?: string | null
    newCondition?: string | null
    details?: string | null
    createdAt?: Date | string
    userId?: string | null
  }

  export type UnitHistoryCreateOrConnectWithoutUnitInput = {
    where: UnitHistoryWhereUniqueInput
    create: XOR<UnitHistoryCreateWithoutUnitInput, UnitHistoryUncheckedCreateWithoutUnitInput>
  }

  export type UnitHistoryCreateManyUnitInputEnvelope = {
    data: UnitHistoryCreateManyUnitInput | UnitHistoryCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type ProductVariantUpsertWithoutUnitsInput = {
    update: XOR<ProductVariantUpdateWithoutUnitsInput, ProductVariantUncheckedUpdateWithoutUnitsInput>
    create: XOR<ProductVariantCreateWithoutUnitsInput, ProductVariantUncheckedCreateWithoutUnitsInput>
    where?: ProductVariantWhereInput
  }

  export type ProductVariantUpdateToOneWithWhereWithoutUnitsInput = {
    where?: ProductVariantWhereInput
    data: XOR<ProductVariantUpdateWithoutUnitsInput, ProductVariantUncheckedUpdateWithoutUnitsInput>
  }

  export type ProductVariantUpdateWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    rentalItems?: RentalItemUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentalItems?: RentalItemUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type OrderUpsertWithoutAssignedUnitsInput = {
    update: XOR<OrderUpdateWithoutAssignedUnitsInput, OrderUncheckedUpdateWithoutAssignedUnitsInput>
    create: XOR<OrderCreateWithoutAssignedUnitsInput, OrderUncheckedCreateWithoutAssignedUnitsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutAssignedUnitsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutAssignedUnitsInput, OrderUncheckedUpdateWithoutAssignedUnitsInput>
  }

  export type OrderUpdateWithoutAssignedUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUpdateManyWithoutOrderNestedInput
    users_orders_payment_confirmed_byTousers?: UserUpdateOneWithoutOrders_orders_payment_confirmed_byTousersNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    rentalItems?: RentalItemUpdateManyWithoutOrderNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutAssignedUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
    rentalItems?: RentalItemUncheckedUpdateManyWithoutOrderNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type RentalItemUpsertWithWhereUniqueWithoutUnitInput = {
    where: RentalItemWhereUniqueInput
    update: XOR<RentalItemUpdateWithoutUnitInput, RentalItemUncheckedUpdateWithoutUnitInput>
    create: XOR<RentalItemCreateWithoutUnitInput, RentalItemUncheckedCreateWithoutUnitInput>
  }

  export type RentalItemUpdateWithWhereUniqueWithoutUnitInput = {
    where: RentalItemWhereUniqueInput
    data: XOR<RentalItemUpdateWithoutUnitInput, RentalItemUncheckedUpdateWithoutUnitInput>
  }

  export type RentalItemUpdateManyWithWhereWithoutUnitInput = {
    where: RentalItemScalarWhereInput
    data: XOR<RentalItemUpdateManyMutationInput, RentalItemUncheckedUpdateManyWithoutUnitInput>
  }

  export type UnitHistoryUpsertWithWhereUniqueWithoutUnitInput = {
    where: UnitHistoryWhereUniqueInput
    update: XOR<UnitHistoryUpdateWithoutUnitInput, UnitHistoryUncheckedUpdateWithoutUnitInput>
    create: XOR<UnitHistoryCreateWithoutUnitInput, UnitHistoryUncheckedCreateWithoutUnitInput>
  }

  export type UnitHistoryUpdateWithWhereUniqueWithoutUnitInput = {
    where: UnitHistoryWhereUniqueInput
    data: XOR<UnitHistoryUpdateWithoutUnitInput, UnitHistoryUncheckedUpdateWithoutUnitInput>
  }

  export type UnitHistoryUpdateManyWithWhereWithoutUnitInput = {
    where: UnitHistoryScalarWhereInput
    data: XOR<UnitHistoryUpdateManyMutationInput, UnitHistoryUncheckedUpdateManyWithoutUnitInput>
  }

  export type UnitHistoryScalarWhereInput = {
    AND?: UnitHistoryScalarWhereInput | UnitHistoryScalarWhereInput[]
    OR?: UnitHistoryScalarWhereInput[]
    NOT?: UnitHistoryScalarWhereInput | UnitHistoryScalarWhereInput[]
    id?: UuidFilter<"UnitHistory"> | string
    unitId?: UuidFilter<"UnitHistory"> | string
    oldStatus?: StringNullableFilter<"UnitHistory"> | string | null
    newStatus?: StringFilter<"UnitHistory"> | string
    oldCondition?: StringNullableFilter<"UnitHistory"> | string | null
    newCondition?: StringNullableFilter<"UnitHistory"> | string | null
    details?: StringNullableFilter<"UnitHistory"> | string | null
    createdAt?: DateTimeFilter<"UnitHistory"> | Date | string
    userId?: UuidNullableFilter<"UnitHistory"> | string | null
  }

  export type ProductUnitCreateWithoutHistoryInput = {
    id?: string
    serialNumber: string
    status?: $Enums.UnitStatus
    condition?: $Enums.UnitCondition
    purchaseDate?: Date | string | null
    lastServiceDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variant: ProductVariantCreateNestedOneWithoutUnitsInput
    assignedOrder?: OrderCreateNestedOneWithoutAssignedUnitsInput
    rentalItems?: RentalItemCreateNestedManyWithoutUnitInput
  }

  export type ProductUnitUncheckedCreateWithoutHistoryInput = {
    id?: string
    variantId: string
    serialNumber: string
    status?: $Enums.UnitStatus
    condition?: $Enums.UnitCondition
    assignedOrderId?: string | null
    purchaseDate?: Date | string | null
    lastServiceDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rentalItems?: RentalItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type ProductUnitCreateOrConnectWithoutHistoryInput = {
    where: ProductUnitWhereUniqueInput
    create: XOR<ProductUnitCreateWithoutHistoryInput, ProductUnitUncheckedCreateWithoutHistoryInput>
  }

  export type UserCreateWithoutUnitActionsInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionCreateNestedManyWithoutVerifiedByInput
    aiActionApprovals?: AiActionCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutUnitActionsInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogUncheckedCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogUncheckedCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceUncheckedCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryUncheckedCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageUncheckedCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalUncheckedCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutVerifiedByInput
    aiActionApprovals?: AiActionUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutUnitActionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUnitActionsInput, UserUncheckedCreateWithoutUnitActionsInput>
  }

  export type ProductUnitUpsertWithoutHistoryInput = {
    update: XOR<ProductUnitUpdateWithoutHistoryInput, ProductUnitUncheckedUpdateWithoutHistoryInput>
    create: XOR<ProductUnitCreateWithoutHistoryInput, ProductUnitUncheckedCreateWithoutHistoryInput>
    where?: ProductUnitWhereInput
  }

  export type ProductUnitUpdateToOneWithWhereWithoutHistoryInput = {
    where?: ProductUnitWhereInput
    data: XOR<ProductUnitUpdateWithoutHistoryInput, ProductUnitUncheckedUpdateWithoutHistoryInput>
  }

  export type ProductUnitUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    condition?: EnumUnitConditionFieldUpdateOperationsInput | $Enums.UnitCondition
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastServiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variant?: ProductVariantUpdateOneRequiredWithoutUnitsNestedInput
    assignedOrder?: OrderUpdateOneWithoutAssignedUnitsNestedInput
    rentalItems?: RentalItemUpdateManyWithoutUnitNestedInput
  }

  export type ProductUnitUncheckedUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    condition?: EnumUnitConditionFieldUpdateOperationsInput | $Enums.UnitCondition
    assignedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastServiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentalItems?: RentalItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UserUpsertWithoutUnitActionsInput = {
    update: XOR<UserUpdateWithoutUnitActionsInput, UserUncheckedUpdateWithoutUnitActionsInput>
    create: XOR<UserCreateWithoutUnitActionsInput, UserUncheckedCreateWithoutUnitActionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUnitActionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUnitActionsInput, UserUncheckedUpdateWithoutUnitActionsInput>
  }

  export type UserUpdateWithoutUnitActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUpdateManyWithoutVerifiedByNestedInput
    aiActionApprovals?: AiActionUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutUnitActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUncheckedUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUncheckedUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUncheckedUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUncheckedUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUncheckedUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUncheckedUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUncheckedUpdateManyWithoutVerifiedByNestedInput
    aiActionApprovals?: AiActionUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserCreateWithoutSystemNotificationsInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutSystemNotificationsInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogUncheckedCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogUncheckedCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceUncheckedCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryUncheckedCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageUncheckedCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalUncheckedCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryUncheckedCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutSystemNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSystemNotificationsInput, UserUncheckedCreateWithoutSystemNotificationsInput>
  }

  export type UserUpsertWithoutSystemNotificationsInput = {
    update: XOR<UserUpdateWithoutSystemNotificationsInput, UserUncheckedUpdateWithoutSystemNotificationsInput>
    create: XOR<UserCreateWithoutSystemNotificationsInput, UserUncheckedCreateWithoutSystemNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSystemNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSystemNotificationsInput, UserUncheckedUpdateWithoutSystemNotificationsInput>
  }

  export type UserUpdateWithoutSystemNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutSystemNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUncheckedUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUncheckedUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUncheckedUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUncheckedUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUncheckedUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUncheckedUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUncheckedUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUncheckedUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type OrderCreateWithoutRentalItemsInput = {
    id?: string
    orderNumber: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    totalAmount: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    paymentMethod?: string | null
    createdAt?: Date | string | null
    paymentStatus?: string | null
    paymentConfirmedAt?: Date | string | null
    deliveryAddress?: string | null
    invoices?: InvoiceCreateNestedManyWithoutOrderInput
    assignedUnits?: ProductUnitCreateNestedManyWithoutAssignedOrderInput
    users_orders_payment_confirmed_byTousers?: UserCreateNestedOneWithoutOrders_orders_payment_confirmed_byTousersInput
    user: UserCreateNestedOneWithoutOrdersInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutRentalItemsInput = {
    id?: string
    orderNumber: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    totalAmount: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    paymentMethod?: string | null
    createdAt?: Date | string | null
    userId: string
    paymentStatus?: string | null
    paymentConfirmedBy?: string | null
    paymentConfirmedAt?: Date | string | null
    deliveryAddress?: string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
    assignedUnits?: ProductUnitUncheckedCreateNestedManyWithoutAssignedOrderInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutRentalItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutRentalItemsInput, OrderUncheckedCreateWithoutRentalItemsInput>
  }

  export type RentalPackageCreateWithoutRentalItemsInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    price: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    duration: number
    createdAt?: Date | string | null
    images?: RentalPackageCreateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    rentalPackageItems?: RentalPackageItemCreateNestedManyWithoutRentalPackageInput
  }

  export type RentalPackageUncheckedCreateWithoutRentalItemsInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    price: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    duration: number
    createdAt?: Date | string | null
    images?: RentalPackageCreateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    rentalPackageItems?: RentalPackageItemUncheckedCreateNestedManyWithoutRentalPackageInput
  }

  export type RentalPackageCreateOrConnectWithoutRentalItemsInput = {
    where: RentalPackageWhereUniqueInput
    create: XOR<RentalPackageCreateWithoutRentalItemsInput, RentalPackageUncheckedCreateWithoutRentalItemsInput>
  }

  export type ProductVariantCreateWithoutRentalItemsInput = {
    id?: string
    color?: string
    sku: string
    monthlyPrice?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
    units?: ProductUnitCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutRentalItemsInput = {
    id?: string
    productId: string
    color?: string
    sku: string
    monthlyPrice?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: ProductUnitUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutRentalItemsInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutRentalItemsInput, ProductVariantUncheckedCreateWithoutRentalItemsInput>
  }

  export type ProductUnitCreateWithoutRentalItemsInput = {
    id?: string
    serialNumber: string
    status?: $Enums.UnitStatus
    condition?: $Enums.UnitCondition
    purchaseDate?: Date | string | null
    lastServiceDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variant: ProductVariantCreateNestedOneWithoutUnitsInput
    assignedOrder?: OrderCreateNestedOneWithoutAssignedUnitsInput
    history?: UnitHistoryCreateNestedManyWithoutUnitInput
  }

  export type ProductUnitUncheckedCreateWithoutRentalItemsInput = {
    id?: string
    variantId: string
    serialNumber: string
    status?: $Enums.UnitStatus
    condition?: $Enums.UnitCondition
    assignedOrderId?: string | null
    purchaseDate?: Date | string | null
    lastServiceDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    history?: UnitHistoryUncheckedCreateNestedManyWithoutUnitInput
  }

  export type ProductUnitCreateOrConnectWithoutRentalItemsInput = {
    where: ProductUnitWhereUniqueInput
    create: XOR<ProductUnitCreateWithoutRentalItemsInput, ProductUnitUncheckedCreateWithoutRentalItemsInput>
  }

  export type DeliveryItemCreateWithoutRentalItemInput = {
    id?: string
    quantity: number
    delivery: DeliveryCreateNestedOneWithoutItemsInput
  }

  export type DeliveryItemUncheckedCreateWithoutRentalItemInput = {
    id?: string
    deliveryId: string
    quantity: number
  }

  export type DeliveryItemCreateOrConnectWithoutRentalItemInput = {
    where: DeliveryItemWhereUniqueInput
    create: XOR<DeliveryItemCreateWithoutRentalItemInput, DeliveryItemUncheckedCreateWithoutRentalItemInput>
  }

  export type DeliveryItemCreateManyRentalItemInputEnvelope = {
    data: DeliveryItemCreateManyRentalItemInput | DeliveryItemCreateManyRentalItemInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithoutRentalItemsInput = {
    update: XOR<OrderUpdateWithoutRentalItemsInput, OrderUncheckedUpdateWithoutRentalItemsInput>
    create: XOR<OrderCreateWithoutRentalItemsInput, OrderUncheckedCreateWithoutRentalItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutRentalItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutRentalItemsInput, OrderUncheckedUpdateWithoutRentalItemsInput>
  }

  export type OrderUpdateWithoutRentalItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUpdateManyWithoutOrderNestedInput
    assignedUnits?: ProductUnitUpdateManyWithoutAssignedOrderNestedInput
    users_orders_payment_confirmed_byTousers?: UserUpdateOneWithoutOrders_orders_payment_confirmed_byTousersNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutRentalItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
    assignedUnits?: ProductUnitUncheckedUpdateManyWithoutAssignedOrderNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type RentalPackageUpsertWithoutRentalItemsInput = {
    update: XOR<RentalPackageUpdateWithoutRentalItemsInput, RentalPackageUncheckedUpdateWithoutRentalItemsInput>
    create: XOR<RentalPackageCreateWithoutRentalItemsInput, RentalPackageUncheckedCreateWithoutRentalItemsInput>
    where?: RentalPackageWhereInput
  }

  export type RentalPackageUpdateToOneWithWhereWithoutRentalItemsInput = {
    where?: RentalPackageWhereInput
    data: XOR<RentalPackageUpdateWithoutRentalItemsInput, RentalPackageUncheckedUpdateWithoutRentalItemsInput>
  }

  export type RentalPackageUpdateWithoutRentalItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: RentalPackageUpdateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    rentalPackageItems?: RentalPackageItemUpdateManyWithoutRentalPackageNestedInput
  }

  export type RentalPackageUncheckedUpdateWithoutRentalItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: RentalPackageUpdateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    rentalPackageItems?: RentalPackageItemUncheckedUpdateManyWithoutRentalPackageNestedInput
  }

  export type ProductVariantUpsertWithoutRentalItemsInput = {
    update: XOR<ProductVariantUpdateWithoutRentalItemsInput, ProductVariantUncheckedUpdateWithoutRentalItemsInput>
    create: XOR<ProductVariantCreateWithoutRentalItemsInput, ProductVariantUncheckedCreateWithoutRentalItemsInput>
    where?: ProductVariantWhereInput
  }

  export type ProductVariantUpdateToOneWithWhereWithoutRentalItemsInput = {
    where?: ProductVariantWhereInput
    data: XOR<ProductVariantUpdateWithoutRentalItemsInput, ProductVariantUncheckedUpdateWithoutRentalItemsInput>
  }

  export type ProductVariantUpdateWithoutRentalItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    units?: ProductUnitUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutRentalItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: ProductUnitUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type ProductUnitUpsertWithoutRentalItemsInput = {
    update: XOR<ProductUnitUpdateWithoutRentalItemsInput, ProductUnitUncheckedUpdateWithoutRentalItemsInput>
    create: XOR<ProductUnitCreateWithoutRentalItemsInput, ProductUnitUncheckedCreateWithoutRentalItemsInput>
    where?: ProductUnitWhereInput
  }

  export type ProductUnitUpdateToOneWithWhereWithoutRentalItemsInput = {
    where?: ProductUnitWhereInput
    data: XOR<ProductUnitUpdateWithoutRentalItemsInput, ProductUnitUncheckedUpdateWithoutRentalItemsInput>
  }

  export type ProductUnitUpdateWithoutRentalItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    condition?: EnumUnitConditionFieldUpdateOperationsInput | $Enums.UnitCondition
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastServiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variant?: ProductVariantUpdateOneRequiredWithoutUnitsNestedInput
    assignedOrder?: OrderUpdateOneWithoutAssignedUnitsNestedInput
    history?: UnitHistoryUpdateManyWithoutUnitNestedInput
  }

  export type ProductUnitUncheckedUpdateWithoutRentalItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    condition?: EnumUnitConditionFieldUpdateOperationsInput | $Enums.UnitCondition
    assignedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastServiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: UnitHistoryUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type DeliveryItemUpsertWithWhereUniqueWithoutRentalItemInput = {
    where: DeliveryItemWhereUniqueInput
    update: XOR<DeliveryItemUpdateWithoutRentalItemInput, DeliveryItemUncheckedUpdateWithoutRentalItemInput>
    create: XOR<DeliveryItemCreateWithoutRentalItemInput, DeliveryItemUncheckedCreateWithoutRentalItemInput>
  }

  export type DeliveryItemUpdateWithWhereUniqueWithoutRentalItemInput = {
    where: DeliveryItemWhereUniqueInput
    data: XOR<DeliveryItemUpdateWithoutRentalItemInput, DeliveryItemUncheckedUpdateWithoutRentalItemInput>
  }

  export type DeliveryItemUpdateManyWithWhereWithoutRentalItemInput = {
    where: DeliveryItemScalarWhereInput
    data: XOR<DeliveryItemUpdateManyMutationInput, DeliveryItemUncheckedUpdateManyWithoutRentalItemInput>
  }

  export type DeliveryItemScalarWhereInput = {
    AND?: DeliveryItemScalarWhereInput | DeliveryItemScalarWhereInput[]
    OR?: DeliveryItemScalarWhereInput[]
    NOT?: DeliveryItemScalarWhereInput | DeliveryItemScalarWhereInput[]
    id?: UuidFilter<"DeliveryItem"> | string
    deliveryId?: UuidFilter<"DeliveryItem"> | string
    rentalItemId?: UuidFilter<"DeliveryItem"> | string
    quantity?: IntFilter<"DeliveryItem"> | number
  }

  export type ActivityLogCreateWithoutUserInput = {
    id?: string
    action: string
    entity: string
    details?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entity: string
    details?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogCreateManyUserInputEnvelope = {
    data: ActivityLogCreateManyUserInput | ActivityLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InventorySyncLogCreateWithoutResolvedByUserInput = {
    id?: string
    oldQuantity: number
    newQuantity: number
    source: $Enums.inventory_source
    conflict?: boolean | null
    resolved?: boolean | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string | null
    product: ProductCreateNestedOneWithoutInventorySyncLogsInput
    updatedByUser: UserCreateNestedOneWithoutInventoryUpdatesInput
  }

  export type InventorySyncLogUncheckedCreateWithoutResolvedByUserInput = {
    id?: string
    productId: string
    oldQuantity: number
    newQuantity: number
    updatedBy: string
    source: $Enums.inventory_source
    conflict?: boolean | null
    resolved?: boolean | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string | null
  }

  export type InventorySyncLogCreateOrConnectWithoutResolvedByUserInput = {
    where: InventorySyncLogWhereUniqueInput
    create: XOR<InventorySyncLogCreateWithoutResolvedByUserInput, InventorySyncLogUncheckedCreateWithoutResolvedByUserInput>
  }

  export type InventorySyncLogCreateManyResolvedByUserInputEnvelope = {
    data: InventorySyncLogCreateManyResolvedByUserInput | InventorySyncLogCreateManyResolvedByUserInput[]
    skipDuplicates?: boolean
  }

  export type InventorySyncLogCreateWithoutUpdatedByUserInput = {
    id?: string
    oldQuantity: number
    newQuantity: number
    source: $Enums.inventory_source
    conflict?: boolean | null
    resolved?: boolean | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string | null
    product: ProductCreateNestedOneWithoutInventorySyncLogsInput
    resolvedByUser?: UserCreateNestedOneWithoutInventoryResolutionsInput
  }

  export type InventorySyncLogUncheckedCreateWithoutUpdatedByUserInput = {
    id?: string
    productId: string
    oldQuantity: number
    newQuantity: number
    source: $Enums.inventory_source
    conflict?: boolean | null
    resolved?: boolean | null
    resolvedBy?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string | null
  }

  export type InventorySyncLogCreateOrConnectWithoutUpdatedByUserInput = {
    where: InventorySyncLogWhereUniqueInput
    create: XOR<InventorySyncLogCreateWithoutUpdatedByUserInput, InventorySyncLogUncheckedCreateWithoutUpdatedByUserInput>
  }

  export type InventorySyncLogCreateManyUpdatedByUserInputEnvelope = {
    data: InventorySyncLogCreateManyUpdatedByUserInput | InventorySyncLogCreateManyUpdatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutUserInput = {
    id?: string
    invoiceNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string | null
    createdAt?: Date | string | null
    status?: string
    guestEmail?: string | null
    guestName?: string | null
    guestWhatsapp?: string | null
    guestAddress?: string | null
    deliveryFeeOverride?: Decimal | DecimalJsLike | number | string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    shareableToken?: string | null
    emailSent?: boolean | null
    emailSentAt?: Date | string | null
    order?: OrderCreateNestedOneWithoutInvoicesInput
    deliveries?: DeliveryCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutUserInput = {
    id?: string
    invoiceNumber: string
    orderId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string | null
    createdAt?: Date | string | null
    status?: string
    guestEmail?: string | null
    guestName?: string | null
    guestWhatsapp?: string | null
    guestAddress?: string | null
    deliveryFeeOverride?: Decimal | DecimalJsLike | number | string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    shareableToken?: string | null
    emailSent?: boolean | null
    emailSentAt?: Date | string | null
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput>
  }

  export type InvoiceCreateManyUserInputEnvelope = {
    data: InvoiceCreateManyUserInput | InvoiceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutUsers_orders_payment_confirmed_byTousersInput = {
    id?: string
    orderNumber: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    totalAmount: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    paymentMethod?: string | null
    createdAt?: Date | string | null
    paymentStatus?: string | null
    paymentConfirmedAt?: Date | string | null
    deliveryAddress?: string | null
    invoices?: InvoiceCreateNestedManyWithoutOrderInput
    assignedUnits?: ProductUnitCreateNestedManyWithoutAssignedOrderInput
    user: UserCreateNestedOneWithoutOrdersInput
    rentalItems?: RentalItemCreateNestedManyWithoutOrderInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUsers_orders_payment_confirmed_byTousersInput = {
    id?: string
    orderNumber: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    totalAmount: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    paymentMethod?: string | null
    createdAt?: Date | string | null
    userId: string
    paymentStatus?: string | null
    paymentConfirmedAt?: Date | string | null
    deliveryAddress?: string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
    assignedUnits?: ProductUnitUncheckedCreateNestedManyWithoutAssignedOrderInput
    rentalItems?: RentalItemUncheckedCreateNestedManyWithoutOrderInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUsers_orders_payment_confirmed_byTousersInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUsers_orders_payment_confirmed_byTousersInput, OrderUncheckedCreateWithoutUsers_orders_payment_confirmed_byTousersInput>
  }

  export type OrderCreateManyUsers_orders_payment_confirmed_byTousersInputEnvelope = {
    data: OrderCreateManyUsers_orders_payment_confirmed_byTousersInput | OrderCreateManyUsers_orders_payment_confirmed_byTousersInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutUserInput = {
    id?: string
    orderNumber: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    totalAmount: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    paymentMethod?: string | null
    createdAt?: Date | string | null
    paymentStatus?: string | null
    paymentConfirmedAt?: Date | string | null
    deliveryAddress?: string | null
    invoices?: InvoiceCreateNestedManyWithoutOrderInput
    assignedUnits?: ProductUnitCreateNestedManyWithoutAssignedOrderInput
    users_orders_payment_confirmed_byTousers?: UserCreateNestedOneWithoutOrders_orders_payment_confirmed_byTousersInput
    rentalItems?: RentalItemCreateNestedManyWithoutOrderInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: string
    orderNumber: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    totalAmount: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    paymentMethod?: string | null
    createdAt?: Date | string | null
    paymentStatus?: string | null
    paymentConfirmedBy?: string | null
    paymentConfirmedAt?: Date | string | null
    deliveryAddress?: string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
    assignedUnits?: ProductUnitUncheckedCreateNestedManyWithoutAssignedOrderInput
    rentalItems?: RentalItemUncheckedCreateNestedManyWithoutOrderInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkerAttendanceCreateWithoutWorkerInput = {
    id?: string
    date: Date | string
    status?: $Enums.attendance_status | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    notes?: string | null
    createdAt?: Date | string | null
  }

  export type WorkerAttendanceUncheckedCreateWithoutWorkerInput = {
    id?: string
    date: Date | string
    status?: $Enums.attendance_status | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    notes?: string | null
    createdAt?: Date | string | null
  }

  export type WorkerAttendanceCreateOrConnectWithoutWorkerInput = {
    where: WorkerAttendanceWhereUniqueInput
    create: XOR<WorkerAttendanceCreateWithoutWorkerInput, WorkerAttendanceUncheckedCreateWithoutWorkerInput>
  }

  export type WorkerAttendanceCreateManyWorkerInputEnvelope = {
    data: WorkerAttendanceCreateManyWorkerInput | WorkerAttendanceCreateManyWorkerInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryCreateWithoutClaimedByWorkerInput = {
    id?: string
    deliveryMethod: $Enums.DeliveryMethod
    deliveryType: $Enums.DeliveryType
    status?: $Enums.DeliveryStatus
    claimedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    eta?: Date | string | null
    etaOverrideCount?: number
    delayMinutes?: number
    latitude?: number | null
    longitude?: number | null
    lastLocationUpdate?: Date | string | null
    trackingCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutDeliveriesInput
    vehicle?: VehicleCreateNestedOneWithoutDeliveriesInput
    items?: DeliveryItemCreateNestedManyWithoutDeliveryInput
    logs?: DeliveryLogCreateNestedManyWithoutDeliveryInput
    editLogs?: DeliveryEditLogCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateWithoutClaimedByWorkerInput = {
    id?: string
    invoiceId?: string | null
    deliveryMethod: $Enums.DeliveryMethod
    deliveryType: $Enums.DeliveryType
    vehicleId?: string | null
    status?: $Enums.DeliveryStatus
    claimedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    eta?: Date | string | null
    etaOverrideCount?: number
    delayMinutes?: number
    latitude?: number | null
    longitude?: number | null
    lastLocationUpdate?: Date | string | null
    trackingCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: DeliveryItemUncheckedCreateNestedManyWithoutDeliveryInput
    logs?: DeliveryLogUncheckedCreateNestedManyWithoutDeliveryInput
    editLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryCreateOrConnectWithoutClaimedByWorkerInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutClaimedByWorkerInput, DeliveryUncheckedCreateWithoutClaimedByWorkerInput>
  }

  export type DeliveryCreateManyClaimedByWorkerInputEnvelope = {
    data: DeliveryCreateManyClaimedByWorkerInput | DeliveryCreateManyClaimedByWorkerInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryLogCreateWithoutCreatedByUserInput = {
    id?: string
    eventType: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    role: $Enums.DeliveryRole
    createdAt?: Date | string
    delivery: DeliveryCreateNestedOneWithoutLogsInput
  }

  export type DeliveryLogUncheckedCreateWithoutCreatedByUserInput = {
    id?: string
    deliveryId: string
    eventType: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    role: $Enums.DeliveryRole
    createdAt?: Date | string
  }

  export type DeliveryLogCreateOrConnectWithoutCreatedByUserInput = {
    where: DeliveryLogWhereUniqueInput
    create: XOR<DeliveryLogCreateWithoutCreatedByUserInput, DeliveryLogUncheckedCreateWithoutCreatedByUserInput>
  }

  export type DeliveryLogCreateManyCreatedByUserInputEnvelope = {
    data: DeliveryLogCreateManyCreatedByUserInput | DeliveryLogCreateManyCreatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryEditLogCreateWithoutEditedByUserInput = {
    id?: string
    role: $Enums.DeliveryRole
    fieldChanged: string
    oldValue?: string | null
    newValue?: string | null
    reason?: string | null
    createdAt?: Date | string
    delivery: DeliveryCreateNestedOneWithoutEditLogsInput
  }

  export type DeliveryEditLogUncheckedCreateWithoutEditedByUserInput = {
    id?: string
    deliveryId: string
    role: $Enums.DeliveryRole
    fieldChanged: string
    oldValue?: string | null
    newValue?: string | null
    reason?: string | null
    createdAt?: Date | string
  }

  export type DeliveryEditLogCreateOrConnectWithoutEditedByUserInput = {
    where: DeliveryEditLogWhereUniqueInput
    create: XOR<DeliveryEditLogCreateWithoutEditedByUserInput, DeliveryEditLogUncheckedCreateWithoutEditedByUserInput>
  }

  export type DeliveryEditLogCreateManyEditedByUserInputEnvelope = {
    data: DeliveryEditLogCreateManyEditedByUserInput | DeliveryEditLogCreateManyEditedByUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkerNotificationCreateWithoutFromAdminInput = {
    id?: string
    type: string
    title: string
    message: string
    isRead?: boolean | null
    createdAt?: Date | string | null
    worker: UserCreateNestedOneWithoutReceivedNotificationsInput
  }

  export type WorkerNotificationUncheckedCreateWithoutFromAdminInput = {
    id?: string
    workerId: string
    type: string
    title: string
    message: string
    isRead?: boolean | null
    createdAt?: Date | string | null
  }

  export type WorkerNotificationCreateOrConnectWithoutFromAdminInput = {
    where: WorkerNotificationWhereUniqueInput
    create: XOR<WorkerNotificationCreateWithoutFromAdminInput, WorkerNotificationUncheckedCreateWithoutFromAdminInput>
  }

  export type WorkerNotificationCreateManyFromAdminInputEnvelope = {
    data: WorkerNotificationCreateManyFromAdminInput | WorkerNotificationCreateManyFromAdminInput[]
    skipDuplicates?: boolean
  }

  export type WorkerNotificationCreateWithoutWorkerInput = {
    id?: string
    type: string
    title: string
    message: string
    isRead?: boolean | null
    createdAt?: Date | string | null
    fromAdmin?: UserCreateNestedOneWithoutSentNotificationsInput
  }

  export type WorkerNotificationUncheckedCreateWithoutWorkerInput = {
    id?: string
    fromAdminId?: string | null
    type: string
    title: string
    message: string
    isRead?: boolean | null
    createdAt?: Date | string | null
  }

  export type WorkerNotificationCreateOrConnectWithoutWorkerInput = {
    where: WorkerNotificationWhereUniqueInput
    create: XOR<WorkerNotificationCreateWithoutWorkerInput, WorkerNotificationUncheckedCreateWithoutWorkerInput>
  }

  export type WorkerNotificationCreateManyWorkerInputEnvelope = {
    data: WorkerNotificationCreateManyWorkerInput | WorkerNotificationCreateManyWorkerInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    receiverId: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutReceiverInput = {
    id?: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutReceiverInput = {
    id?: string
    senderId: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageCreateManyReceiverInputEnvelope = {
    data: MessageCreateManyReceiverInput | MessageCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type ChatGroupMemberCreateWithoutUserInput = {
    id?: string
    role?: string
    joinedAt?: Date | string
    group: ChatGroupCreateNestedOneWithoutMembersInput
  }

  export type ChatGroupMemberUncheckedCreateWithoutUserInput = {
    id?: string
    groupId: string
    role?: string
    joinedAt?: Date | string
  }

  export type ChatGroupMemberCreateOrConnectWithoutUserInput = {
    where: ChatGroupMemberWhereUniqueInput
    create: XOR<ChatGroupMemberCreateWithoutUserInput, ChatGroupMemberUncheckedCreateWithoutUserInput>
  }

  export type ChatGroupMemberCreateManyUserInputEnvelope = {
    data: ChatGroupMemberCreateManyUserInput | ChatGroupMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GroupMessageCreateWithoutSenderInput = {
    id?: string
    content: string
    createdAt?: Date | string
    group: ChatGroupCreateNestedOneWithoutMessagesInput
  }

  export type GroupMessageUncheckedCreateWithoutSenderInput = {
    id?: string
    groupId: string
    content: string
    createdAt?: Date | string
  }

  export type GroupMessageCreateOrConnectWithoutSenderInput = {
    where: GroupMessageWhereUniqueInput
    create: XOR<GroupMessageCreateWithoutSenderInput, GroupMessageUncheckedCreateWithoutSenderInput>
  }

  export type GroupMessageCreateManySenderInputEnvelope = {
    data: GroupMessageCreateManySenderInput | GroupMessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type NotificationDismissalCreateWithoutUserInput = {
    id?: string
    entityId: string
    entityType: string
    createdAt?: Date | string
  }

  export type NotificationDismissalUncheckedCreateWithoutUserInput = {
    id?: string
    entityId: string
    entityType: string
    createdAt?: Date | string
  }

  export type NotificationDismissalCreateOrConnectWithoutUserInput = {
    where: NotificationDismissalWhereUniqueInput
    create: XOR<NotificationDismissalCreateWithoutUserInput, NotificationDismissalUncheckedCreateWithoutUserInput>
  }

  export type NotificationDismissalCreateManyUserInputEnvelope = {
    data: NotificationDismissalCreateManyUserInput | NotificationDismissalCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SystemNotificationCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    isRead?: boolean
    entityId?: string | null
    entityType?: string | null
    relatedType?: string | null
    createdAt?: Date | string | null
  }

  export type SystemNotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    isRead?: boolean
    entityId?: string | null
    entityType?: string | null
    relatedType?: string | null
    createdAt?: Date | string | null
  }

  export type SystemNotificationCreateOrConnectWithoutUserInput = {
    where: SystemNotificationWhereUniqueInput
    create: XOR<SystemNotificationCreateWithoutUserInput, SystemNotificationUncheckedCreateWithoutUserInput>
  }

  export type SystemNotificationCreateManyUserInputEnvelope = {
    data: SystemNotificationCreateManyUserInput | SystemNotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentTransactionCreateWithoutVerifiedByInput = {
    id?: string
    provider: $Enums.PaymentProvider
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.TransactionStatus
    externalReferenceId?: string | null
    proofUrl?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutPaymentTransactionsInput
  }

  export type PaymentTransactionUncheckedCreateWithoutVerifiedByInput = {
    id?: string
    orderId: string
    provider: $Enums.PaymentProvider
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.TransactionStatus
    externalReferenceId?: string | null
    proofUrl?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentTransactionCreateOrConnectWithoutVerifiedByInput = {
    where: PaymentTransactionWhereUniqueInput
    create: XOR<PaymentTransactionCreateWithoutVerifiedByInput, PaymentTransactionUncheckedCreateWithoutVerifiedByInput>
  }

  export type PaymentTransactionCreateManyVerifiedByInputEnvelope = {
    data: PaymentTransactionCreateManyVerifiedByInput | PaymentTransactionCreateManyVerifiedByInput[]
    skipDuplicates?: boolean
  }

  export type UnitHistoryCreateWithoutUserInput = {
    id?: string
    oldStatus?: string | null
    newStatus: string
    oldCondition?: string | null
    newCondition?: string | null
    details?: string | null
    createdAt?: Date | string
    unit: ProductUnitCreateNestedOneWithoutHistoryInput
  }

  export type UnitHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    unitId: string
    oldStatus?: string | null
    newStatus: string
    oldCondition?: string | null
    newCondition?: string | null
    details?: string | null
    createdAt?: Date | string
  }

  export type UnitHistoryCreateOrConnectWithoutUserInput = {
    where: UnitHistoryWhereUniqueInput
    create: XOR<UnitHistoryCreateWithoutUserInput, UnitHistoryUncheckedCreateWithoutUserInput>
  }

  export type UnitHistoryCreateManyUserInputEnvelope = {
    data: UnitHistoryCreateManyUserInput | UnitHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AiActionCreateWithoutApproverInput = {
    id?: string
    actionType: string
    payloadBefore?: NullableJsonNullValueInput | InputJsonValue
    payloadAfter: JsonNullValueInput | InputJsonValue
    status?: $Enums.AiActionStatus
    createdAt?: Date | string
    executedAt?: Date | string | null
    agent: AiAgentCreateNestedOneWithoutActionsInput
  }

  export type AiActionUncheckedCreateWithoutApproverInput = {
    id?: string
    agentId: string
    actionType: string
    payloadBefore?: NullableJsonNullValueInput | InputJsonValue
    payloadAfter: JsonNullValueInput | InputJsonValue
    status?: $Enums.AiActionStatus
    createdAt?: Date | string
    executedAt?: Date | string | null
  }

  export type AiActionCreateOrConnectWithoutApproverInput = {
    where: AiActionWhereUniqueInput
    create: XOR<AiActionCreateWithoutApproverInput, AiActionUncheckedCreateWithoutApproverInput>
  }

  export type AiActionCreateManyApproverInputEnvelope = {
    data: AiActionCreateManyApproverInput | AiActionCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutUserInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutUserInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: UuidFilter<"ActivityLog"> | string
    action?: StringFilter<"ActivityLog"> | string
    entity?: StringFilter<"ActivityLog"> | string
    details?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    userId?: UuidNullableFilter<"ActivityLog"> | string | null
  }

  export type InventorySyncLogUpsertWithWhereUniqueWithoutResolvedByUserInput = {
    where: InventorySyncLogWhereUniqueInput
    update: XOR<InventorySyncLogUpdateWithoutResolvedByUserInput, InventorySyncLogUncheckedUpdateWithoutResolvedByUserInput>
    create: XOR<InventorySyncLogCreateWithoutResolvedByUserInput, InventorySyncLogUncheckedCreateWithoutResolvedByUserInput>
  }

  export type InventorySyncLogUpdateWithWhereUniqueWithoutResolvedByUserInput = {
    where: InventorySyncLogWhereUniqueInput
    data: XOR<InventorySyncLogUpdateWithoutResolvedByUserInput, InventorySyncLogUncheckedUpdateWithoutResolvedByUserInput>
  }

  export type InventorySyncLogUpdateManyWithWhereWithoutResolvedByUserInput = {
    where: InventorySyncLogScalarWhereInput
    data: XOR<InventorySyncLogUpdateManyMutationInput, InventorySyncLogUncheckedUpdateManyWithoutResolvedByUserInput>
  }

  export type InventorySyncLogUpsertWithWhereUniqueWithoutUpdatedByUserInput = {
    where: InventorySyncLogWhereUniqueInput
    update: XOR<InventorySyncLogUpdateWithoutUpdatedByUserInput, InventorySyncLogUncheckedUpdateWithoutUpdatedByUserInput>
    create: XOR<InventorySyncLogCreateWithoutUpdatedByUserInput, InventorySyncLogUncheckedCreateWithoutUpdatedByUserInput>
  }

  export type InventorySyncLogUpdateWithWhereUniqueWithoutUpdatedByUserInput = {
    where: InventorySyncLogWhereUniqueInput
    data: XOR<InventorySyncLogUpdateWithoutUpdatedByUserInput, InventorySyncLogUncheckedUpdateWithoutUpdatedByUserInput>
  }

  export type InventorySyncLogUpdateManyWithWhereWithoutUpdatedByUserInput = {
    where: InventorySyncLogScalarWhereInput
    data: XOR<InventorySyncLogUpdateManyMutationInput, InventorySyncLogUncheckedUpdateManyWithoutUpdatedByUserInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutUserInput, InvoiceUncheckedUpdateWithoutUserInput>
    create: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutUserInput, InvoiceUncheckedUpdateWithoutUserInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutUserInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutUsers_orders_payment_confirmed_byTousersInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUsers_orders_payment_confirmed_byTousersInput, OrderUncheckedUpdateWithoutUsers_orders_payment_confirmed_byTousersInput>
    create: XOR<OrderCreateWithoutUsers_orders_payment_confirmed_byTousersInput, OrderUncheckedCreateWithoutUsers_orders_payment_confirmed_byTousersInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUsers_orders_payment_confirmed_byTousersInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUsers_orders_payment_confirmed_byTousersInput, OrderUncheckedUpdateWithoutUsers_orders_payment_confirmed_byTousersInput>
  }

  export type OrderUpdateManyWithWhereWithoutUsers_orders_payment_confirmed_byTousersInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUsers_orders_payment_confirmed_byTousersInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: UuidFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    status?: StringFilter<"Order"> | string
    startDate?: DateTimeFilter<"Order"> | Date | string
    endDate?: DateTimeFilter<"Order"> | Date | string
    duration?: IntFilter<"Order"> | number
    totalAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    discountPercentage?: IntNullableFilter<"Order"> | number | null
    discountAmount?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"Order"> | string | null
    paymentMethod?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    userId?: UuidFilter<"Order"> | string
    paymentStatus?: StringNullableFilter<"Order"> | string | null
    paymentConfirmedBy?: UuidNullableFilter<"Order"> | string | null
    paymentConfirmedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveryAddress?: StringNullableFilter<"Order"> | string | null
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkerAttendanceUpsertWithWhereUniqueWithoutWorkerInput = {
    where: WorkerAttendanceWhereUniqueInput
    update: XOR<WorkerAttendanceUpdateWithoutWorkerInput, WorkerAttendanceUncheckedUpdateWithoutWorkerInput>
    create: XOR<WorkerAttendanceCreateWithoutWorkerInput, WorkerAttendanceUncheckedCreateWithoutWorkerInput>
  }

  export type WorkerAttendanceUpdateWithWhereUniqueWithoutWorkerInput = {
    where: WorkerAttendanceWhereUniqueInput
    data: XOR<WorkerAttendanceUpdateWithoutWorkerInput, WorkerAttendanceUncheckedUpdateWithoutWorkerInput>
  }

  export type WorkerAttendanceUpdateManyWithWhereWithoutWorkerInput = {
    where: WorkerAttendanceScalarWhereInput
    data: XOR<WorkerAttendanceUpdateManyMutationInput, WorkerAttendanceUncheckedUpdateManyWithoutWorkerInput>
  }

  export type WorkerAttendanceScalarWhereInput = {
    AND?: WorkerAttendanceScalarWhereInput | WorkerAttendanceScalarWhereInput[]
    OR?: WorkerAttendanceScalarWhereInput[]
    NOT?: WorkerAttendanceScalarWhereInput | WorkerAttendanceScalarWhereInput[]
    id?: UuidFilter<"WorkerAttendance"> | string
    workerId?: UuidFilter<"WorkerAttendance"> | string
    date?: DateTimeFilter<"WorkerAttendance"> | Date | string
    status?: Enumattendance_statusNullableFilter<"WorkerAttendance"> | $Enums.attendance_status | null
    checkInTime?: DateTimeNullableFilter<"WorkerAttendance"> | Date | string | null
    checkOutTime?: DateTimeNullableFilter<"WorkerAttendance"> | Date | string | null
    notes?: StringNullableFilter<"WorkerAttendance"> | string | null
    createdAt?: DateTimeNullableFilter<"WorkerAttendance"> | Date | string | null
  }

  export type DeliveryUpsertWithWhereUniqueWithoutClaimedByWorkerInput = {
    where: DeliveryWhereUniqueInput
    update: XOR<DeliveryUpdateWithoutClaimedByWorkerInput, DeliveryUncheckedUpdateWithoutClaimedByWorkerInput>
    create: XOR<DeliveryCreateWithoutClaimedByWorkerInput, DeliveryUncheckedCreateWithoutClaimedByWorkerInput>
  }

  export type DeliveryUpdateWithWhereUniqueWithoutClaimedByWorkerInput = {
    where: DeliveryWhereUniqueInput
    data: XOR<DeliveryUpdateWithoutClaimedByWorkerInput, DeliveryUncheckedUpdateWithoutClaimedByWorkerInput>
  }

  export type DeliveryUpdateManyWithWhereWithoutClaimedByWorkerInput = {
    where: DeliveryScalarWhereInput
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyWithoutClaimedByWorkerInput>
  }

  export type DeliveryLogUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: DeliveryLogWhereUniqueInput
    update: XOR<DeliveryLogUpdateWithoutCreatedByUserInput, DeliveryLogUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<DeliveryLogCreateWithoutCreatedByUserInput, DeliveryLogUncheckedCreateWithoutCreatedByUserInput>
  }

  export type DeliveryLogUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: DeliveryLogWhereUniqueInput
    data: XOR<DeliveryLogUpdateWithoutCreatedByUserInput, DeliveryLogUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type DeliveryLogUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: DeliveryLogScalarWhereInput
    data: XOR<DeliveryLogUpdateManyMutationInput, DeliveryLogUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type DeliveryLogScalarWhereInput = {
    AND?: DeliveryLogScalarWhereInput | DeliveryLogScalarWhereInput[]
    OR?: DeliveryLogScalarWhereInput[]
    NOT?: DeliveryLogScalarWhereInput | DeliveryLogScalarWhereInput[]
    id?: UuidFilter<"DeliveryLog"> | string
    deliveryId?: UuidFilter<"DeliveryLog"> | string
    eventType?: StringFilter<"DeliveryLog"> | string
    oldValue?: JsonNullableFilter<"DeliveryLog">
    newValue?: JsonNullableFilter<"DeliveryLog">
    createdByUserId?: UuidNullableFilter<"DeliveryLog"> | string | null
    role?: EnumDeliveryRoleFilter<"DeliveryLog"> | $Enums.DeliveryRole
    createdAt?: DateTimeFilter<"DeliveryLog"> | Date | string
  }

  export type DeliveryEditLogUpsertWithWhereUniqueWithoutEditedByUserInput = {
    where: DeliveryEditLogWhereUniqueInput
    update: XOR<DeliveryEditLogUpdateWithoutEditedByUserInput, DeliveryEditLogUncheckedUpdateWithoutEditedByUserInput>
    create: XOR<DeliveryEditLogCreateWithoutEditedByUserInput, DeliveryEditLogUncheckedCreateWithoutEditedByUserInput>
  }

  export type DeliveryEditLogUpdateWithWhereUniqueWithoutEditedByUserInput = {
    where: DeliveryEditLogWhereUniqueInput
    data: XOR<DeliveryEditLogUpdateWithoutEditedByUserInput, DeliveryEditLogUncheckedUpdateWithoutEditedByUserInput>
  }

  export type DeliveryEditLogUpdateManyWithWhereWithoutEditedByUserInput = {
    where: DeliveryEditLogScalarWhereInput
    data: XOR<DeliveryEditLogUpdateManyMutationInput, DeliveryEditLogUncheckedUpdateManyWithoutEditedByUserInput>
  }

  export type DeliveryEditLogScalarWhereInput = {
    AND?: DeliveryEditLogScalarWhereInput | DeliveryEditLogScalarWhereInput[]
    OR?: DeliveryEditLogScalarWhereInput[]
    NOT?: DeliveryEditLogScalarWhereInput | DeliveryEditLogScalarWhereInput[]
    id?: UuidFilter<"DeliveryEditLog"> | string
    deliveryId?: UuidFilter<"DeliveryEditLog"> | string
    editedByUserId?: UuidFilter<"DeliveryEditLog"> | string
    role?: EnumDeliveryRoleFilter<"DeliveryEditLog"> | $Enums.DeliveryRole
    fieldChanged?: StringFilter<"DeliveryEditLog"> | string
    oldValue?: StringNullableFilter<"DeliveryEditLog"> | string | null
    newValue?: StringNullableFilter<"DeliveryEditLog"> | string | null
    reason?: StringNullableFilter<"DeliveryEditLog"> | string | null
    createdAt?: DateTimeFilter<"DeliveryEditLog"> | Date | string
  }

  export type WorkerNotificationUpsertWithWhereUniqueWithoutFromAdminInput = {
    where: WorkerNotificationWhereUniqueInput
    update: XOR<WorkerNotificationUpdateWithoutFromAdminInput, WorkerNotificationUncheckedUpdateWithoutFromAdminInput>
    create: XOR<WorkerNotificationCreateWithoutFromAdminInput, WorkerNotificationUncheckedCreateWithoutFromAdminInput>
  }

  export type WorkerNotificationUpdateWithWhereUniqueWithoutFromAdminInput = {
    where: WorkerNotificationWhereUniqueInput
    data: XOR<WorkerNotificationUpdateWithoutFromAdminInput, WorkerNotificationUncheckedUpdateWithoutFromAdminInput>
  }

  export type WorkerNotificationUpdateManyWithWhereWithoutFromAdminInput = {
    where: WorkerNotificationScalarWhereInput
    data: XOR<WorkerNotificationUpdateManyMutationInput, WorkerNotificationUncheckedUpdateManyWithoutFromAdminInput>
  }

  export type WorkerNotificationScalarWhereInput = {
    AND?: WorkerNotificationScalarWhereInput | WorkerNotificationScalarWhereInput[]
    OR?: WorkerNotificationScalarWhereInput[]
    NOT?: WorkerNotificationScalarWhereInput | WorkerNotificationScalarWhereInput[]
    id?: UuidFilter<"WorkerNotification"> | string
    workerId?: UuidFilter<"WorkerNotification"> | string
    fromAdminId?: UuidNullableFilter<"WorkerNotification"> | string | null
    type?: StringFilter<"WorkerNotification"> | string
    title?: StringFilter<"WorkerNotification"> | string
    message?: StringFilter<"WorkerNotification"> | string
    isRead?: BoolNullableFilter<"WorkerNotification"> | boolean | null
    createdAt?: DateTimeNullableFilter<"WorkerNotification"> | Date | string | null
  }

  export type WorkerNotificationUpsertWithWhereUniqueWithoutWorkerInput = {
    where: WorkerNotificationWhereUniqueInput
    update: XOR<WorkerNotificationUpdateWithoutWorkerInput, WorkerNotificationUncheckedUpdateWithoutWorkerInput>
    create: XOR<WorkerNotificationCreateWithoutWorkerInput, WorkerNotificationUncheckedCreateWithoutWorkerInput>
  }

  export type WorkerNotificationUpdateWithWhereUniqueWithoutWorkerInput = {
    where: WorkerNotificationWhereUniqueInput
    data: XOR<WorkerNotificationUpdateWithoutWorkerInput, WorkerNotificationUncheckedUpdateWithoutWorkerInput>
  }

  export type WorkerNotificationUpdateManyWithWhereWithoutWorkerInput = {
    where: WorkerNotificationScalarWhereInput
    data: XOR<WorkerNotificationUpdateManyMutationInput, WorkerNotificationUncheckedUpdateManyWithoutWorkerInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: UuidFilter<"Message"> | string
    senderId?: UuidFilter<"Message"> | string
    receiverId?: UuidFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
  }

  export type MessageUpdateManyWithWhereWithoutReceiverInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutReceiverInput>
  }

  export type ChatGroupMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: ChatGroupMemberWhereUniqueInput
    update: XOR<ChatGroupMemberUpdateWithoutUserInput, ChatGroupMemberUncheckedUpdateWithoutUserInput>
    create: XOR<ChatGroupMemberCreateWithoutUserInput, ChatGroupMemberUncheckedCreateWithoutUserInput>
  }

  export type ChatGroupMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: ChatGroupMemberWhereUniqueInput
    data: XOR<ChatGroupMemberUpdateWithoutUserInput, ChatGroupMemberUncheckedUpdateWithoutUserInput>
  }

  export type ChatGroupMemberUpdateManyWithWhereWithoutUserInput = {
    where: ChatGroupMemberScalarWhereInput
    data: XOR<ChatGroupMemberUpdateManyMutationInput, ChatGroupMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatGroupMemberScalarWhereInput = {
    AND?: ChatGroupMemberScalarWhereInput | ChatGroupMemberScalarWhereInput[]
    OR?: ChatGroupMemberScalarWhereInput[]
    NOT?: ChatGroupMemberScalarWhereInput | ChatGroupMemberScalarWhereInput[]
    id?: UuidFilter<"ChatGroupMember"> | string
    groupId?: UuidFilter<"ChatGroupMember"> | string
    userId?: UuidFilter<"ChatGroupMember"> | string
    role?: StringFilter<"ChatGroupMember"> | string
    joinedAt?: DateTimeFilter<"ChatGroupMember"> | Date | string
  }

  export type GroupMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: GroupMessageWhereUniqueInput
    update: XOR<GroupMessageUpdateWithoutSenderInput, GroupMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<GroupMessageCreateWithoutSenderInput, GroupMessageUncheckedCreateWithoutSenderInput>
  }

  export type GroupMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: GroupMessageWhereUniqueInput
    data: XOR<GroupMessageUpdateWithoutSenderInput, GroupMessageUncheckedUpdateWithoutSenderInput>
  }

  export type GroupMessageUpdateManyWithWhereWithoutSenderInput = {
    where: GroupMessageScalarWhereInput
    data: XOR<GroupMessageUpdateManyMutationInput, GroupMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type GroupMessageScalarWhereInput = {
    AND?: GroupMessageScalarWhereInput | GroupMessageScalarWhereInput[]
    OR?: GroupMessageScalarWhereInput[]
    NOT?: GroupMessageScalarWhereInput | GroupMessageScalarWhereInput[]
    id?: UuidFilter<"GroupMessage"> | string
    groupId?: UuidFilter<"GroupMessage"> | string
    senderId?: UuidFilter<"GroupMessage"> | string
    content?: StringFilter<"GroupMessage"> | string
    createdAt?: DateTimeFilter<"GroupMessage"> | Date | string
  }

  export type NotificationDismissalUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationDismissalWhereUniqueInput
    update: XOR<NotificationDismissalUpdateWithoutUserInput, NotificationDismissalUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationDismissalCreateWithoutUserInput, NotificationDismissalUncheckedCreateWithoutUserInput>
  }

  export type NotificationDismissalUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationDismissalWhereUniqueInput
    data: XOR<NotificationDismissalUpdateWithoutUserInput, NotificationDismissalUncheckedUpdateWithoutUserInput>
  }

  export type NotificationDismissalUpdateManyWithWhereWithoutUserInput = {
    where: NotificationDismissalScalarWhereInput
    data: XOR<NotificationDismissalUpdateManyMutationInput, NotificationDismissalUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationDismissalScalarWhereInput = {
    AND?: NotificationDismissalScalarWhereInput | NotificationDismissalScalarWhereInput[]
    OR?: NotificationDismissalScalarWhereInput[]
    NOT?: NotificationDismissalScalarWhereInput | NotificationDismissalScalarWhereInput[]
    id?: UuidFilter<"NotificationDismissal"> | string
    userId?: UuidFilter<"NotificationDismissal"> | string
    entityId?: UuidFilter<"NotificationDismissal"> | string
    entityType?: StringFilter<"NotificationDismissal"> | string
    createdAt?: DateTimeFilter<"NotificationDismissal"> | Date | string
  }

  export type SystemNotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: SystemNotificationWhereUniqueInput
    update: XOR<SystemNotificationUpdateWithoutUserInput, SystemNotificationUncheckedUpdateWithoutUserInput>
    create: XOR<SystemNotificationCreateWithoutUserInput, SystemNotificationUncheckedCreateWithoutUserInput>
  }

  export type SystemNotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: SystemNotificationWhereUniqueInput
    data: XOR<SystemNotificationUpdateWithoutUserInput, SystemNotificationUncheckedUpdateWithoutUserInput>
  }

  export type SystemNotificationUpdateManyWithWhereWithoutUserInput = {
    where: SystemNotificationScalarWhereInput
    data: XOR<SystemNotificationUpdateManyMutationInput, SystemNotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type SystemNotificationScalarWhereInput = {
    AND?: SystemNotificationScalarWhereInput | SystemNotificationScalarWhereInput[]
    OR?: SystemNotificationScalarWhereInput[]
    NOT?: SystemNotificationScalarWhereInput | SystemNotificationScalarWhereInput[]
    id?: UuidFilter<"SystemNotification"> | string
    type?: StringFilter<"SystemNotification"> | string
    title?: StringFilter<"SystemNotification"> | string
    message?: StringFilter<"SystemNotification"> | string
    isRead?: BoolFilter<"SystemNotification"> | boolean
    userId?: UuidNullableFilter<"SystemNotification"> | string | null
    entityId?: UuidNullableFilter<"SystemNotification"> | string | null
    entityType?: StringNullableFilter<"SystemNotification"> | string | null
    relatedType?: StringNullableFilter<"SystemNotification"> | string | null
    createdAt?: DateTimeNullableFilter<"SystemNotification"> | Date | string | null
  }

  export type PaymentTransactionUpsertWithWhereUniqueWithoutVerifiedByInput = {
    where: PaymentTransactionWhereUniqueInput
    update: XOR<PaymentTransactionUpdateWithoutVerifiedByInput, PaymentTransactionUncheckedUpdateWithoutVerifiedByInput>
    create: XOR<PaymentTransactionCreateWithoutVerifiedByInput, PaymentTransactionUncheckedCreateWithoutVerifiedByInput>
  }

  export type PaymentTransactionUpdateWithWhereUniqueWithoutVerifiedByInput = {
    where: PaymentTransactionWhereUniqueInput
    data: XOR<PaymentTransactionUpdateWithoutVerifiedByInput, PaymentTransactionUncheckedUpdateWithoutVerifiedByInput>
  }

  export type PaymentTransactionUpdateManyWithWhereWithoutVerifiedByInput = {
    where: PaymentTransactionScalarWhereInput
    data: XOR<PaymentTransactionUpdateManyMutationInput, PaymentTransactionUncheckedUpdateManyWithoutVerifiedByInput>
  }

  export type UnitHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: UnitHistoryWhereUniqueInput
    update: XOR<UnitHistoryUpdateWithoutUserInput, UnitHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<UnitHistoryCreateWithoutUserInput, UnitHistoryUncheckedCreateWithoutUserInput>
  }

  export type UnitHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: UnitHistoryWhereUniqueInput
    data: XOR<UnitHistoryUpdateWithoutUserInput, UnitHistoryUncheckedUpdateWithoutUserInput>
  }

  export type UnitHistoryUpdateManyWithWhereWithoutUserInput = {
    where: UnitHistoryScalarWhereInput
    data: XOR<UnitHistoryUpdateManyMutationInput, UnitHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type AiActionUpsertWithWhereUniqueWithoutApproverInput = {
    where: AiActionWhereUniqueInput
    update: XOR<AiActionUpdateWithoutApproverInput, AiActionUncheckedUpdateWithoutApproverInput>
    create: XOR<AiActionCreateWithoutApproverInput, AiActionUncheckedCreateWithoutApproverInput>
  }

  export type AiActionUpdateWithWhereUniqueWithoutApproverInput = {
    where: AiActionWhereUniqueInput
    data: XOR<AiActionUpdateWithoutApproverInput, AiActionUncheckedUpdateWithoutApproverInput>
  }

  export type AiActionUpdateManyWithWhereWithoutApproverInput = {
    where: AiActionScalarWhereInput
    data: XOR<AiActionUpdateManyMutationInput, AiActionUncheckedUpdateManyWithoutApproverInput>
  }

  export type AiActionScalarWhereInput = {
    AND?: AiActionScalarWhereInput | AiActionScalarWhereInput[]
    OR?: AiActionScalarWhereInput[]
    NOT?: AiActionScalarWhereInput | AiActionScalarWhereInput[]
    id?: UuidFilter<"AiAction"> | string
    agentId?: UuidFilter<"AiAction"> | string
    actionType?: StringFilter<"AiAction"> | string
    payloadBefore?: JsonNullableFilter<"AiAction">
    payloadAfter?: JsonFilter<"AiAction">
    status?: EnumAiActionStatusFilter<"AiAction"> | $Enums.AiActionStatus
    approvedBy?: UuidNullableFilter<"AiAction"> | string | null
    createdAt?: DateTimeFilter<"AiAction"> | Date | string
    executedAt?: DateTimeNullableFilter<"AiAction"> | Date | string | null
  }

  export type ChatGroupMemberCreateWithoutGroupInput = {
    id?: string
    role?: string
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutChatGroupMembershipsInput
  }

  export type ChatGroupMemberUncheckedCreateWithoutGroupInput = {
    id?: string
    userId: string
    role?: string
    joinedAt?: Date | string
  }

  export type ChatGroupMemberCreateOrConnectWithoutGroupInput = {
    where: ChatGroupMemberWhereUniqueInput
    create: XOR<ChatGroupMemberCreateWithoutGroupInput, ChatGroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type ChatGroupMemberCreateManyGroupInputEnvelope = {
    data: ChatGroupMemberCreateManyGroupInput | ChatGroupMemberCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type GroupMessageCreateWithoutGroupInput = {
    id?: string
    content: string
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentGroupMessagesInput
  }

  export type GroupMessageUncheckedCreateWithoutGroupInput = {
    id?: string
    senderId: string
    content: string
    createdAt?: Date | string
  }

  export type GroupMessageCreateOrConnectWithoutGroupInput = {
    where: GroupMessageWhereUniqueInput
    create: XOR<GroupMessageCreateWithoutGroupInput, GroupMessageUncheckedCreateWithoutGroupInput>
  }

  export type GroupMessageCreateManyGroupInputEnvelope = {
    data: GroupMessageCreateManyGroupInput | GroupMessageCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type ChatGroupMemberUpsertWithWhereUniqueWithoutGroupInput = {
    where: ChatGroupMemberWhereUniqueInput
    update: XOR<ChatGroupMemberUpdateWithoutGroupInput, ChatGroupMemberUncheckedUpdateWithoutGroupInput>
    create: XOR<ChatGroupMemberCreateWithoutGroupInput, ChatGroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type ChatGroupMemberUpdateWithWhereUniqueWithoutGroupInput = {
    where: ChatGroupMemberWhereUniqueInput
    data: XOR<ChatGroupMemberUpdateWithoutGroupInput, ChatGroupMemberUncheckedUpdateWithoutGroupInput>
  }

  export type ChatGroupMemberUpdateManyWithWhereWithoutGroupInput = {
    where: ChatGroupMemberScalarWhereInput
    data: XOR<ChatGroupMemberUpdateManyMutationInput, ChatGroupMemberUncheckedUpdateManyWithoutGroupInput>
  }

  export type GroupMessageUpsertWithWhereUniqueWithoutGroupInput = {
    where: GroupMessageWhereUniqueInput
    update: XOR<GroupMessageUpdateWithoutGroupInput, GroupMessageUncheckedUpdateWithoutGroupInput>
    create: XOR<GroupMessageCreateWithoutGroupInput, GroupMessageUncheckedCreateWithoutGroupInput>
  }

  export type GroupMessageUpdateWithWhereUniqueWithoutGroupInput = {
    where: GroupMessageWhereUniqueInput
    data: XOR<GroupMessageUpdateWithoutGroupInput, GroupMessageUncheckedUpdateWithoutGroupInput>
  }

  export type GroupMessageUpdateManyWithWhereWithoutGroupInput = {
    where: GroupMessageScalarWhereInput
    data: XOR<GroupMessageUpdateManyMutationInput, GroupMessageUncheckedUpdateManyWithoutGroupInput>
  }

  export type ChatGroupCreateWithoutMembersInput = {
    id?: string
    name: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: GroupMessageCreateNestedManyWithoutGroupInput
  }

  export type ChatGroupUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: GroupMessageUncheckedCreateNestedManyWithoutGroupInput
  }

  export type ChatGroupCreateOrConnectWithoutMembersInput = {
    where: ChatGroupWhereUniqueInput
    create: XOR<ChatGroupCreateWithoutMembersInput, ChatGroupUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutChatGroupMembershipsInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    sentGroupMessages?: GroupMessageCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutChatGroupMembershipsInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogUncheckedCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogUncheckedCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceUncheckedCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryUncheckedCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    sentGroupMessages?: GroupMessageUncheckedCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalUncheckedCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryUncheckedCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutChatGroupMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatGroupMembershipsInput, UserUncheckedCreateWithoutChatGroupMembershipsInput>
  }

  export type ChatGroupUpsertWithoutMembersInput = {
    update: XOR<ChatGroupUpdateWithoutMembersInput, ChatGroupUncheckedUpdateWithoutMembersInput>
    create: XOR<ChatGroupCreateWithoutMembersInput, ChatGroupUncheckedCreateWithoutMembersInput>
    where?: ChatGroupWhereInput
  }

  export type ChatGroupUpdateToOneWithWhereWithoutMembersInput = {
    where?: ChatGroupWhereInput
    data: XOR<ChatGroupUpdateWithoutMembersInput, ChatGroupUncheckedUpdateWithoutMembersInput>
  }

  export type ChatGroupUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: GroupMessageUpdateManyWithoutGroupNestedInput
  }

  export type ChatGroupUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: GroupMessageUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type UserUpsertWithoutChatGroupMembershipsInput = {
    update: XOR<UserUpdateWithoutChatGroupMembershipsInput, UserUncheckedUpdateWithoutChatGroupMembershipsInput>
    create: XOR<UserCreateWithoutChatGroupMembershipsInput, UserUncheckedCreateWithoutChatGroupMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatGroupMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatGroupMembershipsInput, UserUncheckedUpdateWithoutChatGroupMembershipsInput>
  }

  export type UserUpdateWithoutChatGroupMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    sentGroupMessages?: GroupMessageUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutChatGroupMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUncheckedUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUncheckedUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUncheckedUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUncheckedUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUncheckedUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    sentGroupMessages?: GroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUncheckedUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUncheckedUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUncheckedUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type ChatGroupCreateWithoutMessagesInput = {
    id?: string
    name: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ChatGroupMemberCreateNestedManyWithoutGroupInput
  }

  export type ChatGroupUncheckedCreateWithoutMessagesInput = {
    id?: string
    name: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ChatGroupMemberUncheckedCreateNestedManyWithoutGroupInput
  }

  export type ChatGroupCreateOrConnectWithoutMessagesInput = {
    where: ChatGroupWhereUniqueInput
    create: XOR<ChatGroupCreateWithoutMessagesInput, ChatGroupUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutSentGroupMessagesInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberCreateNestedManyWithoutUserInput
    notificationDismissals?: NotificationDismissalCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutSentGroupMessagesInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogUncheckedCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogUncheckedCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceUncheckedCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryUncheckedCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    notificationDismissals?: NotificationDismissalUncheckedCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryUncheckedCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutSentGroupMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentGroupMessagesInput, UserUncheckedCreateWithoutSentGroupMessagesInput>
  }

  export type ChatGroupUpsertWithoutMessagesInput = {
    update: XOR<ChatGroupUpdateWithoutMessagesInput, ChatGroupUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatGroupCreateWithoutMessagesInput, ChatGroupUncheckedCreateWithoutMessagesInput>
    where?: ChatGroupWhereInput
  }

  export type ChatGroupUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatGroupWhereInput
    data: XOR<ChatGroupUpdateWithoutMessagesInput, ChatGroupUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatGroupUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ChatGroupMemberUpdateManyWithoutGroupNestedInput
  }

  export type ChatGroupUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ChatGroupMemberUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type UserUpsertWithoutSentGroupMessagesInput = {
    update: XOR<UserUpdateWithoutSentGroupMessagesInput, UserUncheckedUpdateWithoutSentGroupMessagesInput>
    create: XOR<UserCreateWithoutSentGroupMessagesInput, UserUncheckedCreateWithoutSentGroupMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentGroupMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentGroupMessagesInput, UserUncheckedUpdateWithoutSentGroupMessagesInput>
  }

  export type UserUpdateWithoutSentGroupMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    notificationDismissals?: NotificationDismissalUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutSentGroupMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUncheckedUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUncheckedUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUncheckedUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUncheckedUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUncheckedUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notificationDismissals?: NotificationDismissalUncheckedUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUncheckedUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUncheckedUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserCreateWithoutActivityLogsInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    inventoryResolutions?: InventorySyncLogCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutActivityLogsInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    inventoryResolutions?: InventorySyncLogUncheckedCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogUncheckedCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceUncheckedCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryUncheckedCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageUncheckedCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalUncheckedCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryUncheckedCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutActivityLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
  }

  export type UserUpsertWithoutActivityLogsInput = {
    update: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryResolutions?: InventorySyncLogUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryResolutions?: InventorySyncLogUncheckedUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUncheckedUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUncheckedUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUncheckedUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUncheckedUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUncheckedUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUncheckedUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUncheckedUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserCreateWithoutWorkerAttendanceInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    claimedDeliveries?: DeliveryCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutWorkerAttendanceInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogUncheckedCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogUncheckedCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    claimedDeliveries?: DeliveryUncheckedCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageUncheckedCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalUncheckedCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryUncheckedCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutWorkerAttendanceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkerAttendanceInput, UserUncheckedCreateWithoutWorkerAttendanceInput>
  }

  export type UserUpsertWithoutWorkerAttendanceInput = {
    update: XOR<UserUpdateWithoutWorkerAttendanceInput, UserUncheckedUpdateWithoutWorkerAttendanceInput>
    create: XOR<UserCreateWithoutWorkerAttendanceInput, UserUncheckedCreateWithoutWorkerAttendanceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkerAttendanceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkerAttendanceInput, UserUncheckedUpdateWithoutWorkerAttendanceInput>
  }

  export type UserUpdateWithoutWorkerAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    claimedDeliveries?: DeliveryUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkerAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUncheckedUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    claimedDeliveries?: DeliveryUncheckedUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUncheckedUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUncheckedUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUncheckedUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUncheckedUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUncheckedUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUncheckedUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type ProductCreateWithoutInventorySyncLogsInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    monthlyPrice: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    imageUrl?: string | null
    createdAt?: Date | string | null
    images?: ProductCreateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    rentalPackageItems?: RentalPackageItemCreateNestedManyWithoutProductInput
    productRelations?: ProductRelationCreateNestedManyWithoutProductInput
    relatedTo?: ProductRelationCreateNestedManyWithoutRelatedProductInput
    variants?: ProductVariantCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutInventorySyncLogsInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    monthlyPrice: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    imageUrl?: string | null
    createdAt?: Date | string | null
    images?: ProductCreateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    rentalPackageItems?: RentalPackageItemUncheckedCreateNestedManyWithoutProductInput
    productRelations?: ProductRelationUncheckedCreateNestedManyWithoutProductInput
    relatedTo?: ProductRelationUncheckedCreateNestedManyWithoutRelatedProductInput
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutInventorySyncLogsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutInventorySyncLogsInput, ProductUncheckedCreateWithoutInventorySyncLogsInput>
  }

  export type UserCreateWithoutInventoryResolutionsInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    inventoryUpdates?: InventorySyncLogCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutInventoryResolutionsInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    inventoryUpdates?: InventorySyncLogUncheckedCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceUncheckedCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryUncheckedCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageUncheckedCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalUncheckedCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryUncheckedCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutInventoryResolutionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryResolutionsInput, UserUncheckedCreateWithoutInventoryResolutionsInput>
  }

  export type UserCreateWithoutInventoryUpdatesInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogCreateNestedManyWithoutResolvedByUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutInventoryUpdatesInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogUncheckedCreateNestedManyWithoutResolvedByUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceUncheckedCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryUncheckedCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageUncheckedCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalUncheckedCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryUncheckedCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutInventoryUpdatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryUpdatesInput, UserUncheckedCreateWithoutInventoryUpdatesInput>
  }

  export type ProductUpsertWithoutInventorySyncLogsInput = {
    update: XOR<ProductUpdateWithoutInventorySyncLogsInput, ProductUncheckedUpdateWithoutInventorySyncLogsInput>
    create: XOR<ProductCreateWithoutInventorySyncLogsInput, ProductUncheckedCreateWithoutInventorySyncLogsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutInventorySyncLogsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutInventorySyncLogsInput, ProductUncheckedUpdateWithoutInventorySyncLogsInput>
  }

  export type ProductUpdateWithoutInventorySyncLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: ProductUpdateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    rentalPackageItems?: RentalPackageItemUpdateManyWithoutProductNestedInput
    productRelations?: ProductRelationUpdateManyWithoutProductNestedInput
    relatedTo?: ProductRelationUpdateManyWithoutRelatedProductNestedInput
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutInventorySyncLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: ProductUpdateimagesInput | string[]
    specs?: NullableJsonNullValueInput | InputJsonValue
    rentalPackageItems?: RentalPackageItemUncheckedUpdateManyWithoutProductNestedInput
    productRelations?: ProductRelationUncheckedUpdateManyWithoutProductNestedInput
    relatedTo?: ProductRelationUncheckedUpdateManyWithoutRelatedProductNestedInput
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserUpsertWithoutInventoryResolutionsInput = {
    update: XOR<UserUpdateWithoutInventoryResolutionsInput, UserUncheckedUpdateWithoutInventoryResolutionsInput>
    create: XOR<UserCreateWithoutInventoryResolutionsInput, UserUncheckedCreateWithoutInventoryResolutionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryResolutionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryResolutionsInput, UserUncheckedUpdateWithoutInventoryResolutionsInput>
  }

  export type UserUpdateWithoutInventoryResolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    inventoryUpdates?: InventorySyncLogUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryResolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryUpdates?: InventorySyncLogUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUncheckedUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUncheckedUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUncheckedUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUncheckedUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUncheckedUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUncheckedUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUncheckedUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserUpsertWithoutInventoryUpdatesInput = {
    update: XOR<UserUpdateWithoutInventoryUpdatesInput, UserUncheckedUpdateWithoutInventoryUpdatesInput>
    create: XOR<UserCreateWithoutInventoryUpdatesInput, UserUncheckedCreateWithoutInventoryUpdatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryUpdatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryUpdatesInput, UserUncheckedUpdateWithoutInventoryUpdatesInput>
  }

  export type UserUpdateWithoutInventoryUpdatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUpdateManyWithoutResolvedByUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryUpdatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUncheckedUpdateManyWithoutResolvedByUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUncheckedUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUncheckedUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUncheckedUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUncheckedUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUncheckedUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUncheckedUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUncheckedUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserCreateWithoutSentNotificationsInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogCreateNestedManyWithoutEditedByUserInput
    receivedNotifications?: WorkerNotificationCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutSentNotificationsInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogUncheckedCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogUncheckedCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceUncheckedCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryUncheckedCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutEditedByUserInput
    receivedNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageUncheckedCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalUncheckedCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryUncheckedCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutSentNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
  }

  export type UserCreateWithoutReceivedNotificationsInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationCreateNestedManyWithoutFromAdminInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutReceivedNotificationsInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogUncheckedCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogUncheckedCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceUncheckedCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryUncheckedCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutFromAdminInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageUncheckedCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalUncheckedCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryUncheckedCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutReceivedNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedNotificationsInput, UserUncheckedCreateWithoutReceivedNotificationsInput>
  }

  export type UserUpsertWithoutSentNotificationsInput = {
    update: XOR<UserUpdateWithoutSentNotificationsInput, UserUncheckedUpdateWithoutSentNotificationsInput>
    create: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentNotificationsInput, UserUncheckedUpdateWithoutSentNotificationsInput>
  }

  export type UserUpdateWithoutSentNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUpdateManyWithoutEditedByUserNestedInput
    receivedNotifications?: WorkerNotificationUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutSentNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUncheckedUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUncheckedUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUncheckedUpdateManyWithoutEditedByUserNestedInput
    receivedNotifications?: WorkerNotificationUncheckedUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUncheckedUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUncheckedUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUncheckedUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserUpsertWithoutReceivedNotificationsInput = {
    update: XOR<UserUpdateWithoutReceivedNotificationsInput, UserUncheckedUpdateWithoutReceivedNotificationsInput>
    create: XOR<UserCreateWithoutReceivedNotificationsInput, UserUncheckedCreateWithoutReceivedNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedNotificationsInput, UserUncheckedUpdateWithoutReceivedNotificationsInput>
  }

  export type UserUpdateWithoutReceivedNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUpdateManyWithoutFromAdminNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUncheckedUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUncheckedUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUncheckedUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUncheckedUpdateManyWithoutFromAdminNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUncheckedUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUncheckedUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUncheckedUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationCreateNestedManyWithoutWorkerInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogUncheckedCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogUncheckedCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceUncheckedCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryUncheckedCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutWorkerInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageUncheckedCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalUncheckedCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryUncheckedCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type UserCreateWithoutReceivedMessagesInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    chatGroupMemberships?: ChatGroupMemberCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutReceivedMessagesInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogUncheckedCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogUncheckedCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceUncheckedCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryUncheckedCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    chatGroupMemberships?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageUncheckedCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalUncheckedCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryUncheckedCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUpdateManyWithoutWorkerNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUncheckedUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUncheckedUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUncheckedUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUncheckedUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUncheckedUpdateManyWithoutWorkerNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUncheckedUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUncheckedUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUncheckedUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserUpsertWithoutReceivedMessagesInput = {
    update: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    chatGroupMemberships?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUncheckedUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUncheckedUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUncheckedUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUncheckedUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUncheckedUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    chatGroupMemberships?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUncheckedUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUncheckedUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUncheckedUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserCreateWithoutNotificationDismissalsInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageCreateNestedManyWithoutSenderInput
    systemNotifications?: SystemNotificationCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutNotificationDismissalsInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogUncheckedCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogUncheckedCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceUncheckedCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryUncheckedCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageUncheckedCreateNestedManyWithoutSenderInput
    systemNotifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryUncheckedCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutNotificationDismissalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationDismissalsInput, UserUncheckedCreateWithoutNotificationDismissalsInput>
  }

  export type UserUpsertWithoutNotificationDismissalsInput = {
    update: XOR<UserUpdateWithoutNotificationDismissalsInput, UserUncheckedUpdateWithoutNotificationDismissalsInput>
    create: XOR<UserCreateWithoutNotificationDismissalsInput, UserUncheckedCreateWithoutNotificationDismissalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationDismissalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationDismissalsInput, UserUncheckedUpdateWithoutNotificationDismissalsInput>
  }

  export type UserUpdateWithoutNotificationDismissalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUpdateManyWithoutSenderNestedInput
    systemNotifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationDismissalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUncheckedUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUncheckedUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUncheckedUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUncheckedUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUncheckedUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    systemNotifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUncheckedUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUncheckedUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type AiPermissionCreateWithoutAgentInput = {
    id?: string
    canModifyProducts?: boolean
    canModifyPackages?: boolean
    canModifyOrders?: boolean
    requiresAdminConfirmation?: boolean
  }

  export type AiPermissionUncheckedCreateWithoutAgentInput = {
    id?: string
    canModifyProducts?: boolean
    canModifyPackages?: boolean
    canModifyOrders?: boolean
    requiresAdminConfirmation?: boolean
  }

  export type AiPermissionCreateOrConnectWithoutAgentInput = {
    where: AiPermissionWhereUniqueInput
    create: XOR<AiPermissionCreateWithoutAgentInput, AiPermissionUncheckedCreateWithoutAgentInput>
  }

  export type AiActionCreateWithoutAgentInput = {
    id?: string
    actionType: string
    payloadBefore?: NullableJsonNullValueInput | InputJsonValue
    payloadAfter: JsonNullValueInput | InputJsonValue
    status?: $Enums.AiActionStatus
    createdAt?: Date | string
    executedAt?: Date | string | null
    approver?: UserCreateNestedOneWithoutAiActionApprovalsInput
  }

  export type AiActionUncheckedCreateWithoutAgentInput = {
    id?: string
    actionType: string
    payloadBefore?: NullableJsonNullValueInput | InputJsonValue
    payloadAfter: JsonNullValueInput | InputJsonValue
    status?: $Enums.AiActionStatus
    approvedBy?: string | null
    createdAt?: Date | string
    executedAt?: Date | string | null
  }

  export type AiActionCreateOrConnectWithoutAgentInput = {
    where: AiActionWhereUniqueInput
    create: XOR<AiActionCreateWithoutAgentInput, AiActionUncheckedCreateWithoutAgentInput>
  }

  export type AiActionCreateManyAgentInputEnvelope = {
    data: AiActionCreateManyAgentInput | AiActionCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type AiTrainingDataCreateWithoutAgentInput = {
    id?: string
    suggestion: string
    adminDecision: string
    feedbackScore?: number | null
    createdAt?: Date | string
  }

  export type AiTrainingDataUncheckedCreateWithoutAgentInput = {
    id?: string
    suggestion: string
    adminDecision: string
    feedbackScore?: number | null
    createdAt?: Date | string
  }

  export type AiTrainingDataCreateOrConnectWithoutAgentInput = {
    where: AiTrainingDataWhereUniqueInput
    create: XOR<AiTrainingDataCreateWithoutAgentInput, AiTrainingDataUncheckedCreateWithoutAgentInput>
  }

  export type AiTrainingDataCreateManyAgentInputEnvelope = {
    data: AiTrainingDataCreateManyAgentInput | AiTrainingDataCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type AiPermissionUpsertWithoutAgentInput = {
    update: XOR<AiPermissionUpdateWithoutAgentInput, AiPermissionUncheckedUpdateWithoutAgentInput>
    create: XOR<AiPermissionCreateWithoutAgentInput, AiPermissionUncheckedCreateWithoutAgentInput>
    where?: AiPermissionWhereInput
  }

  export type AiPermissionUpdateToOneWithWhereWithoutAgentInput = {
    where?: AiPermissionWhereInput
    data: XOR<AiPermissionUpdateWithoutAgentInput, AiPermissionUncheckedUpdateWithoutAgentInput>
  }

  export type AiPermissionUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    canModifyProducts?: BoolFieldUpdateOperationsInput | boolean
    canModifyPackages?: BoolFieldUpdateOperationsInput | boolean
    canModifyOrders?: BoolFieldUpdateOperationsInput | boolean
    requiresAdminConfirmation?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AiPermissionUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    canModifyProducts?: BoolFieldUpdateOperationsInput | boolean
    canModifyPackages?: BoolFieldUpdateOperationsInput | boolean
    canModifyOrders?: BoolFieldUpdateOperationsInput | boolean
    requiresAdminConfirmation?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AiActionUpsertWithWhereUniqueWithoutAgentInput = {
    where: AiActionWhereUniqueInput
    update: XOR<AiActionUpdateWithoutAgentInput, AiActionUncheckedUpdateWithoutAgentInput>
    create: XOR<AiActionCreateWithoutAgentInput, AiActionUncheckedCreateWithoutAgentInput>
  }

  export type AiActionUpdateWithWhereUniqueWithoutAgentInput = {
    where: AiActionWhereUniqueInput
    data: XOR<AiActionUpdateWithoutAgentInput, AiActionUncheckedUpdateWithoutAgentInput>
  }

  export type AiActionUpdateManyWithWhereWithoutAgentInput = {
    where: AiActionScalarWhereInput
    data: XOR<AiActionUpdateManyMutationInput, AiActionUncheckedUpdateManyWithoutAgentInput>
  }

  export type AiTrainingDataUpsertWithWhereUniqueWithoutAgentInput = {
    where: AiTrainingDataWhereUniqueInput
    update: XOR<AiTrainingDataUpdateWithoutAgentInput, AiTrainingDataUncheckedUpdateWithoutAgentInput>
    create: XOR<AiTrainingDataCreateWithoutAgentInput, AiTrainingDataUncheckedCreateWithoutAgentInput>
  }

  export type AiTrainingDataUpdateWithWhereUniqueWithoutAgentInput = {
    where: AiTrainingDataWhereUniqueInput
    data: XOR<AiTrainingDataUpdateWithoutAgentInput, AiTrainingDataUncheckedUpdateWithoutAgentInput>
  }

  export type AiTrainingDataUpdateManyWithWhereWithoutAgentInput = {
    where: AiTrainingDataScalarWhereInput
    data: XOR<AiTrainingDataUpdateManyMutationInput, AiTrainingDataUncheckedUpdateManyWithoutAgentInput>
  }

  export type AiTrainingDataScalarWhereInput = {
    AND?: AiTrainingDataScalarWhereInput | AiTrainingDataScalarWhereInput[]
    OR?: AiTrainingDataScalarWhereInput[]
    NOT?: AiTrainingDataScalarWhereInput | AiTrainingDataScalarWhereInput[]
    id?: UuidFilter<"AiTrainingData"> | string
    agentId?: UuidFilter<"AiTrainingData"> | string
    suggestion?: StringFilter<"AiTrainingData"> | string
    adminDecision?: StringFilter<"AiTrainingData"> | string
    feedbackScore?: IntNullableFilter<"AiTrainingData"> | number | null
    createdAt?: DateTimeFilter<"AiTrainingData"> | Date | string
  }

  export type AiAgentCreateWithoutPermissionsInput = {
    id?: string
    systemName: $Enums.AiAgentSystemName
    displayName: string
    isActive?: boolean
    canMutateData?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    actions?: AiActionCreateNestedManyWithoutAgentInput
    trainingData?: AiTrainingDataCreateNestedManyWithoutAgentInput
  }

  export type AiAgentUncheckedCreateWithoutPermissionsInput = {
    id?: string
    systemName: $Enums.AiAgentSystemName
    displayName: string
    isActive?: boolean
    canMutateData?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    actions?: AiActionUncheckedCreateNestedManyWithoutAgentInput
    trainingData?: AiTrainingDataUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AiAgentCreateOrConnectWithoutPermissionsInput = {
    where: AiAgentWhereUniqueInput
    create: XOR<AiAgentCreateWithoutPermissionsInput, AiAgentUncheckedCreateWithoutPermissionsInput>
  }

  export type AiAgentUpsertWithoutPermissionsInput = {
    update: XOR<AiAgentUpdateWithoutPermissionsInput, AiAgentUncheckedUpdateWithoutPermissionsInput>
    create: XOR<AiAgentCreateWithoutPermissionsInput, AiAgentUncheckedCreateWithoutPermissionsInput>
    where?: AiAgentWhereInput
  }

  export type AiAgentUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: AiAgentWhereInput
    data: XOR<AiAgentUpdateWithoutPermissionsInput, AiAgentUncheckedUpdateWithoutPermissionsInput>
  }

  export type AiAgentUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemName?: EnumAiAgentSystemNameFieldUpdateOperationsInput | $Enums.AiAgentSystemName
    displayName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    canMutateData?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actions?: AiActionUpdateManyWithoutAgentNestedInput
    trainingData?: AiTrainingDataUpdateManyWithoutAgentNestedInput
  }

  export type AiAgentUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemName?: EnumAiAgentSystemNameFieldUpdateOperationsInput | $Enums.AiAgentSystemName
    displayName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    canMutateData?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actions?: AiActionUncheckedUpdateManyWithoutAgentNestedInput
    trainingData?: AiTrainingDataUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AiAgentCreateWithoutActionsInput = {
    id?: string
    systemName: $Enums.AiAgentSystemName
    displayName: string
    isActive?: boolean
    canMutateData?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: AiPermissionCreateNestedOneWithoutAgentInput
    trainingData?: AiTrainingDataCreateNestedManyWithoutAgentInput
  }

  export type AiAgentUncheckedCreateWithoutActionsInput = {
    id?: string
    systemName: $Enums.AiAgentSystemName
    displayName: string
    isActive?: boolean
    canMutateData?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: AiPermissionUncheckedCreateNestedOneWithoutAgentInput
    trainingData?: AiTrainingDataUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AiAgentCreateOrConnectWithoutActionsInput = {
    where: AiAgentWhereUniqueInput
    create: XOR<AiAgentCreateWithoutActionsInput, AiAgentUncheckedCreateWithoutActionsInput>
  }

  export type UserCreateWithoutAiActionApprovalsInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAiActionApprovalsInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogUncheckedCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogUncheckedCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceUncheckedCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryUncheckedCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageUncheckedCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalUncheckedCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAiActionApprovalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAiActionApprovalsInput, UserUncheckedCreateWithoutAiActionApprovalsInput>
  }

  export type AiAgentUpsertWithoutActionsInput = {
    update: XOR<AiAgentUpdateWithoutActionsInput, AiAgentUncheckedUpdateWithoutActionsInput>
    create: XOR<AiAgentCreateWithoutActionsInput, AiAgentUncheckedCreateWithoutActionsInput>
    where?: AiAgentWhereInput
  }

  export type AiAgentUpdateToOneWithWhereWithoutActionsInput = {
    where?: AiAgentWhereInput
    data: XOR<AiAgentUpdateWithoutActionsInput, AiAgentUncheckedUpdateWithoutActionsInput>
  }

  export type AiAgentUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemName?: EnumAiAgentSystemNameFieldUpdateOperationsInput | $Enums.AiAgentSystemName
    displayName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    canMutateData?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: AiPermissionUpdateOneWithoutAgentNestedInput
    trainingData?: AiTrainingDataUpdateManyWithoutAgentNestedInput
  }

  export type AiAgentUncheckedUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemName?: EnumAiAgentSystemNameFieldUpdateOperationsInput | $Enums.AiAgentSystemName
    displayName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    canMutateData?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: AiPermissionUncheckedUpdateOneWithoutAgentNestedInput
    trainingData?: AiTrainingDataUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type UserUpsertWithoutAiActionApprovalsInput = {
    update: XOR<UserUpdateWithoutAiActionApprovalsInput, UserUncheckedUpdateWithoutAiActionApprovalsInput>
    create: XOR<UserCreateWithoutAiActionApprovalsInput, UserUncheckedCreateWithoutAiActionApprovalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAiActionApprovalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAiActionApprovalsInput, UserUncheckedUpdateWithoutAiActionApprovalsInput>
  }

  export type UserUpdateWithoutAiActionApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAiActionApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUncheckedUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUncheckedUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUncheckedUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUncheckedUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUncheckedUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUncheckedUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUncheckedUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AiAgentCreateWithoutTrainingDataInput = {
    id?: string
    systemName: $Enums.AiAgentSystemName
    displayName: string
    isActive?: boolean
    canMutateData?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: AiPermissionCreateNestedOneWithoutAgentInput
    actions?: AiActionCreateNestedManyWithoutAgentInput
  }

  export type AiAgentUncheckedCreateWithoutTrainingDataInput = {
    id?: string
    systemName: $Enums.AiAgentSystemName
    displayName: string
    isActive?: boolean
    canMutateData?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: AiPermissionUncheckedCreateNestedOneWithoutAgentInput
    actions?: AiActionUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AiAgentCreateOrConnectWithoutTrainingDataInput = {
    where: AiAgentWhereUniqueInput
    create: XOR<AiAgentCreateWithoutTrainingDataInput, AiAgentUncheckedCreateWithoutTrainingDataInput>
  }

  export type AiAgentUpsertWithoutTrainingDataInput = {
    update: XOR<AiAgentUpdateWithoutTrainingDataInput, AiAgentUncheckedUpdateWithoutTrainingDataInput>
    create: XOR<AiAgentCreateWithoutTrainingDataInput, AiAgentUncheckedCreateWithoutTrainingDataInput>
    where?: AiAgentWhereInput
  }

  export type AiAgentUpdateToOneWithWhereWithoutTrainingDataInput = {
    where?: AiAgentWhereInput
    data: XOR<AiAgentUpdateWithoutTrainingDataInput, AiAgentUncheckedUpdateWithoutTrainingDataInput>
  }

  export type AiAgentUpdateWithoutTrainingDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemName?: EnumAiAgentSystemNameFieldUpdateOperationsInput | $Enums.AiAgentSystemName
    displayName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    canMutateData?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: AiPermissionUpdateOneWithoutAgentNestedInput
    actions?: AiActionUpdateManyWithoutAgentNestedInput
  }

  export type AiAgentUncheckedUpdateWithoutTrainingDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemName?: EnumAiAgentSystemNameFieldUpdateOperationsInput | $Enums.AiAgentSystemName
    displayName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    canMutateData?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: AiPermissionUncheckedUpdateOneWithoutAgentNestedInput
    actions?: AiActionUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type DeliveryCreateWithoutVehicleInput = {
    id?: string
    deliveryMethod: $Enums.DeliveryMethod
    deliveryType: $Enums.DeliveryType
    status?: $Enums.DeliveryStatus
    claimedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    eta?: Date | string | null
    etaOverrideCount?: number
    delayMinutes?: number
    latitude?: number | null
    longitude?: number | null
    lastLocationUpdate?: Date | string | null
    trackingCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutDeliveriesInput
    claimedByWorker?: UserCreateNestedOneWithoutClaimedDeliveriesInput
    items?: DeliveryItemCreateNestedManyWithoutDeliveryInput
    logs?: DeliveryLogCreateNestedManyWithoutDeliveryInput
    editLogs?: DeliveryEditLogCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateWithoutVehicleInput = {
    id?: string
    invoiceId?: string | null
    deliveryMethod: $Enums.DeliveryMethod
    deliveryType: $Enums.DeliveryType
    status?: $Enums.DeliveryStatus
    claimedByWorkerId?: string | null
    claimedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    eta?: Date | string | null
    etaOverrideCount?: number
    delayMinutes?: number
    latitude?: number | null
    longitude?: number | null
    lastLocationUpdate?: Date | string | null
    trackingCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: DeliveryItemUncheckedCreateNestedManyWithoutDeliveryInput
    logs?: DeliveryLogUncheckedCreateNestedManyWithoutDeliveryInput
    editLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryCreateOrConnectWithoutVehicleInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutVehicleInput, DeliveryUncheckedCreateWithoutVehicleInput>
  }

  export type DeliveryCreateManyVehicleInputEnvelope = {
    data: DeliveryCreateManyVehicleInput | DeliveryCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryUpsertWithWhereUniqueWithoutVehicleInput = {
    where: DeliveryWhereUniqueInput
    update: XOR<DeliveryUpdateWithoutVehicleInput, DeliveryUncheckedUpdateWithoutVehicleInput>
    create: XOR<DeliveryCreateWithoutVehicleInput, DeliveryUncheckedCreateWithoutVehicleInput>
  }

  export type DeliveryUpdateWithWhereUniqueWithoutVehicleInput = {
    where: DeliveryWhereUniqueInput
    data: XOR<DeliveryUpdateWithoutVehicleInput, DeliveryUncheckedUpdateWithoutVehicleInput>
  }

  export type DeliveryUpdateManyWithWhereWithoutVehicleInput = {
    where: DeliveryScalarWhereInput
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyWithoutVehicleInput>
  }

  export type InvoiceCreateWithoutDeliveriesInput = {
    id?: string
    invoiceNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string | null
    createdAt?: Date | string | null
    status?: string
    guestEmail?: string | null
    guestName?: string | null
    guestWhatsapp?: string | null
    guestAddress?: string | null
    deliveryFeeOverride?: Decimal | DecimalJsLike | number | string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    shareableToken?: string | null
    emailSent?: boolean | null
    emailSentAt?: Date | string | null
    order?: OrderCreateNestedOneWithoutInvoicesInput
    user?: UserCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutDeliveriesInput = {
    id?: string
    invoiceNumber: string
    orderId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string | null
    createdAt?: Date | string | null
    userId?: string | null
    status?: string
    guestEmail?: string | null
    guestName?: string | null
    guestWhatsapp?: string | null
    guestAddress?: string | null
    deliveryFeeOverride?: Decimal | DecimalJsLike | number | string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    shareableToken?: string | null
    emailSent?: boolean | null
    emailSentAt?: Date | string | null
  }

  export type InvoiceCreateOrConnectWithoutDeliveriesInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutDeliveriesInput, InvoiceUncheckedCreateWithoutDeliveriesInput>
  }

  export type VehicleCreateWithoutDeliveriesInput = {
    id?: string
    name: string
    type: $Enums.VehicleType
    status?: $Enums.VehicleStatus
    currentDeliveryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleUncheckedCreateWithoutDeliveriesInput = {
    id?: string
    name: string
    type: $Enums.VehicleType
    status?: $Enums.VehicleStatus
    currentDeliveryId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleCreateOrConnectWithoutDeliveriesInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutDeliveriesInput, VehicleUncheckedCreateWithoutDeliveriesInput>
  }

  export type UserCreateWithoutClaimedDeliveriesInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceCreateNestedManyWithoutWorkerInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutClaimedDeliveriesInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogUncheckedCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogUncheckedCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceUncheckedCreateNestedManyWithoutWorkerInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    deliveryEditLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageUncheckedCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalUncheckedCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryUncheckedCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutClaimedDeliveriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClaimedDeliveriesInput, UserUncheckedCreateWithoutClaimedDeliveriesInput>
  }

  export type DeliveryItemCreateWithoutDeliveryInput = {
    id?: string
    quantity: number
    rentalItem: RentalItemCreateNestedOneWithoutDeliveryItemsInput
  }

  export type DeliveryItemUncheckedCreateWithoutDeliveryInput = {
    id?: string
    rentalItemId: string
    quantity: number
  }

  export type DeliveryItemCreateOrConnectWithoutDeliveryInput = {
    where: DeliveryItemWhereUniqueInput
    create: XOR<DeliveryItemCreateWithoutDeliveryInput, DeliveryItemUncheckedCreateWithoutDeliveryInput>
  }

  export type DeliveryItemCreateManyDeliveryInputEnvelope = {
    data: DeliveryItemCreateManyDeliveryInput | DeliveryItemCreateManyDeliveryInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryLogCreateWithoutDeliveryInput = {
    id?: string
    eventType: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    role: $Enums.DeliveryRole
    createdAt?: Date | string
    createdByUser?: UserCreateNestedOneWithoutDeliveryLogsInput
  }

  export type DeliveryLogUncheckedCreateWithoutDeliveryInput = {
    id?: string
    eventType: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdByUserId?: string | null
    role: $Enums.DeliveryRole
    createdAt?: Date | string
  }

  export type DeliveryLogCreateOrConnectWithoutDeliveryInput = {
    where: DeliveryLogWhereUniqueInput
    create: XOR<DeliveryLogCreateWithoutDeliveryInput, DeliveryLogUncheckedCreateWithoutDeliveryInput>
  }

  export type DeliveryLogCreateManyDeliveryInputEnvelope = {
    data: DeliveryLogCreateManyDeliveryInput | DeliveryLogCreateManyDeliveryInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryEditLogCreateWithoutDeliveryInput = {
    id?: string
    role: $Enums.DeliveryRole
    fieldChanged: string
    oldValue?: string | null
    newValue?: string | null
    reason?: string | null
    createdAt?: Date | string
    editedByUser: UserCreateNestedOneWithoutDeliveryEditLogsInput
  }

  export type DeliveryEditLogUncheckedCreateWithoutDeliveryInput = {
    id?: string
    editedByUserId: string
    role: $Enums.DeliveryRole
    fieldChanged: string
    oldValue?: string | null
    newValue?: string | null
    reason?: string | null
    createdAt?: Date | string
  }

  export type DeliveryEditLogCreateOrConnectWithoutDeliveryInput = {
    where: DeliveryEditLogWhereUniqueInput
    create: XOR<DeliveryEditLogCreateWithoutDeliveryInput, DeliveryEditLogUncheckedCreateWithoutDeliveryInput>
  }

  export type DeliveryEditLogCreateManyDeliveryInputEnvelope = {
    data: DeliveryEditLogCreateManyDeliveryInput | DeliveryEditLogCreateManyDeliveryInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceUpsertWithoutDeliveriesInput = {
    update: XOR<InvoiceUpdateWithoutDeliveriesInput, InvoiceUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<InvoiceCreateWithoutDeliveriesInput, InvoiceUncheckedCreateWithoutDeliveriesInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutDeliveriesInput, InvoiceUncheckedUpdateWithoutDeliveriesInput>
  }

  export type InvoiceUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    guestAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryFeeOverride?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shareableToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderUpdateOneWithoutInvoicesNestedInput
    user?: UserUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    guestAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryFeeOverride?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shareableToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VehicleUpsertWithoutDeliveriesInput = {
    update: XOR<VehicleUpdateWithoutDeliveriesInput, VehicleUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<VehicleCreateWithoutDeliveriesInput, VehicleUncheckedCreateWithoutDeliveriesInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutDeliveriesInput, VehicleUncheckedUpdateWithoutDeliveriesInput>
  }

  export type VehicleUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    currentDeliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleUncheckedUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    currentDeliveryId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutClaimedDeliveriesInput = {
    update: XOR<UserUpdateWithoutClaimedDeliveriesInput, UserUncheckedUpdateWithoutClaimedDeliveriesInput>
    create: XOR<UserCreateWithoutClaimedDeliveriesInput, UserUncheckedCreateWithoutClaimedDeliveriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClaimedDeliveriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClaimedDeliveriesInput, UserUncheckedUpdateWithoutClaimedDeliveriesInput>
  }

  export type UserUpdateWithoutClaimedDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUpdateManyWithoutWorkerNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutClaimedDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUncheckedUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    deliveryEditLogs?: DeliveryEditLogUncheckedUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUncheckedUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUncheckedUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUncheckedUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUncheckedUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUncheckedUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type DeliveryItemUpsertWithWhereUniqueWithoutDeliveryInput = {
    where: DeliveryItemWhereUniqueInput
    update: XOR<DeliveryItemUpdateWithoutDeliveryInput, DeliveryItemUncheckedUpdateWithoutDeliveryInput>
    create: XOR<DeliveryItemCreateWithoutDeliveryInput, DeliveryItemUncheckedCreateWithoutDeliveryInput>
  }

  export type DeliveryItemUpdateWithWhereUniqueWithoutDeliveryInput = {
    where: DeliveryItemWhereUniqueInput
    data: XOR<DeliveryItemUpdateWithoutDeliveryInput, DeliveryItemUncheckedUpdateWithoutDeliveryInput>
  }

  export type DeliveryItemUpdateManyWithWhereWithoutDeliveryInput = {
    where: DeliveryItemScalarWhereInput
    data: XOR<DeliveryItemUpdateManyMutationInput, DeliveryItemUncheckedUpdateManyWithoutDeliveryInput>
  }

  export type DeliveryLogUpsertWithWhereUniqueWithoutDeliveryInput = {
    where: DeliveryLogWhereUniqueInput
    update: XOR<DeliveryLogUpdateWithoutDeliveryInput, DeliveryLogUncheckedUpdateWithoutDeliveryInput>
    create: XOR<DeliveryLogCreateWithoutDeliveryInput, DeliveryLogUncheckedCreateWithoutDeliveryInput>
  }

  export type DeliveryLogUpdateWithWhereUniqueWithoutDeliveryInput = {
    where: DeliveryLogWhereUniqueInput
    data: XOR<DeliveryLogUpdateWithoutDeliveryInput, DeliveryLogUncheckedUpdateWithoutDeliveryInput>
  }

  export type DeliveryLogUpdateManyWithWhereWithoutDeliveryInput = {
    where: DeliveryLogScalarWhereInput
    data: XOR<DeliveryLogUpdateManyMutationInput, DeliveryLogUncheckedUpdateManyWithoutDeliveryInput>
  }

  export type DeliveryEditLogUpsertWithWhereUniqueWithoutDeliveryInput = {
    where: DeliveryEditLogWhereUniqueInput
    update: XOR<DeliveryEditLogUpdateWithoutDeliveryInput, DeliveryEditLogUncheckedUpdateWithoutDeliveryInput>
    create: XOR<DeliveryEditLogCreateWithoutDeliveryInput, DeliveryEditLogUncheckedCreateWithoutDeliveryInput>
  }

  export type DeliveryEditLogUpdateWithWhereUniqueWithoutDeliveryInput = {
    where: DeliveryEditLogWhereUniqueInput
    data: XOR<DeliveryEditLogUpdateWithoutDeliveryInput, DeliveryEditLogUncheckedUpdateWithoutDeliveryInput>
  }

  export type DeliveryEditLogUpdateManyWithWhereWithoutDeliveryInput = {
    where: DeliveryEditLogScalarWhereInput
    data: XOR<DeliveryEditLogUpdateManyMutationInput, DeliveryEditLogUncheckedUpdateManyWithoutDeliveryInput>
  }

  export type DeliveryCreateWithoutItemsInput = {
    id?: string
    deliveryMethod: $Enums.DeliveryMethod
    deliveryType: $Enums.DeliveryType
    status?: $Enums.DeliveryStatus
    claimedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    eta?: Date | string | null
    etaOverrideCount?: number
    delayMinutes?: number
    latitude?: number | null
    longitude?: number | null
    lastLocationUpdate?: Date | string | null
    trackingCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutDeliveriesInput
    vehicle?: VehicleCreateNestedOneWithoutDeliveriesInput
    claimedByWorker?: UserCreateNestedOneWithoutClaimedDeliveriesInput
    logs?: DeliveryLogCreateNestedManyWithoutDeliveryInput
    editLogs?: DeliveryEditLogCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateWithoutItemsInput = {
    id?: string
    invoiceId?: string | null
    deliveryMethod: $Enums.DeliveryMethod
    deliveryType: $Enums.DeliveryType
    vehicleId?: string | null
    status?: $Enums.DeliveryStatus
    claimedByWorkerId?: string | null
    claimedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    eta?: Date | string | null
    etaOverrideCount?: number
    delayMinutes?: number
    latitude?: number | null
    longitude?: number | null
    lastLocationUpdate?: Date | string | null
    trackingCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: DeliveryLogUncheckedCreateNestedManyWithoutDeliveryInput
    editLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryCreateOrConnectWithoutItemsInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutItemsInput, DeliveryUncheckedCreateWithoutItemsInput>
  }

  export type RentalItemCreateWithoutDeliveryItemsInput = {
    id?: string
    quantity?: number | null
    createdAt?: Date | string | null
    order: OrderCreateNestedOneWithoutRentalItemsInput
    rentalPackage?: RentalPackageCreateNestedOneWithoutRentalItemsInput
    variant?: ProductVariantCreateNestedOneWithoutRentalItemsInput
    unit?: ProductUnitCreateNestedOneWithoutRentalItemsInput
  }

  export type RentalItemUncheckedCreateWithoutDeliveryItemsInput = {
    id?: string
    orderId: string
    variantId?: string | null
    packageId?: string | null
    quantity?: number | null
    createdAt?: Date | string | null
    unitId?: string | null
  }

  export type RentalItemCreateOrConnectWithoutDeliveryItemsInput = {
    where: RentalItemWhereUniqueInput
    create: XOR<RentalItemCreateWithoutDeliveryItemsInput, RentalItemUncheckedCreateWithoutDeliveryItemsInput>
  }

  export type DeliveryUpsertWithoutItemsInput = {
    update: XOR<DeliveryUpdateWithoutItemsInput, DeliveryUncheckedUpdateWithoutItemsInput>
    create: XOR<DeliveryCreateWithoutItemsInput, DeliveryUncheckedCreateWithoutItemsInput>
    where?: DeliveryWhereInput
  }

  export type DeliveryUpdateToOneWithWhereWithoutItemsInput = {
    where?: DeliveryWhereInput
    data: XOR<DeliveryUpdateWithoutItemsInput, DeliveryUncheckedUpdateWithoutItemsInput>
  }

  export type DeliveryUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etaOverrideCount?: IntFieldUpdateOperationsInput | number
    delayMinutes?: IntFieldUpdateOperationsInput | number
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutDeliveriesNestedInput
    vehicle?: VehicleUpdateOneWithoutDeliveriesNestedInput
    claimedByWorker?: UserUpdateOneWithoutClaimedDeliveriesNestedInput
    logs?: DeliveryLogUpdateManyWithoutDeliveryNestedInput
    editLogs?: DeliveryEditLogUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    claimedByWorkerId?: NullableStringFieldUpdateOperationsInput | string | null
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etaOverrideCount?: IntFieldUpdateOperationsInput | number
    delayMinutes?: IntFieldUpdateOperationsInput | number
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: DeliveryLogUncheckedUpdateManyWithoutDeliveryNestedInput
    editLogs?: DeliveryEditLogUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type RentalItemUpsertWithoutDeliveryItemsInput = {
    update: XOR<RentalItemUpdateWithoutDeliveryItemsInput, RentalItemUncheckedUpdateWithoutDeliveryItemsInput>
    create: XOR<RentalItemCreateWithoutDeliveryItemsInput, RentalItemUncheckedCreateWithoutDeliveryItemsInput>
    where?: RentalItemWhereInput
  }

  export type RentalItemUpdateToOneWithWhereWithoutDeliveryItemsInput = {
    where?: RentalItemWhereInput
    data: XOR<RentalItemUpdateWithoutDeliveryItemsInput, RentalItemUncheckedUpdateWithoutDeliveryItemsInput>
  }

  export type RentalItemUpdateWithoutDeliveryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderUpdateOneRequiredWithoutRentalItemsNestedInput
    rentalPackage?: RentalPackageUpdateOneWithoutRentalItemsNestedInput
    variant?: ProductVariantUpdateOneWithoutRentalItemsNestedInput
    unit?: ProductUnitUpdateOneWithoutRentalItemsNestedInput
  }

  export type RentalItemUncheckedUpdateWithoutDeliveryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeliveryCreateWithoutLogsInput = {
    id?: string
    deliveryMethod: $Enums.DeliveryMethod
    deliveryType: $Enums.DeliveryType
    status?: $Enums.DeliveryStatus
    claimedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    eta?: Date | string | null
    etaOverrideCount?: number
    delayMinutes?: number
    latitude?: number | null
    longitude?: number | null
    lastLocationUpdate?: Date | string | null
    trackingCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutDeliveriesInput
    vehicle?: VehicleCreateNestedOneWithoutDeliveriesInput
    claimedByWorker?: UserCreateNestedOneWithoutClaimedDeliveriesInput
    items?: DeliveryItemCreateNestedManyWithoutDeliveryInput
    editLogs?: DeliveryEditLogCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateWithoutLogsInput = {
    id?: string
    invoiceId?: string | null
    deliveryMethod: $Enums.DeliveryMethod
    deliveryType: $Enums.DeliveryType
    vehicleId?: string | null
    status?: $Enums.DeliveryStatus
    claimedByWorkerId?: string | null
    claimedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    eta?: Date | string | null
    etaOverrideCount?: number
    delayMinutes?: number
    latitude?: number | null
    longitude?: number | null
    lastLocationUpdate?: Date | string | null
    trackingCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: DeliveryItemUncheckedCreateNestedManyWithoutDeliveryInput
    editLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryCreateOrConnectWithoutLogsInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutLogsInput, DeliveryUncheckedCreateWithoutLogsInput>
  }

  export type UserCreateWithoutDeliveryLogsInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryCreateNestedManyWithoutClaimedByWorkerInput
    deliveryEditLogs?: DeliveryEditLogCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutDeliveryLogsInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogUncheckedCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogUncheckedCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceUncheckedCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryUncheckedCreateNestedManyWithoutClaimedByWorkerInput
    deliveryEditLogs?: DeliveryEditLogUncheckedCreateNestedManyWithoutEditedByUserInput
    sentNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageUncheckedCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalUncheckedCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryUncheckedCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutDeliveryLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeliveryLogsInput, UserUncheckedCreateWithoutDeliveryLogsInput>
  }

  export type DeliveryUpsertWithoutLogsInput = {
    update: XOR<DeliveryUpdateWithoutLogsInput, DeliveryUncheckedUpdateWithoutLogsInput>
    create: XOR<DeliveryCreateWithoutLogsInput, DeliveryUncheckedCreateWithoutLogsInput>
    where?: DeliveryWhereInput
  }

  export type DeliveryUpdateToOneWithWhereWithoutLogsInput = {
    where?: DeliveryWhereInput
    data: XOR<DeliveryUpdateWithoutLogsInput, DeliveryUncheckedUpdateWithoutLogsInput>
  }

  export type DeliveryUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etaOverrideCount?: IntFieldUpdateOperationsInput | number
    delayMinutes?: IntFieldUpdateOperationsInput | number
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutDeliveriesNestedInput
    vehicle?: VehicleUpdateOneWithoutDeliveriesNestedInput
    claimedByWorker?: UserUpdateOneWithoutClaimedDeliveriesNestedInput
    items?: DeliveryItemUpdateManyWithoutDeliveryNestedInput
    editLogs?: DeliveryEditLogUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    claimedByWorkerId?: NullableStringFieldUpdateOperationsInput | string | null
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etaOverrideCount?: IntFieldUpdateOperationsInput | number
    delayMinutes?: IntFieldUpdateOperationsInput | number
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: DeliveryItemUncheckedUpdateManyWithoutDeliveryNestedInput
    editLogs?: DeliveryEditLogUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type UserUpsertWithoutDeliveryLogsInput = {
    update: XOR<UserUpdateWithoutDeliveryLogsInput, UserUncheckedUpdateWithoutDeliveryLogsInput>
    create: XOR<UserCreateWithoutDeliveryLogsInput, UserUncheckedCreateWithoutDeliveryLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeliveryLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeliveryLogsInput, UserUncheckedUpdateWithoutDeliveryLogsInput>
  }

  export type UserUpdateWithoutDeliveryLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryEditLogs?: DeliveryEditLogUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutDeliveryLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUncheckedUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUncheckedUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryEditLogs?: DeliveryEditLogUncheckedUpdateManyWithoutEditedByUserNestedInput
    sentNotifications?: WorkerNotificationUncheckedUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUncheckedUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUncheckedUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUncheckedUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUncheckedUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type DeliveryCreateWithoutEditLogsInput = {
    id?: string
    deliveryMethod: $Enums.DeliveryMethod
    deliveryType: $Enums.DeliveryType
    status?: $Enums.DeliveryStatus
    claimedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    eta?: Date | string | null
    etaOverrideCount?: number
    delayMinutes?: number
    latitude?: number | null
    longitude?: number | null
    lastLocationUpdate?: Date | string | null
    trackingCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutDeliveriesInput
    vehicle?: VehicleCreateNestedOneWithoutDeliveriesInput
    claimedByWorker?: UserCreateNestedOneWithoutClaimedDeliveriesInput
    items?: DeliveryItemCreateNestedManyWithoutDeliveryInput
    logs?: DeliveryLogCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateWithoutEditLogsInput = {
    id?: string
    invoiceId?: string | null
    deliveryMethod: $Enums.DeliveryMethod
    deliveryType: $Enums.DeliveryType
    vehicleId?: string | null
    status?: $Enums.DeliveryStatus
    claimedByWorkerId?: string | null
    claimedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    eta?: Date | string | null
    etaOverrideCount?: number
    delayMinutes?: number
    latitude?: number | null
    longitude?: number | null
    lastLocationUpdate?: Date | string | null
    trackingCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: DeliveryItemUncheckedCreateNestedManyWithoutDeliveryInput
    logs?: DeliveryLogUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type DeliveryCreateOrConnectWithoutEditLogsInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutEditLogsInput, DeliveryUncheckedCreateWithoutEditLogsInput>
  }

  export type UserCreateWithoutDeliveryEditLogsInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogCreateNestedManyWithoutCreatedByUserInput
    sentNotifications?: WorkerNotificationCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutDeliveryEditLogsInput = {
    id?: string
    username: string
    password: string
    plainPassword?: string | null
    email: string
    fullName: string
    whatsapp: string
    baliAddress?: string | null
    mapsAddressLink?: string | null
    role?: string
    createdAt?: Date | string | null
    isVerified?: boolean
    resetPasswordExpires?: Date | string | null
    resetPasswordToken?: string | null
    isActive?: boolean
    profileImage?: string | null
    identityFile?: string | null
    identityType?: string | null
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    inventoryResolutions?: InventorySyncLogUncheckedCreateNestedManyWithoutResolvedByUserInput
    inventoryUpdates?: InventorySyncLogUncheckedCreateNestedManyWithoutUpdatedByUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedCreateNestedManyWithoutUsers_orders_payment_confirmed_byTousersInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    workerAttendance?: WorkerAttendanceUncheckedCreateNestedManyWithoutWorkerInput
    claimedDeliveries?: DeliveryUncheckedCreateNestedManyWithoutClaimedByWorkerInput
    deliveryLogs?: DeliveryLogUncheckedCreateNestedManyWithoutCreatedByUserInput
    sentNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutFromAdminInput
    receivedNotifications?: WorkerNotificationUncheckedCreateNestedManyWithoutWorkerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    chatGroupMemberships?: ChatGroupMemberUncheckedCreateNestedManyWithoutUserInput
    sentGroupMessages?: GroupMessageUncheckedCreateNestedManyWithoutSenderInput
    notificationDismissals?: NotificationDismissalUncheckedCreateNestedManyWithoutUserInput
    systemNotifications?: SystemNotificationUncheckedCreateNestedManyWithoutUserInput
    verifiedTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutVerifiedByInput
    unitActions?: UnitHistoryUncheckedCreateNestedManyWithoutUserInput
    aiActionApprovals?: AiActionUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutDeliveryEditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeliveryEditLogsInput, UserUncheckedCreateWithoutDeliveryEditLogsInput>
  }

  export type DeliveryUpsertWithoutEditLogsInput = {
    update: XOR<DeliveryUpdateWithoutEditLogsInput, DeliveryUncheckedUpdateWithoutEditLogsInput>
    create: XOR<DeliveryCreateWithoutEditLogsInput, DeliveryUncheckedCreateWithoutEditLogsInput>
    where?: DeliveryWhereInput
  }

  export type DeliveryUpdateToOneWithWhereWithoutEditLogsInput = {
    where?: DeliveryWhereInput
    data: XOR<DeliveryUpdateWithoutEditLogsInput, DeliveryUncheckedUpdateWithoutEditLogsInput>
  }

  export type DeliveryUpdateWithoutEditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etaOverrideCount?: IntFieldUpdateOperationsInput | number
    delayMinutes?: IntFieldUpdateOperationsInput | number
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutDeliveriesNestedInput
    vehicle?: VehicleUpdateOneWithoutDeliveriesNestedInput
    claimedByWorker?: UserUpdateOneWithoutClaimedDeliveriesNestedInput
    items?: DeliveryItemUpdateManyWithoutDeliveryNestedInput
    logs?: DeliveryLogUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutEditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    claimedByWorkerId?: NullableStringFieldUpdateOperationsInput | string | null
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etaOverrideCount?: IntFieldUpdateOperationsInput | number
    delayMinutes?: IntFieldUpdateOperationsInput | number
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: DeliveryItemUncheckedUpdateManyWithoutDeliveryNestedInput
    logs?: DeliveryLogUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type UserUpsertWithoutDeliveryEditLogsInput = {
    update: XOR<UserUpdateWithoutDeliveryEditLogsInput, UserUncheckedUpdateWithoutDeliveryEditLogsInput>
    create: XOR<UserCreateWithoutDeliveryEditLogsInput, UserUncheckedCreateWithoutDeliveryEditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeliveryEditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeliveryEditLogsInput, UserUncheckedUpdateWithoutDeliveryEditLogsInput>
  }

  export type UserUpdateWithoutDeliveryEditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUpdateManyWithoutCreatedByUserNestedInput
    sentNotifications?: WorkerNotificationUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutDeliveryEditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    plainPassword?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    baliAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mapsAddressLink?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    identityFile?: NullableStringFieldUpdateOperationsInput | string | null
    identityType?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryResolutions?: InventorySyncLogUncheckedUpdateManyWithoutResolvedByUserNestedInput
    inventoryUpdates?: InventorySyncLogUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    orders_orders_payment_confirmed_byTousers?: OrderUncheckedUpdateManyWithoutUsers_orders_payment_confirmed_byTousersNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    workerAttendance?: WorkerAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
    claimedDeliveries?: DeliveryUncheckedUpdateManyWithoutClaimedByWorkerNestedInput
    deliveryLogs?: DeliveryLogUncheckedUpdateManyWithoutCreatedByUserNestedInput
    sentNotifications?: WorkerNotificationUncheckedUpdateManyWithoutFromAdminNestedInput
    receivedNotifications?: WorkerNotificationUncheckedUpdateManyWithoutWorkerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    chatGroupMemberships?: ChatGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    sentGroupMessages?: GroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    notificationDismissals?: NotificationDismissalUncheckedUpdateManyWithoutUserNestedInput
    systemNotifications?: SystemNotificationUncheckedUpdateManyWithoutUserNestedInput
    verifiedTransactions?: PaymentTransactionUncheckedUpdateManyWithoutVerifiedByNestedInput
    unitActions?: UnitHistoryUncheckedUpdateManyWithoutUserNestedInput
    aiActionApprovals?: AiActionUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type DeliveryCreateManyInvoiceInput = {
    id?: string
    deliveryMethod: $Enums.DeliveryMethod
    deliveryType: $Enums.DeliveryType
    vehicleId?: string | null
    status?: $Enums.DeliveryStatus
    claimedByWorkerId?: string | null
    claimedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    eta?: Date | string | null
    etaOverrideCount?: number
    delayMinutes?: number
    latitude?: number | null
    longitude?: number | null
    lastLocationUpdate?: Date | string | null
    trackingCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etaOverrideCount?: IntFieldUpdateOperationsInput | number
    delayMinutes?: IntFieldUpdateOperationsInput | number
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: VehicleUpdateOneWithoutDeliveriesNestedInput
    claimedByWorker?: UserUpdateOneWithoutClaimedDeliveriesNestedInput
    items?: DeliveryItemUpdateManyWithoutDeliveryNestedInput
    logs?: DeliveryLogUpdateManyWithoutDeliveryNestedInput
    editLogs?: DeliveryEditLogUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    claimedByWorkerId?: NullableStringFieldUpdateOperationsInput | string | null
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etaOverrideCount?: IntFieldUpdateOperationsInput | number
    delayMinutes?: IntFieldUpdateOperationsInput | number
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: DeliveryItemUncheckedUpdateManyWithoutDeliveryNestedInput
    logs?: DeliveryLogUncheckedUpdateManyWithoutDeliveryNestedInput
    editLogs?: DeliveryEditLogUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    claimedByWorkerId?: NullableStringFieldUpdateOperationsInput | string | null
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etaOverrideCount?: IntFieldUpdateOperationsInput | number
    delayMinutes?: IntFieldUpdateOperationsInput | number
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyOrderInput = {
    id?: string
    invoiceNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string | null
    createdAt?: Date | string | null
    userId?: string | null
    status?: string
    guestEmail?: string | null
    guestName?: string | null
    guestWhatsapp?: string | null
    guestAddress?: string | null
    deliveryFeeOverride?: Decimal | DecimalJsLike | number | string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    shareableToken?: string | null
    emailSent?: boolean | null
    emailSentAt?: Date | string | null
  }

  export type ProductUnitCreateManyAssignedOrderInput = {
    id?: string
    variantId: string
    serialNumber: string
    status?: $Enums.UnitStatus
    condition?: $Enums.UnitCondition
    purchaseDate?: Date | string | null
    lastServiceDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RentalItemCreateManyOrderInput = {
    id?: string
    variantId?: string | null
    packageId?: string | null
    quantity?: number | null
    createdAt?: Date | string | null
    unitId?: string | null
  }

  export type PaymentTransactionCreateManyOrderInput = {
    id?: string
    provider: $Enums.PaymentProvider
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.TransactionStatus
    externalReferenceId?: string | null
    proofUrl?: string | null
    verifiedByAdminId?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    guestAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryFeeOverride?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shareableToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveries?: DeliveryUpdateManyWithoutInvoiceNestedInput
    user?: UserUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    guestAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryFeeOverride?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shareableToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveries?: DeliveryUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    guestAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryFeeOverride?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shareableToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductUnitUpdateWithoutAssignedOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    condition?: EnumUnitConditionFieldUpdateOperationsInput | $Enums.UnitCondition
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastServiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variant?: ProductVariantUpdateOneRequiredWithoutUnitsNestedInput
    rentalItems?: RentalItemUpdateManyWithoutUnitNestedInput
    history?: UnitHistoryUpdateManyWithoutUnitNestedInput
  }

  export type ProductUnitUncheckedUpdateWithoutAssignedOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    condition?: EnumUnitConditionFieldUpdateOperationsInput | $Enums.UnitCondition
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastServiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentalItems?: RentalItemUncheckedUpdateManyWithoutUnitNestedInput
    history?: UnitHistoryUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type ProductUnitUncheckedUpdateManyWithoutAssignedOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    condition?: EnumUnitConditionFieldUpdateOperationsInput | $Enums.UnitCondition
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastServiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rentalPackage?: RentalPackageUpdateOneWithoutRentalItemsNestedInput
    variant?: ProductVariantUpdateOneWithoutRentalItemsNestedInput
    unit?: ProductUnitUpdateOneWithoutRentalItemsNestedInput
    deliveryItems?: DeliveryItemUpdateManyWithoutRentalItemNestedInput
  }

  export type RentalItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryItems?: DeliveryItemUncheckedUpdateManyWithoutRentalItemNestedInput
  }

  export type RentalItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentTransactionUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    externalReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedBy?: UserUpdateOneWithoutVerifiedTransactionsNestedInput
  }

  export type PaymentTransactionUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    externalReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTransactionUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    externalReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalPackageItemCreateManyRentalPackageInput = {
    id?: string
    productId: string
    quantity?: number | null
    createdAt?: Date | string | null
  }

  export type RentalItemCreateManyRentalPackageInput = {
    id?: string
    orderId: string
    variantId?: string | null
    quantity?: number | null
    createdAt?: Date | string | null
    unitId?: string | null
  }

  export type RentalPackageItemUpdateWithoutRentalPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutRentalPackageItemsNestedInput
  }

  export type RentalPackageItemUncheckedUpdateWithoutRentalPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RentalPackageItemUncheckedUpdateManyWithoutRentalPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RentalItemUpdateWithoutRentalPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderUpdateOneRequiredWithoutRentalItemsNestedInput
    variant?: ProductVariantUpdateOneWithoutRentalItemsNestedInput
    unit?: ProductUnitUpdateOneWithoutRentalItemsNestedInput
    deliveryItems?: DeliveryItemUpdateManyWithoutRentalItemNestedInput
  }

  export type RentalItemUncheckedUpdateWithoutRentalPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryItems?: DeliveryItemUncheckedUpdateManyWithoutRentalItemNestedInput
  }

  export type RentalItemUncheckedUpdateManyWithoutRentalPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventorySyncLogCreateManyProductInput = {
    id?: string
    oldQuantity: number
    newQuantity: number
    updatedBy: string
    source: $Enums.inventory_source
    conflict?: boolean | null
    resolved?: boolean | null
    resolvedBy?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string | null
  }

  export type RentalPackageItemCreateManyProductInput = {
    id?: string
    rentalPackageId: string
    quantity?: number | null
    createdAt?: Date | string | null
  }

  export type ProductRelationCreateManyProductInput = {
    id?: string
    relatedProductId: string
    relationType?: $Enums.RelationType
    priority?: number
    aiScore?: number | null
    createdAt?: Date | string
  }

  export type ProductRelationCreateManyRelatedProductInput = {
    id?: string
    productId: string
    relationType?: $Enums.RelationType
    priority?: number
    aiScore?: number | null
    createdAt?: Date | string
  }

  export type ProductVariantCreateManyProductInput = {
    id?: string
    color?: string
    sku: string
    monthlyPrice?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventorySyncLogUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    source?: Enuminventory_sourceFieldUpdateOperationsInput | $Enums.inventory_source
    conflict?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedByUser?: UserUpdateOneWithoutInventoryResolutionsNestedInput
    updatedByUser?: UserUpdateOneRequiredWithoutInventoryUpdatesNestedInput
  }

  export type InventorySyncLogUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    updatedBy?: StringFieldUpdateOperationsInput | string
    source?: Enuminventory_sourceFieldUpdateOperationsInput | $Enums.inventory_source
    conflict?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InventorySyncLogUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    updatedBy?: StringFieldUpdateOperationsInput | string
    source?: Enuminventory_sourceFieldUpdateOperationsInput | $Enums.inventory_source
    conflict?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RentalPackageItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rentalPackage?: RentalPackageUpdateOneRequiredWithoutRentalPackageItemsNestedInput
  }

  export type RentalPackageItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    rentalPackageId?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RentalPackageItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    rentalPackageId?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductRelationUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    priority?: IntFieldUpdateOperationsInput | number
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedProduct?: ProductUpdateOneRequiredWithoutRelatedToNestedInput
  }

  export type ProductRelationUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    relatedProductId?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    priority?: IntFieldUpdateOperationsInput | number
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductRelationUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    relatedProductId?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    priority?: IntFieldUpdateOperationsInput | number
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductRelationUpdateWithoutRelatedProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    priority?: IntFieldUpdateOperationsInput | number
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductRelationsNestedInput
  }

  export type ProductRelationUncheckedUpdateWithoutRelatedProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    priority?: IntFieldUpdateOperationsInput | number
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductRelationUncheckedUpdateManyWithoutRelatedProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    priority?: IntFieldUpdateOperationsInput | number
    aiScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentalItems?: RentalItemUpdateManyWithoutVariantNestedInput
    units?: ProductUnitUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentalItems?: RentalItemUncheckedUpdateManyWithoutVariantNestedInput
    units?: ProductUnitUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalItemCreateManyVariantInput = {
    id?: string
    orderId: string
    packageId?: string | null
    quantity?: number | null
    createdAt?: Date | string | null
    unitId?: string | null
  }

  export type ProductUnitCreateManyVariantInput = {
    id?: string
    serialNumber: string
    status?: $Enums.UnitStatus
    condition?: $Enums.UnitCondition
    assignedOrderId?: string | null
    purchaseDate?: Date | string | null
    lastServiceDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RentalItemUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderUpdateOneRequiredWithoutRentalItemsNestedInput
    rentalPackage?: RentalPackageUpdateOneWithoutRentalItemsNestedInput
    unit?: ProductUnitUpdateOneWithoutRentalItemsNestedInput
    deliveryItems?: DeliveryItemUpdateManyWithoutRentalItemNestedInput
  }

  export type RentalItemUncheckedUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryItems?: DeliveryItemUncheckedUpdateManyWithoutRentalItemNestedInput
  }

  export type RentalItemUncheckedUpdateManyWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUnitUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    condition?: EnumUnitConditionFieldUpdateOperationsInput | $Enums.UnitCondition
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastServiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedOrder?: OrderUpdateOneWithoutAssignedUnitsNestedInput
    rentalItems?: RentalItemUpdateManyWithoutUnitNestedInput
    history?: UnitHistoryUpdateManyWithoutUnitNestedInput
  }

  export type ProductUnitUncheckedUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    condition?: EnumUnitConditionFieldUpdateOperationsInput | $Enums.UnitCondition
    assignedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastServiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rentalItems?: RentalItemUncheckedUpdateManyWithoutUnitNestedInput
    history?: UnitHistoryUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type ProductUnitUncheckedUpdateManyWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumUnitStatusFieldUpdateOperationsInput | $Enums.UnitStatus
    condition?: EnumUnitConditionFieldUpdateOperationsInput | $Enums.UnitCondition
    assignedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastServiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalItemCreateManyUnitInput = {
    id?: string
    orderId: string
    variantId?: string | null
    packageId?: string | null
    quantity?: number | null
    createdAt?: Date | string | null
  }

  export type UnitHistoryCreateManyUnitInput = {
    id?: string
    oldStatus?: string | null
    newStatus: string
    oldCondition?: string | null
    newCondition?: string | null
    details?: string | null
    createdAt?: Date | string
    userId?: string | null
  }

  export type RentalItemUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderUpdateOneRequiredWithoutRentalItemsNestedInput
    rentalPackage?: RentalPackageUpdateOneWithoutRentalItemsNestedInput
    variant?: ProductVariantUpdateOneWithoutRentalItemsNestedInput
    deliveryItems?: DeliveryItemUpdateManyWithoutRentalItemNestedInput
  }

  export type RentalItemUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryItems?: DeliveryItemUncheckedUpdateManyWithoutRentalItemNestedInput
  }

  export type RentalItemUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitHistoryUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    oldCondition?: NullableStringFieldUpdateOperationsInput | string | null
    newCondition?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutUnitActionsNestedInput
  }

  export type UnitHistoryUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    oldCondition?: NullableStringFieldUpdateOperationsInput | string | null
    newCondition?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UnitHistoryUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    oldCondition?: NullableStringFieldUpdateOperationsInput | string | null
    newCondition?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeliveryItemCreateManyRentalItemInput = {
    id?: string
    deliveryId: string
    quantity: number
  }

  export type DeliveryItemUpdateWithoutRentalItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    delivery?: DeliveryUpdateOneRequiredWithoutItemsNestedInput
  }

  export type DeliveryItemUncheckedUpdateWithoutRentalItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type DeliveryItemUncheckedUpdateManyWithoutRentalItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ActivityLogCreateManyUserInput = {
    id?: string
    action: string
    entity: string
    details?: string | null
    createdAt?: Date | string
  }

  export type InventorySyncLogCreateManyResolvedByUserInput = {
    id?: string
    productId: string
    oldQuantity: number
    newQuantity: number
    updatedBy: string
    source: $Enums.inventory_source
    conflict?: boolean | null
    resolved?: boolean | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string | null
  }

  export type InventorySyncLogCreateManyUpdatedByUserInput = {
    id?: string
    productId: string
    oldQuantity: number
    newQuantity: number
    source: $Enums.inventory_source
    conflict?: boolean | null
    resolved?: boolean | null
    resolvedBy?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string | null
  }

  export type InvoiceCreateManyUserInput = {
    id?: string
    invoiceNumber: string
    orderId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    currency?: string | null
    createdAt?: Date | string | null
    status?: string
    guestEmail?: string | null
    guestName?: string | null
    guestWhatsapp?: string | null
    guestAddress?: string | null
    deliveryFeeOverride?: Decimal | DecimalJsLike | number | string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    shareableToken?: string | null
    emailSent?: boolean | null
    emailSentAt?: Date | string | null
  }

  export type OrderCreateManyUsers_orders_payment_confirmed_byTousersInput = {
    id?: string
    orderNumber: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    totalAmount: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    paymentMethod?: string | null
    createdAt?: Date | string | null
    userId: string
    paymentStatus?: string | null
    paymentConfirmedAt?: Date | string | null
    deliveryAddress?: string | null
  }

  export type OrderCreateManyUserInput = {
    id?: string
    orderNumber: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    totalAmount: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    deliveryFee?: Decimal | DecimalJsLike | number | string
    discountPercentage?: number | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    paymentMethod?: string | null
    createdAt?: Date | string | null
    paymentStatus?: string | null
    paymentConfirmedBy?: string | null
    paymentConfirmedAt?: Date | string | null
    deliveryAddress?: string | null
  }

  export type WorkerAttendanceCreateManyWorkerInput = {
    id?: string
    date: Date | string
    status?: $Enums.attendance_status | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    notes?: string | null
    createdAt?: Date | string | null
  }

  export type DeliveryCreateManyClaimedByWorkerInput = {
    id?: string
    invoiceId?: string | null
    deliveryMethod: $Enums.DeliveryMethod
    deliveryType: $Enums.DeliveryType
    vehicleId?: string | null
    status?: $Enums.DeliveryStatus
    claimedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    eta?: Date | string | null
    etaOverrideCount?: number
    delayMinutes?: number
    latitude?: number | null
    longitude?: number | null
    lastLocationUpdate?: Date | string | null
    trackingCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryLogCreateManyCreatedByUserInput = {
    id?: string
    deliveryId: string
    eventType: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    role: $Enums.DeliveryRole
    createdAt?: Date | string
  }

  export type DeliveryEditLogCreateManyEditedByUserInput = {
    id?: string
    deliveryId: string
    role: $Enums.DeliveryRole
    fieldChanged: string
    oldValue?: string | null
    newValue?: string | null
    reason?: string | null
    createdAt?: Date | string
  }

  export type WorkerNotificationCreateManyFromAdminInput = {
    id?: string
    workerId: string
    type: string
    title: string
    message: string
    isRead?: boolean | null
    createdAt?: Date | string | null
  }

  export type WorkerNotificationCreateManyWorkerInput = {
    id?: string
    fromAdminId?: string | null
    type: string
    title: string
    message: string
    isRead?: boolean | null
    createdAt?: Date | string | null
  }

  export type MessageCreateManySenderInput = {
    id?: string
    receiverId: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type MessageCreateManyReceiverInput = {
    id?: string
    senderId: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type ChatGroupMemberCreateManyUserInput = {
    id?: string
    groupId: string
    role?: string
    joinedAt?: Date | string
  }

  export type GroupMessageCreateManySenderInput = {
    id?: string
    groupId: string
    content: string
    createdAt?: Date | string
  }

  export type NotificationDismissalCreateManyUserInput = {
    id?: string
    entityId: string
    entityType: string
    createdAt?: Date | string
  }

  export type SystemNotificationCreateManyUserInput = {
    id?: string
    type: string
    title: string
    message: string
    isRead?: boolean
    entityId?: string | null
    entityType?: string | null
    relatedType?: string | null
    createdAt?: Date | string | null
  }

  export type PaymentTransactionCreateManyVerifiedByInput = {
    id?: string
    orderId: string
    provider: $Enums.PaymentProvider
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.TransactionStatus
    externalReferenceId?: string | null
    proofUrl?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitHistoryCreateManyUserInput = {
    id?: string
    unitId: string
    oldStatus?: string | null
    newStatus: string
    oldCondition?: string | null
    newCondition?: string | null
    details?: string | null
    createdAt?: Date | string
  }

  export type AiActionCreateManyApproverInput = {
    id?: string
    agentId: string
    actionType: string
    payloadBefore?: NullableJsonNullValueInput | InputJsonValue
    payloadAfter: JsonNullValueInput | InputJsonValue
    status?: $Enums.AiActionStatus
    createdAt?: Date | string
    executedAt?: Date | string | null
  }

  export type ActivityLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventorySyncLogUpdateWithoutResolvedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    source?: Enuminventory_sourceFieldUpdateOperationsInput | $Enums.inventory_source
    conflict?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutInventorySyncLogsNestedInput
    updatedByUser?: UserUpdateOneRequiredWithoutInventoryUpdatesNestedInput
  }

  export type InventorySyncLogUncheckedUpdateWithoutResolvedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    oldQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    updatedBy?: StringFieldUpdateOperationsInput | string
    source?: Enuminventory_sourceFieldUpdateOperationsInput | $Enums.inventory_source
    conflict?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InventorySyncLogUncheckedUpdateManyWithoutResolvedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    oldQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    updatedBy?: StringFieldUpdateOperationsInput | string
    source?: Enuminventory_sourceFieldUpdateOperationsInput | $Enums.inventory_source
    conflict?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InventorySyncLogUpdateWithoutUpdatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    source?: Enuminventory_sourceFieldUpdateOperationsInput | $Enums.inventory_source
    conflict?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutInventorySyncLogsNestedInput
    resolvedByUser?: UserUpdateOneWithoutInventoryResolutionsNestedInput
  }

  export type InventorySyncLogUncheckedUpdateWithoutUpdatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    oldQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    source?: Enuminventory_sourceFieldUpdateOperationsInput | $Enums.inventory_source
    conflict?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InventorySyncLogUncheckedUpdateManyWithoutUpdatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    oldQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    source?: Enuminventory_sourceFieldUpdateOperationsInput | $Enums.inventory_source
    conflict?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    guestAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryFeeOverride?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shareableToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderUpdateOneWithoutInvoicesNestedInput
    deliveries?: DeliveryUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    guestAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryFeeOverride?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shareableToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveries?: DeliveryUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    guestAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryFeeOverride?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shareableToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailSent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderUpdateWithoutUsers_orders_payment_confirmed_byTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUpdateManyWithoutOrderNestedInput
    assignedUnits?: ProductUnitUpdateManyWithoutAssignedOrderNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    rentalItems?: RentalItemUpdateManyWithoutOrderNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUsers_orders_payment_confirmed_byTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
    assignedUnits?: ProductUnitUncheckedUpdateManyWithoutAssignedOrderNestedInput
    rentalItems?: RentalItemUncheckedUpdateManyWithoutOrderNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutUsers_orders_payment_confirmed_byTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUpdateManyWithoutOrderNestedInput
    assignedUnits?: ProductUnitUpdateManyWithoutAssignedOrderNestedInput
    users_orders_payment_confirmed_byTousers?: UserUpdateOneWithoutOrders_orders_payment_confirmed_byTousersNestedInput
    rentalItems?: RentalItemUpdateManyWithoutOrderNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
    assignedUnits?: ProductUnitUncheckedUpdateManyWithoutAssignedOrderNestedInput
    rentalItems?: RentalItemUncheckedUpdateManyWithoutOrderNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPercentage?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    paymentConfirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkerAttendanceUpdateWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumattendance_statusFieldUpdateOperationsInput | $Enums.attendance_status | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkerAttendanceUncheckedUpdateWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumattendance_statusFieldUpdateOperationsInput | $Enums.attendance_status | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkerAttendanceUncheckedUpdateManyWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumattendance_statusFieldUpdateOperationsInput | $Enums.attendance_status | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeliveryUpdateWithoutClaimedByWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etaOverrideCount?: IntFieldUpdateOperationsInput | number
    delayMinutes?: IntFieldUpdateOperationsInput | number
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutDeliveriesNestedInput
    vehicle?: VehicleUpdateOneWithoutDeliveriesNestedInput
    items?: DeliveryItemUpdateManyWithoutDeliveryNestedInput
    logs?: DeliveryLogUpdateManyWithoutDeliveryNestedInput
    editLogs?: DeliveryEditLogUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutClaimedByWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etaOverrideCount?: IntFieldUpdateOperationsInput | number
    delayMinutes?: IntFieldUpdateOperationsInput | number
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: DeliveryItemUncheckedUpdateManyWithoutDeliveryNestedInput
    logs?: DeliveryLogUncheckedUpdateManyWithoutDeliveryNestedInput
    editLogs?: DeliveryEditLogUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateManyWithoutClaimedByWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etaOverrideCount?: IntFieldUpdateOperationsInput | number
    delayMinutes?: IntFieldUpdateOperationsInput | number
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryLogUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumDeliveryRoleFieldUpdateOperationsInput | $Enums.DeliveryRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delivery?: DeliveryUpdateOneRequiredWithoutLogsNestedInput
  }

  export type DeliveryLogUncheckedUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumDeliveryRoleFieldUpdateOperationsInput | $Enums.DeliveryRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryLogUncheckedUpdateManyWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumDeliveryRoleFieldUpdateOperationsInput | $Enums.DeliveryRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryEditLogUpdateWithoutEditedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumDeliveryRoleFieldUpdateOperationsInput | $Enums.DeliveryRole
    fieldChanged?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delivery?: DeliveryUpdateOneRequiredWithoutEditLogsNestedInput
  }

  export type DeliveryEditLogUncheckedUpdateWithoutEditedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryId?: StringFieldUpdateOperationsInput | string
    role?: EnumDeliveryRoleFieldUpdateOperationsInput | $Enums.DeliveryRole
    fieldChanged?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryEditLogUncheckedUpdateManyWithoutEditedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryId?: StringFieldUpdateOperationsInput | string
    role?: EnumDeliveryRoleFieldUpdateOperationsInput | $Enums.DeliveryRole
    fieldChanged?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerNotificationUpdateWithoutFromAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    worker?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
  }

  export type WorkerNotificationUncheckedUpdateWithoutFromAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    workerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkerNotificationUncheckedUpdateManyWithoutFromAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    workerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkerNotificationUpdateWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fromAdmin?: UserUpdateOneWithoutSentNotificationsNestedInput
  }

  export type WorkerNotificationUncheckedUpdateWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkerNotificationUncheckedUpdateManyWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatGroupMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: ChatGroupUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ChatGroupMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatGroupMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: ChatGroupUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type GroupMessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationDismissalUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationDismissalUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationDismissalUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemNotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    relatedType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemNotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    relatedType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemNotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    relatedType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentTransactionUpdateWithoutVerifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    externalReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutPaymentTransactionsNestedInput
  }

  export type PaymentTransactionUncheckedUpdateWithoutVerifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    externalReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTransactionUncheckedUpdateManyWithoutVerifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    externalReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    oldCondition?: NullableStringFieldUpdateOperationsInput | string | null
    newCondition?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: ProductUnitUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type UnitHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    oldCondition?: NullableStringFieldUpdateOperationsInput | string | null
    newCondition?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    oldCondition?: NullableStringFieldUpdateOperationsInput | string | null
    newCondition?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiActionUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    payloadBefore?: NullableJsonNullValueInput | InputJsonValue
    payloadAfter?: JsonNullValueInput | InputJsonValue
    status?: EnumAiActionStatusFieldUpdateOperationsInput | $Enums.AiActionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agent?: AiAgentUpdateOneRequiredWithoutActionsNestedInput
  }

  export type AiActionUncheckedUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    payloadBefore?: NullableJsonNullValueInput | InputJsonValue
    payloadAfter?: JsonNullValueInput | InputJsonValue
    status?: EnumAiActionStatusFieldUpdateOperationsInput | $Enums.AiActionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiActionUncheckedUpdateManyWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    payloadBefore?: NullableJsonNullValueInput | InputJsonValue
    payloadAfter?: JsonNullValueInput | InputJsonValue
    status?: EnumAiActionStatusFieldUpdateOperationsInput | $Enums.AiActionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChatGroupMemberCreateManyGroupInput = {
    id?: string
    userId: string
    role?: string
    joinedAt?: Date | string
  }

  export type GroupMessageCreateManyGroupInput = {
    id?: string
    senderId: string
    content: string
    createdAt?: Date | string
  }

  export type ChatGroupMemberUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChatGroupMembershipsNestedInput
  }

  export type ChatGroupMemberUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatGroupMemberUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMessageUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentGroupMessagesNestedInput
  }

  export type GroupMessageUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMessageUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiActionCreateManyAgentInput = {
    id?: string
    actionType: string
    payloadBefore?: NullableJsonNullValueInput | InputJsonValue
    payloadAfter: JsonNullValueInput | InputJsonValue
    status?: $Enums.AiActionStatus
    approvedBy?: string | null
    createdAt?: Date | string
    executedAt?: Date | string | null
  }

  export type AiTrainingDataCreateManyAgentInput = {
    id?: string
    suggestion: string
    adminDecision: string
    feedbackScore?: number | null
    createdAt?: Date | string
  }

  export type AiActionUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    payloadBefore?: NullableJsonNullValueInput | InputJsonValue
    payloadAfter?: JsonNullValueInput | InputJsonValue
    status?: EnumAiActionStatusFieldUpdateOperationsInput | $Enums.AiActionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approver?: UserUpdateOneWithoutAiActionApprovalsNestedInput
  }

  export type AiActionUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    payloadBefore?: NullableJsonNullValueInput | InputJsonValue
    payloadAfter?: JsonNullValueInput | InputJsonValue
    status?: EnumAiActionStatusFieldUpdateOperationsInput | $Enums.AiActionStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiActionUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    payloadBefore?: NullableJsonNullValueInput | InputJsonValue
    payloadAfter?: JsonNullValueInput | InputJsonValue
    status?: EnumAiActionStatusFieldUpdateOperationsInput | $Enums.AiActionStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiTrainingDataUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    suggestion?: StringFieldUpdateOperationsInput | string
    adminDecision?: StringFieldUpdateOperationsInput | string
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiTrainingDataUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    suggestion?: StringFieldUpdateOperationsInput | string
    adminDecision?: StringFieldUpdateOperationsInput | string
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiTrainingDataUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    suggestion?: StringFieldUpdateOperationsInput | string
    adminDecision?: StringFieldUpdateOperationsInput | string
    feedbackScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryCreateManyVehicleInput = {
    id?: string
    invoiceId?: string | null
    deliveryMethod: $Enums.DeliveryMethod
    deliveryType: $Enums.DeliveryType
    status?: $Enums.DeliveryStatus
    claimedByWorkerId?: string | null
    claimedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    eta?: Date | string | null
    etaOverrideCount?: number
    delayMinutes?: number
    latitude?: number | null
    longitude?: number | null
    lastLocationUpdate?: Date | string | null
    trackingCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etaOverrideCount?: IntFieldUpdateOperationsInput | number
    delayMinutes?: IntFieldUpdateOperationsInput | number
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutDeliveriesNestedInput
    claimedByWorker?: UserUpdateOneWithoutClaimedDeliveriesNestedInput
    items?: DeliveryItemUpdateManyWithoutDeliveryNestedInput
    logs?: DeliveryLogUpdateManyWithoutDeliveryNestedInput
    editLogs?: DeliveryEditLogUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    claimedByWorkerId?: NullableStringFieldUpdateOperationsInput | string | null
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etaOverrideCount?: IntFieldUpdateOperationsInput | number
    delayMinutes?: IntFieldUpdateOperationsInput | number
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: DeliveryItemUncheckedUpdateManyWithoutDeliveryNestedInput
    logs?: DeliveryLogUncheckedUpdateManyWithoutDeliveryNestedInput
    editLogs?: DeliveryEditLogUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    deliveryType?: EnumDeliveryTypeFieldUpdateOperationsInput | $Enums.DeliveryType
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    claimedByWorkerId?: NullableStringFieldUpdateOperationsInput | string | null
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etaOverrideCount?: IntFieldUpdateOperationsInput | number
    delayMinutes?: IntFieldUpdateOperationsInput | number
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryItemCreateManyDeliveryInput = {
    id?: string
    rentalItemId: string
    quantity: number
  }

  export type DeliveryLogCreateManyDeliveryInput = {
    id?: string
    eventType: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdByUserId?: string | null
    role: $Enums.DeliveryRole
    createdAt?: Date | string
  }

  export type DeliveryEditLogCreateManyDeliveryInput = {
    id?: string
    editedByUserId: string
    role: $Enums.DeliveryRole
    fieldChanged: string
    oldValue?: string | null
    newValue?: string | null
    reason?: string | null
    createdAt?: Date | string
  }

  export type DeliveryItemUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    rentalItem?: RentalItemUpdateOneRequiredWithoutDeliveryItemsNestedInput
  }

  export type DeliveryItemUncheckedUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    rentalItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type DeliveryItemUncheckedUpdateManyWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    rentalItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type DeliveryLogUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumDeliveryRoleFieldUpdateOperationsInput | $Enums.DeliveryRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUser?: UserUpdateOneWithoutDeliveryLogsNestedInput
  }

  export type DeliveryLogUncheckedUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumDeliveryRoleFieldUpdateOperationsInput | $Enums.DeliveryRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryLogUncheckedUpdateManyWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumDeliveryRoleFieldUpdateOperationsInput | $Enums.DeliveryRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryEditLogUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumDeliveryRoleFieldUpdateOperationsInput | $Enums.DeliveryRole
    fieldChanged?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedByUser?: UserUpdateOneRequiredWithoutDeliveryEditLogsNestedInput
  }

  export type DeliveryEditLogUncheckedUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    editedByUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumDeliveryRoleFieldUpdateOperationsInput | $Enums.DeliveryRole
    fieldChanged?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryEditLogUncheckedUpdateManyWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    editedByUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumDeliveryRoleFieldUpdateOperationsInput | $Enums.DeliveryRole
    fieldChanged?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}